!% $MAX_ARRAYS=1500
!% $MAX_CLASSES=200
!% $MAX_VERBS=300
!% $MAX_LABELS=10000
!% $MAX_ZCODE_SIZE=50000
!% $MAX_STATIC_DATA=100000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000

! --------------------------------------------------------------------------
! Generated by NI build:
Constant NI_BUILD_COUNT "5J39";

Array UUID_ARRAY string "UUID://B7DF7B58-126C-4C8B-838C-D5EE47ABB024//";

Constant Story SC_0;
Constant Headline "An Interactive Fiction";
Constant Story_Author SC_1;
Serial "071208";


#ifdef TARGET_ZCODE;
	Constant I6_NULL $ffff;
	Constant MAX_POSITIVE_NUMBER 32767;
#ifnot;
	Constant I6_NULL $ffffffff;
	Constant MAX_POSITIVE_NUMBER 2147483647;
#endif;

Constant NO_PLACES;
Constant PREFER_HELD;
Constant START_MOVE 1;
Constant HIGHEST_RULEBOOK_NO 353;
Constant I7_OBJECT_TY 61;

[ I7ExtensionVersions;
  print "Standard Rules version 1/061217 by Graham Nelson^";
];
[ I7FullExtensionVersions;
  print "Standard Rules version 1/061217 by Graham Nelson^";
];


Global location = InformLibrary;
Global sline1;
Global sline2;
Global I7_prompt_text = ">";
Global I7_command;
Global I7_match_snippet;
Global I7_mistake_code;
Global I7_left_sl = SL_Location;
Global I7_right_sl = SL_Score_Moves;
Global I7_box;
Global act_requester;
Global I7_action_deciding_rule;
Global I7_concealed_item;
Global I7_TProp;
Global I7_TSign;
Global I7_suppress_scope_loops;
Global I7BASP = 0;

Constant I7_EMPTY_TEXT "";

Global say__n;
Array I7_CS --> 16;
Array I7_boxes_appeared --> I7_BOXES;

Constant WITHOUT_DIRECTIONS;

 
Global SACK_OBJECT;
Constant RUCKSACK_CLASS = K10_player_s_holdall;
 
  Constant I7_SPECIFIC_HEAP_SIZE = 8192;  
  Constant I7_IT_MAX_LENGTH = 1024+3;  


! --- Replacements of library routines ---

#IFDEF DEBUG;
#IFDEF TEST_SCENARIOS_EXIST;
Replace KeyboardPrimitive;
#ENDIF;
#ENDIF;
Replace DrawStatusLine;
Replace BeforeRoutines;
Replace ActionPrimitive;
Replace AfterRoutines;
Replace ObjectIsUntouchable;
Replace AllowPushDir;
Replace ActionsOnSub;
Replace ActionsOffSub;
Replace InvSub;
Replace TakeSub;
Replace RemoveSub;
Replace DropSub;
Replace PutOnSub;
Replace InsertSub;
Replace EatSub;
Replace GoSub;
Replace EnterSub;
Replace ExitSub;
Replace GetOffSub;
Replace LookSub;
Replace ExamineSub;
Replace LookUnderSub;
Replace SearchSub;
Replace ConsultSub;
Replace LockSub;
Replace UnlockSub;
Replace SwitchOnSub;
Replace SwitchOffSub;
Replace OpenSub;
Replace CloseSub;
Replace WearSub;
Replace DisrobeSub;
Replace GiveSub;
Replace ShowSub;
Replace WakeOtherSub;
Replace ThrowAtSub;
Replace AttackSub;
Replace KissSub;
Replace AnswerSub;
Replace TellSub;
Replace AskSub;
Replace AskForSub;
Replace WaitSub;
Replace TouchSub;
Replace WaveSub;
Replace PullSub;
Replace PushSub;
Replace TurnSub;
Replace PushDirSub;
Replace SqueezeSub;
Replace YesSub;
Replace NoSub;
Replace BurnSub;
Replace WakeSub;
Replace ThinkSub;
Replace SmellSub;
Replace ListenSub;
Replace TasteSub;
Replace CutSub;
Replace JumpSub;
Replace TieSub;
Replace DrinkSub;
Replace SorrySub;
Replace StrongSub;
Replace MildSub;
Replace SwingSub;
Replace RubSub;
Replace SetToSub;
Replace WaveHandsSub;
Replace BuySub;
Replace SingSub;
Replace ClimbSub;
Replace SleepSub;
Replace ScoreSub;
Replace QuitSub;
Replace SaveSub;
Replace RestoreSub;
Replace RestartSub;
Replace VerifySub;
Replace VersionSub;
Replace ScriptOnSub;
Replace ScriptOffSub;
Replace LMode3Sub;
Replace LMode2Sub;
Replace LMode1Sub;
Replace PronounsSub;
Replace NotifyOnSub;
Replace NotifyOffSub;


! --- Variables used in printing ---
Global say__c; Global say__p = 1; Global say__pc = 0;
Global I7_caps_mode = false;
Global I7_uninitialised = false;
Global I7_IT_RE_Trace = false;
Global I7_IT_RE_Err = 0;
Global ct_0 = 0; ! Overridden almost always by local variable definitions
Global ct_1 = 0;

! --- Properties ---
Property component_parent;
Property component_child;
Property component_sibling;
Property I7_Map_Region;
Property regional_found_in;

! --- I7 type numbers as I6 constants ---

Constant UNKNOWN_TY = 1;
Constant MATCHING_MTY = 5;
Constant NEW_LOCAL_VARIABLE_NAME_STY = 6;
Constant VALUE_MTY = 10;
Constant CONSTANT_STY = 11;
Constant PHRASE_TO_DECIDE_VALUE_STY = 12;
Constant STORAGE_MTY = 20;
Constant LOCAL_VARIABLE_STY = 21;
Constant NONLOCAL_VARIABLE_STY = 22;
Constant PROPERTY_VALUE_STY = 23;
Constant TABLE_ENTRY_STY = 24;
Constant LIST_ENTRY_STY = 25;
Constant CONDITION_MTY = 30;
Constant LOGICAL_AND_STY = 31;
Constant LOGICAL_OR_STY = 32;
Constant TEST_PROPOSITION_STY = 33;
Constant TEST_PHRASE_OPTION_STY = 34;
Constant TEST_ACTION_STY = 35;
Constant TEST_PAST_ACTION_STY = 36;
Constant NOW_PROPOSITION_STY = 37;
Constant PHRASE_TO_DECIDE_IF_STY = 38;
Constant DESCRIPTION_STY = 39;
Constant COMMAND_MTY = 40;
Constant TO_PHRASE_STY = 41;
Constant END_BLOCK_STY = 42;
Constant OTHERWISE_STY = 43;
Constant TO_PHRASE_RETURNING_STY = 44;
Constant RULEBOOK_OUTCOME_PHRASE_STY = 45;
Constant TRY_ACTION_STY = 46;
Constant ANY_VALUE_TY = 50;
Constant ASSIGNABLE_VALUE_TY = 51;
Constant KIND_OF_WORD_VALUE_TY = 52;
Constant KIND_OF_POINTER_VALUE_TY = 53;
Constant NUMBER_TY = 54;
Constant TIME_TY = 55;
Constant TEXT_TY = 56;
Constant TEXT_ROUTINE_TY = 57;
Constant QUOT_TY = 58;
Constant SNIPPET_TY = 59;
Constant UNICODECHAR_TY = 60;
Constant OBJECT_TY = 61;
Constant I6_DESCRIPTION_ROUTINE_TY = 62;
Constant USEOPTION_TY = 63;
Constant PROPERTY_TY = 64;
Constant RULE_TY = 65;
Constant RULEBOOK_TY = 66;
Constant RULEBOOK_OUTCOME_TY = 67;
Constant ACTION_NAME_TY = 68;
Constant ACTIVITY_TY = 69;
Constant SCENE_TY = 70;
Constant TABLE_TY = 71;
Constant TABLE_COLUMN_TY = 72;
Constant RELATION_TY = 73;
Constant UNDERSTANDING_TY = 74;
Constant FIGURENAME_TY = 75;
Constant SOUNDNAME_TY = 76;
Constant EXTERNALFILE_TY = 77;
Constant TRUTH_STATE_TY = 78;
Constant DESCRIPTION_OF_ACTION_TY = 79;
Constant INDEXED_TEXT_TY = 80;
Constant STORED_ACTION_TY = 81;
Constant LIST_OF_TY = 82;
Constant ANY_POINTER_VALUE_TY = 83;
Constant ANY_WORD_VALUE_TY = 84;
Constant CLASSIFIED_TY = 85;
Constant TEMPLATE_VAR1_TY = 86;
Constant TEMPLATE_VAR2_TY = 87;
Constant TEMPLATE_VAR3_TY = 88;
Constant TEMPLATE_VAR4_TY = 89;
Constant NO_ENTRIES_TY = 90;
Constant RULE_OUTCOME_TY = 91;


! --- Inclusion of library routines ---
Include "Parser";
Include "VerbLib";

Array Protect_I7_Arrays --> 16339 12345;

! --- Attributes ---
Property additive i7_kind;

Attribute initially_carried;
Attribute i7listflag;
Attribute I7_mentioned;

! --- Quantities ---
Constant Q22_entire_game = 1;

Array I7_Globals -->
  (SC_1) ! 1: Q30_story_author
  (I7_EMPTY_TEXT
) ! 2: Q31_story_headline
  (I7_EMPTY_TEXT
) ! 3: Q32_story_genre
  (I7_EMPTY_TEXT
) ! 4: Q33_story_description
  (0
) ! 5: Q34_release_number
  (0
) ! 6: Q35_story_creation_year
  (selfobj) ! 7: Q36_actor
  (nothing
) ! 8: Q37_thing_implicitly_taken
  (O98_shrine) ! 9: Q38_room_gone_from
  (nothing
) ! 10: Q39_room_gone_to
  (nothing
) ! 11: Q40_door_gone_through
  (nothing
) ! 12: Q41_vehicle_gone_by
  (nothing
) ! 13: Q42_thing_gone_with
  (nothing
) ! 14: Q43_container_exited_from
  (##Wait
) ! 15: Q44_room_describing_action
  (0
) ! 16: Q45_visibility_level_count
  (nothing
) ! 17: Q46_visibility_ceiling
  I6_NULL
  ; ! extent 18 words


! --- Activities ---
Constant V0_printing_the_name_of_some = 0;
Constant V1_listing_contents_of_somet = 1;
Constant V2_grouping_together_somethi = 2;
Constant V3_constructing_the_status_l = 3;
Constant V4_listing_nondescript_items = 4;
Constant V5_deciding_the_scope_of_som = 5;
Constant V6_supplying_a_missing_noun = 6;
Constant V7_supplying_a_missing_secon = 7;
Constant V8_reading_a_command = 8;
Constant V9_deciding_whether_all_incl = 9;
Constant V10_printing_the_player_s_ob = 10;
Constant V11_amusing_a_victorious_pla = 11;
Constant V12_printing_the_banner_text = 12;
Constant V13_printing_the_plural_name = 13;
Constant V14_deciding_the_concealed_p = 14;
Constant V15_printing_a_refusal_to_ac = 15;
Constant V16_printing_the_announcemen = 16;
Constant V17_printing_the_name_of_a_d = 17;
Constant V18_printing_the_description = 18;
Constant V19_printing_room_descriptio = 19;
Constant V20_printing_a_parser_error = 20;
Constant V21_implicitly_taking_someth = 21;
Constant V22_starting_the_virtual_mac = 22;
Constant V23_clarifying_the_parser_s_ = 23;
Constant V24_asking_which_do_you_mean = 24;
Constant V25_writing_a_paragraph_abou = 25;

Array Activity_before_rulebooks -->
  35
  38
  41
  44
  47
  50
  53
  56
  59
  62
  65
  68
  71
  74
  77
  80
  83
  86
  89
  92
  95
  98
  101
  104
  107
  110
  I6_NULL;

Array Activity_when_rulebooks -->
  36
  39
  42
  45
  48
  51
  54
  57
  60
  63
  66
  69
  72
  75
  78
  81
  84
  87
  90
  93
  96
  99
  102
  105
  108
  111
  I6_NULL;

Array Activity_after_rulebooks -->
  37
  40
  43
  46
  49
  52
  55
  58
  61
  64
  67
  70
  73
  76
  79
  82
  85
  88
  91
  94
  97
  100
  103
  106
  109
  112
  I6_NULL;

Array Activity_atb_rulebooks ->
  0
  0
  0
  0
  0
  1
  0
  0
  0
  1
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  1
  1
  0
  $ff;


! --- Variable used in debugging ---
Global debug_rules = 0;
Global debug_scenes = 0;

! --- Variables and arrays used in action processing ---
Attribute pushable; Global move_pushing;
Global move_from; Global move_to;
Global move_by; Global move_through;
Global actor_location;

Constant RS_CAPACITY = 666;
Global   rulechange_sp = 0;
Array    rulechange_stack --> RS_CAPACITY;
Global   los_rv = false;
Array    scene_started --> (1+2);
Array    scene_ended --> (1+2);
Array    scene_status --> (1+2);
Array    scene_endings --> (1+2);
Array    scene_latest_ending --> (1+2);

Constant Relation_Implicit	-1;
Constant Relation_OtoO		1;
Constant Relation_OtoV		2;
Constant Relation_VtoO		3;
Constant Relation_VtoV		4;
Constant Relation_Sym_OtoO	5;
Constant Relation_Sym_VtoV	6;
Constant Relation_Equiv		7;
Constant Relation_ByRoutine	8;

Array RelationList -->
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  door_to Relation_OtoV "Leading-through relates one room (called the other side) to various doors"
  0 Relation_Implicit "--"
  with_key Relation_OtoV "Lock-fitting relates one thing (called the matching key) to various things"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  I6_NULL;


! --- Variable used by choose objects mechanism ---
Global cobj_flag = 0;
[ I7ResetChooseObjects; cobj_flag = 0; rfalse; ];

Array LocalParking --> 16;

! --- Printing routines ---
[ I7_Print_Kind_Value_Pair k v;
  switch(k) {
    50: print (I7_DefaultPrinter) v;
    51: print (I7_DefaultPrinter) v;
    83: print (I7_DefaultPrinter) v;
    84: print (I7_DefaultPrinter) v;
    53: print (I7_DefaultPrinter) v;
    52: print (I7_DefaultPrinter) v;
    85: print (I7_DefaultPrinter) v;
    86: print (I7_DefaultPrinter) v;
    87: print (I7_DefaultPrinter) v;
    88: print (I7_DefaultPrinter) v;
    89: print (I7_DefaultPrinter) v;
    90: print (I7_DefaultPrinter) v;
    54: print (I7_DefaultPrinter) v;
    55: print (PrintTimeOfDay) v;
    56: print (I7_PrintText) v;
    57: print (I7_DefaultPrinter) v;
    58: print (I7_DefaultPrinter) v;
    59: print (PrintSnippet) v;
    60: print (I7_DefaultPrinter) v;
    61: print (PrintShortName) v;
    62: print (I7_DefaultPrinter) v;
    63: print (I7_DefaultPrinter) v;
    64: print (I7_DefaultPrinter) v;
    65: print (I7_RulePrintingRule) v;
    91: print (I7_DefaultPrinter) v;
    66: print (I7_DefaultPrinter) v;
    67: print (I7_RulebookOutcomePrintingRule) v;
    68: print (I7_SayActionName) v;
    69: print (I7_DefaultPrinter) v;
    70: print (I7_DefaultPrinter) v;
    71: print (PrintTableName) v;
    72: print (I7_DefaultPrinter) v;
    73: print (I7_DefaultPrinter) v;
    74: print (I7_DefaultPrinter) v;
    75: print (I7_DefaultPrinter) v;
    76: print (I7_DefaultPrinter) v;
    77: print (I7_DefaultPrinter) v;
    78: print (DA_TruthState) v;
    79: print (I7_DefaultPrinter) v;
    80: print (I7_INDEXED_TEXT_TY_Say) v;
    81: print (I7_STORED_ACTION_TY_Say) v;
    82: print (I7_LIST_OF_TY_Say) v;
    default: print v;
  }
];
[ I7_Default_Value_of_KOV k;
  switch(k) {
    54: return 0
;
    55: return 540
;
    56: return I7_EMPTY_TEXT
;
    59: return 101
;
    61: return nothing
;
    62: return Prop_Falsity
;
    65: return I7_DO_NOTHING
;
    66: return 0
;
    68: return ##Wait
;
    70: return 0
;
    71: return T_empty_table
;
    75: return 1
;
    77: return 0
;
    78: return false
;
    80: return 0;
    81: return 0;
    82: return 0;
    default: return 0;
  }
];
[ I7_Comparison_Function_for_KOV k;
  switch(k) {
    56: return UnsignedCompare;
    59: return UnsignedCompare;
    61: return UnsignedCompare;
    62: return UnsignedCompare;
    65: return UnsignedCompare;
    66: return UnsignedCompare;
    68: return UnsignedCompare;
    70: return UnsignedCompare;
    71: return UnsignedCompare;
    75: return UnsignedCompare;
    77: return UnsignedCompare;
    78: return UnsignedCompare;
    80: return I7_Blk_Deep_Comparison;
    81: return I7_Blk_Deep_Comparison;
    82: return I7_Blk_Deep_Comparison;
    default: return 0;
  }
];
[ I7_KOV_On_Heap k;
  if (k == 80 or 81 or 82) rtrue;
  rfalse;
];

[ I7_Kind_Name k;
  if (k == K1_room) print "room";
  if (k == K2_thing) print "thing";
  if (k == K3_direction) print "direction";
  if (k == K4_door) print "door";
  if (k == K5_container) print "container";
  if (k == K6_supporter) print "supporter";
  if (k == K7_backdrop) print "backdrop";
  if (k == K8_person) print "person";
  if (k == K9_region) print "region";
  if (k == K10_player_s_holdall) print "player's holdall";
  if (k == K11_device) print "device";
  if (k == K24_animal) print "animal";
  if (k == K25_man) print "man";
  if (k == K26_woman) print "woman";
  if (k == K29_vehicle) print "vehicle";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "persuasion succeeds";
Constant RBNO_3 = "persuasion fails";
Constant RBNO_4 = "there is sufficient light";
Constant RBNO_5 = "there is insufficient light";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
[ I7_RulebookOutcomePrintingRule rbno;
  print (string) rbno; rfalse;
];


Object I7_property_numberspace_forcer
;




! --- Object tree ---
Class K0_kind 
 with vector 0
;

Class K1_room 
class K0_kind
 
  with n_to 0, ne_to 0, e_to 0, se_to 0, s_to 0, sw_to 0, w_to 0, nw_to 0,
  u_to 0, d_to 0, in_to 0, out_to 0,
 
 with vector 0
  has light
  has ~visited
  with plural "rooms"
;

Class K2_thing 
class K0_kind
 
  with before [;
      PushDir: AllowPushDir(); rtrue;
  ],
  with add_to_scope I7_ScopeParts,
  with component_parent nothing, component_sibling nothing, component_child nothing,
 
  with describe [ o; if (self has I7_mentioned ) rtrue; say__p = 0;  
CarryOutActivity( V25_writing_a_paragraph_abou , self); if (say__p) {
give self I7_mentioned; rtrue; } ],  
 with vector 0
  has ~light
  has ~edible
  has ~transparent
  has ~concealed
  has ~static
  has ~scenery
  has ~clothing
  has ~workflag
 with action_bitmap 0 0 0 0 0 0
;

Class K3_direction 
class K0_kind
  class CompassDirection,  
 with vector 0
  has ~workflag
  with plural "directions"
 with p10_opposite n_obj,
 with p11_inform_property I7_EMPTY_TEXT
,
 with p12_inform_object I7_EMPTY_TEXT
,
;

Class K4_door 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has static
  has ~pushable
  has door
  has ~open
  has openable
  has ~lockable
  has ~locked
  with plural "doors"
;

Class K5_container 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has container
  has open
  has ~openable
  has ~lockable
  has ~locked
  with plural "containers"
;

Class K6_supporter 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has transparent
  has static
  has supporter
  with plural "supporters"
;

Class K7_backdrop 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has static
  has scenery
  with plural "backdrops"
;

Class K8_person 
class K2_thing
with i7_kind K2_thing
 
  with before NULL, after NULL, life NULL, each_turn NULL,
       time_out NULL, before_implicit NULL,
       orders 0, number 0,
  has  transparent,
 
 with vector 0
 with capacity 100
  has animate
  has ~female
  has ~neuter
  with plural "persons"
;

Class K9_region 
class K0_kind
 with vector 0
  with plural "regions"
;

Class K10_player_s_holdall 
class K5_container
with i7_kind K5_container
 with vector 0
  has ~static
  has openable
  with plural "player's holdalls"
;

Class K11_device 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has switchable
  has ~on
  with plural "devices"
;

Class K24_animal 
class K8_person
with i7_kind K8_person
 with vector 0
  with plural "animals"
;

Class K25_man 
class K8_person
with i7_kind K8_person
 with vector 0
  has male
  has ~female
  has ~neuter
  with plural "mans"
;

Class K26_woman 
class K8_person
with i7_kind K8_person
 with vector 0
  has female
  has ~neuter
  with plural "women"
;

Class K29_vehicle 
class K5_container
with i7_kind K5_container
  with before [; Go: return 1; ],  
 with vector 0
  has enterable
  has static
  with plural "vehicles"
;

Object Value_Property_Holder
;
Object n_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link ne_obj,
  with name 'n//' 'north', door_dir n_to,  
 with vector 0
 with p10_opposite s_obj
  with short_name "north"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object ne_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link nw_obj,
  with name 'ne' 'northeast', door_dir ne_to,  
 with vector 0
 with p10_opposite sw_obj
  with short_name "northeast"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object nw_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link s_obj,
  with name 'nw' 'northwest', door_dir nw_to,  
 with vector 0
 with p10_opposite se_obj
  with short_name "northwest"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object s_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link se_obj,
  with name 's//' 'south', door_dir s_to,  
 with vector 0
 with p10_opposite n_obj
  with short_name "south"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object se_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link sw_obj,
  with name 'se' 'southeast', door_dir se_to,  
 with vector 0
 with p10_opposite nw_obj
  with short_name "southeast"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object sw_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link e_obj,
  with name 'sw' 'southwest', door_dir sw_to,  
 with vector 0
 with p10_opposite ne_obj
  with short_name "southwest"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object e_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link w_obj,
  with name 'e//' 'east', door_dir e_to,  
 with vector 0
 with p10_opposite w_obj
  with short_name "east"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object w_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link u_obj,
  with name 'w//' 'west', door_dir w_to,  
 with vector 0
 with p10_opposite e_obj
  with short_name "west"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object u_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link d_obj,
  with name 'u//' 'up', door_dir u_to,  
 with vector 0
 with p10_opposite d_obj
  with short_name "up"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object d_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link in_obj,
  with name 'd//' 'down', door_dir d_to,  
 with vector 0
 with p10_opposite u_obj
  with short_name "down"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object in_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link out_obj,
  with name 'in//' 'inside', door_dir in_to,  
 with vector 0
 with p10_opposite out_obj
  with short_name "inside"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object out_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link nothing,
  with name 'out//' 'outside', door_dir out_to,  
 with vector 0
 with p10_opposite in_obj
  with short_name "outside"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object selfobj ""
class K8_person
with i7_kind K8_person
  with K8_Link nothing,
  with K2_Link O99_pedestal,
 
  has  proper,
  with saved_short_name "yourself",
  
 with name 'yourself' 
 with vector 0
 with description SC_2
  has concealed
  with short_name "yourself"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object O98_shrine ""
class K1_room
with i7_kind K1_room
  with K1_Link nothing,
 with name 'shrine' 
 with vector 0
  has proper
 with description SC_3
  with short_name "Shrine"
  with list_together 0,
;

Object -> O99_pedestal ""
class K6_supporter
with i7_kind K6_supporter
  with K6_Link nothing,
  with K2_Link O100_golden_idol,
 with name 'pedestal' 
 with vector 0
  has static
  with short_name "pedestal"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object -> -> O100_golden_idol ""
class K2_thing
with i7_kind K2_thing
  with K2_Link nothing,
 with name 'golden' 'idol' 
 with vector 0
 with description SC_4
  with short_name "golden idol"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Constant K0_First = n_obj;
Constant K1_First = O98_shrine;
Constant K2_First = selfobj;
Constant K3_First = n_obj;
Constant K4_First = nothing;
Constant K5_First = nothing;
Constant K6_First = O99_pedestal;
Constant K7_First = nothing;
Constant K8_First = selfobj;
Constant K9_First = nothing;
Constant K10_First = nothing;
Constant K11_First = nothing;
Constant K24_First = nothing;
Constant K25_First = nothing;
Constant K26_First = nothing;
Constant K29_First = nothing;


! --- Property metadata ---
Array property_metadata --> 
    "map region" K1_room I6_NULL
    "description" K1_room K2_thing I6_NULL
    "printed name" K1_room K2_thing I6_NULL
    "initial appearance" K2_thing I6_NULL
    "printed plural name" K2_thing I6_NULL
    "inventory listing" K2_thing I6_NULL
    "indefinite article" K2_thing I6_NULL
    "matching key" K2_thing I6_NULL
    "other side" K4_door I6_NULL
    "carrying capacity" K5_container K6_supporter K8_person I6_NULL
    "opposite" K3_direction I6_NULL
    "inform property" K3_direction I6_NULL
    "inform object" K3_direction I6_NULL
    "lighted" K1_room K1_room K2_thing I6_NULL
    "visited" K1_room I6_NULL
    "enterable" K2_thing I6_NULL
    "lit" K2_thing K1_room K2_thing I6_NULL
    "edible" K2_thing I6_NULL
    "transparent" K2_thing I6_NULL
    "undescribed" K2_thing I6_NULL
    "fixed in place" K2_thing I6_NULL
    "scenery" K2_thing I6_NULL
    "wearable" K2_thing I6_NULL
    "handled" K2_thing I6_NULL
    "pushable between rooms" K2_thing I6_NULL
    "an inform library door" K2_thing I6_NULL
    "an inform library container" K2_thing I6_NULL
    "an inform library supporter" K2_thing I6_NULL
    "inform library switchable" K2_thing I6_NULL
    "an inform library animate object" K2_thing I6_NULL
    "an inform library male" K2_thing I6_NULL
    "marked for listing" K2_thing K3_direction I6_NULL
    "mentioned" K2_thing I6_NULL
    "initially carried" K2_thing I6_NULL
    "plural-named" K2_thing I6_NULL
    "proper-named" K2_thing I6_NULL
    "open" K4_door K5_container I6_NULL
    "openable" K4_door K5_container I6_NULL
    "lockable" K4_door K5_container I6_NULL
    "locked" K4_door K5_container I6_NULL
    "switched on" K11_device I6_NULL
    "female" K8_person I6_NULL
    "neuter" K8_person I6_NULL
    "specification" I6_NULL
    "score for visiting" I6_NULL
    "score" I6_NULL
    "worn" I6_NULL
    ;

Array attribute_offsets --> (50 + 63);
#IFDEF TARGET_ZCODE;
Array property_offsets --> (100 + 63);
#IFNOT; ! TARGET_ZCODE
Array property_offsets -->
	(100 + 63 + INDIV_PROP_START - 48);
#ENDIF; ! TARGET_ZCODE
[ CreatePropertyOffsets i;
  for (i=0: i<113: i++) attribute_offsets-->i = -1;
  for (i=0: i<163: i++) property_offsets-->i = -1;
  attribute_offsets-->light = 43;
  attribute_offsets-->visited = 48;
  attribute_offsets-->enterable = 51;
  attribute_offsets-->light = 54;
  attribute_offsets-->edible = 59;
  attribute_offsets-->transparent = 62;
  attribute_offsets-->concealed = 65;
  attribute_offsets-->static = 68;
  attribute_offsets-->scenery = 71;
  attribute_offsets-->clothing = 74;
  attribute_offsets-->moved = 77;
  attribute_offsets-->pushable = 80;
  attribute_offsets-->door = 83;
  attribute_offsets-->container = 86;
  attribute_offsets-->supporter = 89;
  attribute_offsets-->switchable = 92;
  attribute_offsets-->animate = 95;
  attribute_offsets-->male = 98;
  attribute_offsets-->workflag = 101;
  attribute_offsets-->I7_mentioned = 105;
  attribute_offsets-->initially_carried = 108;
  attribute_offsets-->pluralname = 111;
  attribute_offsets-->proper = 114;
  attribute_offsets-->open = 117;
  attribute_offsets-->openable = 121;
  attribute_offsets-->lockable = 125;
  attribute_offsets-->locked = 129;
  attribute_offsets-->on = 133;
  attribute_offsets-->female = 136;
  attribute_offsets-->neuter = 139;
  property_offsets-->I7_Map_Region = 0;
  property_offsets-->description = 3;
  property_offsets-->short_name = 7;
  property_offsets-->initial = 11;
  property_offsets-->plural = 14;
  property_offsets-->invent = 17;
  property_offsets-->article = 20;
  property_offsets-->with_key = 23;
  property_offsets-->door_to = 26;
  property_offsets-->capacity = 29;
  property_offsets-->p10_opposite = 34;
  property_offsets-->p11_inform_property = 37;
  property_offsets-->p12_inform_object = 40;
  property_offsets-->p59_specification = 142;
  property_offsets-->score = 144;
  property_offsets-->score = 146;
  property_offsets-->worn = 148;
];



Array I7_T_Blanks -> 
  ! End of table
  I6_NULL I6_NULL;
Array I7_TC_KOV --> 0 0;


[ PrintTableName T;
	switch(T) {

		default: print "** No such table **";
	}
];




Global parameter_object;


! Definitions of non-inline "To..." phrases

! From the Standard Rules
! To say the contents of ( O - an object ):
[ PHR_434 
    t_0 ! Call parameter 'O' = OBJECT_TY
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence , using the definite article]
        I7WriteListFrom(child(t_0), 264);  
   rfalse;
];
! From the Standard Rules
! To say no line break -- running on:
[ PHR_263 ;
      ! phrase 1
      ! [1: do nothing]
        ;  
   rfalse;
];
! From the Standard Rules
! To say contents of ( O - an object ):
[ PHR_433 
    t_0 ! Call parameter 'O' = OBJECT_TY
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence]
        I7WriteListFrom(child(t_0), 8);  
   rfalse;
];
! Definitions of rule phrases


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B0_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! The first action-processing rule:
! --- now the mid-placed rules ---
! Rule 2/7: PA_R
!   === which is equally specific with ===
! Rule 3/7: CR_R
! --- now the last-placed rules ---
! Rule 4/7 ! A last action-processing rule:
!   === which is equally specific with ===
! Rule 5/7 ! A last action-processing rule:
!   === which is equally specific with ===
! Rule 6/7 ! A last action-processing rule:
!   === which is equally specific with ===
! Rule 7/7 ! A last action-processing rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The first action-processing rule:
[ R_17 ;
      ! phrase 1
      ! [1: abide by the before rules]
        if (ProcessRulebook(1)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_18 ;
      ! phrase 1
      ! [1: abide by the instead rules]
        if (ProcessRulebook(2)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_19 ;
      ! phrase 1
      ! [1: abide by the non-player character action rule]
        if (ProcessRulebook(I7_NPCA)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_20 ;
      ! phrase 1
      ! [1: abide by the action-specific rules]
        if (ProcessRulebook(6)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_21 ;
      ! phrase 1
      ! [1: rule succeeds]
        RulebookSucceeds(); rtrue;  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B1_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last before rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last before rule:
[ R_15 ;
      ! phrase 1
      ! [1: abide by i6 gamepreroutine]
        if (GamePreRoutine()~=0) rtrue;  
      ! phrase 2
      ! [2: abide by i6 orders property]
        if (RunRoutines(player,orders)~=0) rtrue;  
      ! phrase 3
      ! [3: abide by i6 location before]
        if (location~=0 && RunRoutines(location,before)~=0) rtrue;  
      ! phrase 4
      ! [4: abide by i6 react_before property]
        scope_reason=REACT_BEFORE_REASON; parser_one=0;SearchScope(ScopeCeiling(player),player,0); scope_reason=PARSING_REASON; if (parser_one~=0) rtrue;  
      ! phrase 5
      ! [5: abide by i6 object before]
        if (inp1>1 && RunRoutines(inp1,before)~=0) rtrue;  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B3_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! The first after rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! After taking the idol:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The first after rule:
[ R_16 ;
      ! phrase 1
      ! [1: abide by i6 gamepostroutine]
        if (GamePostRoutine()~=0) rtrue;  
      ! phrase 2
      ! [2: abide by i6 location after]
        if (location~=0 && RunRoutines(location,after)~=0) rtrue;  
      ! phrase 3
      ! [3: abide by i6 react_after property]
        scope_reason=REACT_AFTER_REASON; parser_one=0;SearchScope(ScopeCeiling(player),player,0); scope_reason=PARSING_REASON; if (parser_one~=0) rtrue;  
      ! phrase 4
      ! [4: abide by i6 object after]
        if (inp1>1 && RunRoutines(inp1,after)~=0) rtrue;  
      ! phrase 5
      ! [5: continue the action]
        rfalse;  
      RulebookSucceeds(); rtrue;
   rfalse;
];
! After taking the idol:
[ R_649 ;
   if ((action ==##Take) &&  (actor==player) && (noun == O100_golden_idol)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_649);
      ! phrase 1
        #ifndef I7_ECONOMY; if (debug_rules>1) print "@31  [1: say ~The pedestal clicks almost imperceptibly. You remember the princess's warning, quickly drop to one knee, and just barely avoid the poison dart aimed for your head. Heaving a sigh of relief, you stick the idol in your knapsack and head back to the museum.~]^"; #endif;
      say__c=0; say__p=1;  print (I7_string) SC_5;   new_line; .L_Say0;
      ! phrase 2
      ! [2: end the game in victory]
        deadflag=2;  
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_649, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-specific (B6_action_specific)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last action-specific rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last action-specific rule:
[ R_22 ;
      ! phrase 1
      ! [1: cause the action to take place]
        _I6_ActionPrimitive(); rtrue;  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B9_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! A first turn sequence rule:
!   === which is equally specific with ===
! Rule 2/9 ! A first turn sequence rule:
! --- now the mid-placed rules ---
! Rule 3/9: I7ResetChooseObjects
!   === which is equally specific with ===
! Rule 4/9: ProcessI7Timers
!   === which is equally specific with ===
! Rule 5/9: TS1_R
!   === which is equally specific with ===
! Rule 6/9: TS4_R
! --- now the last-placed rules ---
! Rule 7/9 ! A last turn sequence rule:
!   === which is equally specific with ===
! Rule 8/9: TS5_R
!   === which is equally specific with ===
! Rule 9/9: TS6_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! A first turn sequence rule:
[ R_11 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
        ConsiderRulebook(32);  
   rfalse;
];
! From the Standard Rules
! A first turn sequence rule:
[ R_10 ;
      ! phrase 1
      ! [1: consider the every turn rules]
        ConsiderRulebook(24);  
   rfalse;
];
! From the Standard Rules
! A last turn sequence rule:
[ R_12 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
        ConsiderRulebook(32);  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B22_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The first when play begins rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The first when play begins rule:
[ R_9 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
        ConsiderRulebook(32);  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B30_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_14 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == I7_CarriedBy(noun)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_14);
      ! phrase 1
      ! [1: it is very unlikely]
      RulebookSucceeds(true, RBNO_10); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_14, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B31_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Setting action variables for taking ( this is the standard set taking variables rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Setting action variables for exiting:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Setting action variables for taking ( this is the standard set taking variables rule ):
[ R_30 ;
   if ((action ==##Take)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_30);
      ! phrase 1
      ! [1: if the i6 parser asks for an implicit take , now the thing implicitly taken is the noun]
        if ((  (onotheld_mode==1)  )) {   (MStack-->MstVO(20001,0)) = noun;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_30, true);
   rfalse;
];
! From the Standard Rules
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_81 
    t_0 ! Local variable e.g. 'carriage' = OBJECT_TY
    t_1 ! Local variable e.g. 'target' = OBJECT_TY
    t_2 ! Local variable e.g. 'direction D' = OBJECT_TY
    ;
   if ((action ==##Go)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_81);
      ! phrase 1
      ! [1: now the thing gone with is the i6-pushdir item]
        (MStack-->MstVO(20007,4)) = move_pushing;  
      ! phrase 2
      ! [2: now the room gone from is the location of the actor]
        (MStack-->MstVO(20007,0)) =   I7_Location(actor)  ;  
      ! phrase 3
      ! [3: if the actor is in an enterable vehicle ( called the carriage ) , now the vehicle gone by is the carriage]
        if (((t_0=I7_InWhat(actor)) && (I7_InWhat(actor) ofclass K29_vehicle) && (I7GetEitherOr(I7_InWhat(actor),enterable)))) {   (MStack-->MstVO(20007,3)) = t_0;     }
      ! phrase 4
      ! [4: let the target be nothing]
        t_1 = nothing;  
      ! phrase 5
      ! [5: if the noun is a direction begin]
        if ((noun ofclass K3_direction))   {
         ! phrase 6
         ! [6: let direction d be the noun]
           t_2 = noun;  
         ! phrase 7
         ! [7: let the target be the room-or-door direction d from the room gone from]
           t_1 = (Resolver_0(t_2,(MStack-->MstVO(20007,0)),"source", 1259));  
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: if the noun is a door , let the target be the noun]
           if ((noun ofclass K4_door)) {   t_1 = noun;     }
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: if the target is a door begin]
        if ((t_1 ofclass K4_door))   {
         ! phrase 12
         ! [12: now the door gone through is the target]
           (MStack-->MstVO(20007,2)) = t_1;  
         ! phrase 13
         ! [13: now the target is the other side of the target from the room gone from]
           t_1 = (Resolver_1(t_1,(MStack-->MstVO(20007,0)),"source", 0));  
         ! phrase 14
         ! [14: end if]
         }

      ! phrase 15
      ! [15: now the room gone to is the target]
        (MStack-->MstVO(20007,1)) = t_1;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_81, true);
   rfalse;
];
! From the Standard Rules
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_113 ;
   if ((action ==##Look)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_113);
      ! phrase 1
      ! [1: calculate visibility ceiling at low level]
        I7_Calculate_VC();  
      ! phrase 2
      ! [2: now the visibility level count is the visibility ceiling count calculated]
        (MStack-->MstVO(20011,1)) =   visibility_levels  ;  
      ! phrase 3
      ! [3: now the visibility ceiling is the visibility ceiling calculated]
        (MStack-->MstVO(20011,2)) =   visibility_ceiling  ;  
      ! phrase 4
      ! [4: now the room-describing action is the looking action]
        (MStack-->MstVO(20011,0)) = ##Look;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_113, true);
   rfalse;
];
! From the Standard Rules
! Setting action variables for exiting:
[ R_101 ;
   if ((action ==##Exit)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_101);
      ! phrase 1
      ! [1: now the container exited from is the holder of the actor]
        (MStack-->MstVO(20009,0)) =   (I7_Holder(actor))  ;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_101, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Scene changing (B32_scene_changing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last scene changing rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last scene changing rule:
[ R_13 ;
      ! phrase 1
      ! [1: run scene change machinery]
        I7_SceneChange();  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B35_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_25 
    t_0 ! Local variable e.g. 'item being printed' = OBJECT_TY
    ;
   if ((t_0 = parameter_object, ((parameter_object ofclass K2_thing)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_25);
      ! phrase 1
      ! [1: now the item being printed is mentioned]
        I7SetEitherOr(t_0,I7_mentioned);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_25, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the name (B36_for_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last for printing the name rule ( this is the standard name printing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last for printing the name rule ( this is the standard name printing rule ):
[ R_23 ;
      ! phrase 1
      ! [1: cause the description to take place]
        I6_PSN__(parameter_object);  
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Listing contents (B39_for_listing_contents)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last for listing contents rule ( this is the standard contents listing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last for listing contents rule ( this is the standard contents listing rule ):
[ R_24 ;
      ! phrase 1
      ! [1: cause the listing to take place]
        I7_WLF(child(parameter_object), 0);  
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B54_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
[ R_237 ;
   if (((((action ==##Smell))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_237);
      ! phrase 1
      ! [1: change the noun to the location]
        noun = real_location;  
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_237, true);
   rfalse;
];
! From the Standard Rules
! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
[ R_238 ;
   if (((((action ==##Listen))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_238);
      ! phrase 1
      ! [1: change the noun to the location]
        noun = real_location;  
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_238, true);
   rfalse;
];
! From the Standard Rules
! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
[ R_239 ;
   if (((((action ==##Go))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_239);
      ! phrase 1
      ! [1: say ~You'll have to say which compass direction to go in.~]
      say__c=0; say__p=1;  print (I7_string) SC_6;   new_line; .L_Say1;
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_239, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B114_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Carry out taking inventory ( this is the print standard inventory rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Carry out taking inventory ( this is the use inventory to set pronouns rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_26 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_26);
      ! phrase 1
      ! [1: if the first thing held by the player is nothing , stop the action with library message taking inventory action number 1]
        if ((  (child(player))   == nothing)) {   return GL__M(##Inv,1,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_26, true);
   rfalse;
];
! From the Standard Rules
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_27 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_27);
      ! phrase 1
      ! [1: issue library message taking inventory action number 2]
        GL__M(##Inv,2,noun);  
      ! phrase 2
      ! [2: say ~:[line break]~]
      say__c=0; say__p=1;  print (I7_string) SC_7;    new_line;   .L_Say2;
      ! phrase 3
      ! [3: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
        I7WriteListFrom(child(player), 8215);  
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_27, true);
   rfalse;
];
! From the Standard Rules
! Carry out taking inventory ( this is the use inventory to set pronouns rule ):
[ R_28 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_28);
      ! phrase 1
      ! [1: set pronouns from possessions of the player]
        I7_NoticeHeld();  
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_28, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B115_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_29 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_29);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks through [possessive for the actor] possessions.~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_8;  (Resolver_2(actor,"source", 836));  print (I7_string) SC_9;   new_line; .L_Say3;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_29, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B116_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/13 ! Check an actor taking ( this is the avoid unnecessary implicit taking rule ):
!   === which is equally specific with ===
! Rule 2/13 ! Check an actor taking ( this is the can't take yourself rule ):
!   === which is equally specific with ===
! Rule 3/13 ! Check an actor taking ( this is the can't take other people rule ):
!   === which is equally specific with ===
! Rule 4/13 ! Check an actor taking ( this is the can't take component parts rule ):
!   === which is equally specific with ===
! Rule 5/13 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === which is equally specific with ===
! Rule 6/13 ! Check an actor taking ( this is the can't take items out of play rule ):
!   === which is equally specific with ===
! Rule 7/13 ! Check an actor taking ( this is the can't take what you're inside rule ):
!   === which is equally specific with ===
! Rule 8/13 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === which is equally specific with ===
! Rule 9/13 ! Check an actor taking ( this is the can't take scenery rule ):
!   === which is equally specific with ===
! Rule 10/13 ! Check an actor taking ( this is the can only take things rule ):
!   === which is equally specific with ===
! Rule 11/13 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 12/13 ! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
!   === which is equally specific with ===
! Rule 13/13 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor taking ( this is the avoid unnecessary implicit taking rule ):
[ R_31 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_31);
      ! phrase 1
      ! [1: if the thing implicitly taken is a thing carried by the actor , stop the action]
        if ((((MStack-->MstVO(20001,0)) ofclass K2_thing) && (actor == I7_CarriedBy((MStack-->MstVO(20001,0)))))) {   rtrue;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_31, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take yourself rule ):
[ R_32 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_32);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message taking action number 2 for the noun]
        if ((actor == noun)) {   return GL__M(##Take,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_32, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take other people rule ):
[ R_33 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_33);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message taking action number 3 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Take,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_33, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take component parts rule ):
[ R_34 
    t_0 ! Local variable e.g. 'whole' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_34);
      ! phrase 1
      ! [1: if the noun is part of something ( called the whole ) , stop the action with library message taking action number 7 for the whole]
        if (((t_0=(noun.component_parent)) && ((noun.component_parent) ofclass K2_thing))) {   return GL__M(##Take,7,t_0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_34, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_35 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    t_1 ! Local variable e.g. 'H' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_35);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: let h be the not-counting-parts holder of the noun]
        t_1 =   (OIU_Parent(noun))  ;  
      ! phrase 3
      ! [3: while h is not nothing and h is not the local ceiling begin]
        while ((~~((t_1 == nothing))) && (~~((t_1 == t_0))))   {
         ! phrase 4
         ! [4: if h is a person , stop the action with library message taking action number 6 for h]
           if ((t_1 ofclass K8_person)) {   return GL__M(##Take,6,t_1);     }
         ! phrase 5
         ! [5: let h be the not-counting-parts holder of h]
           t_1 =   (OIU_Parent(t_1))  ;  
         ! phrase 6
         ! [6: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_35, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take items out of play rule ):
[ R_36 
    t_0 ! Local variable e.g. 'H' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_36);
      ! phrase 1
      ! [1: let h be the noun]
        t_0 = noun;  
      ! phrase 2
      ! [2: while h is not nothing and h is not a room begin]
        while ((~~((t_0 == nothing))) && ((Prop_0(t_0))))   {
         ! phrase 3
         ! [3: let h be the not-counting-parts holder of h]
           t_0 =   (OIU_Parent(t_0))  ;  
         ! phrase 4
         ! [4: end while]
         }

      ! phrase 5
      ! [5: if h is nothing , stop the action with library message taking action number 8 for the noun]
        if ((t_0 == nothing)) {   return GL__M(##Take,8,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_36, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_37 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_37);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message taking action number 4 for the noun]
        if ((t_0 == noun)) {   return GL__M(##Take,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_37, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_38 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_38);
      ! phrase 1
      ! [1: if the actor is carrying the noun , stop the action with library message taking action number 5 for the noun]
        if ((actor == I7_CarriedBy(noun))) {   return GL__M(##Take,5,noun);     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , stop the action with library message taking action number 5 for the noun]
        if ((actor == I7_WornBy(noun))) {   return GL__M(##Take,5,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_38, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take scenery rule ):
[ R_39 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_39);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message taking action number 10 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Take,10,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_39, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can only take things rule ):
[ R_40 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_40);
      ! phrase 1
      ! [1: if the noun is not a thing , stop the action with library message taking action number 15 for the noun]
        if ((Prop_1(noun))) {   return GL__M(##Take,15,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_40, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_41 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_41);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message taking action number 11 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Take,11,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_41, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_42 
    t_0 ! Local variable e.g. 'sack' = OBJECT_TY
    t_1 ! Local variable e.g. 'transferred item' = OBJECT_TY
    t_2 ! Local variable e.g. '?-1,-1?' = OBJECT_TY
    t_3 ! Local variable e.g. '?-1,-1?' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_42);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
        if ((  (Prop_2(actor))   >= AccessProp(actor,capacity)))   {
         ! phrase 2
         ! [2: if the actor is holding a player's holdall ( called the sack ) begin]
           if ((Prop_3(actor)&& (t_0=I7_CS-->0)))   {
            ! phrase 3
            ! [3: let the transferred item be nothing]
              t_1 = nothing;  
            ! phrase 4
            ! [4: repeat with the possible item running through things carried by the actor begin]
              for (t_2=Prop_4(actor,0), t_3=Prop_4(actor,t_2): t_2: t_2=t_3, t_3=Prop_4(actor,t_3))   {
               ! phrase 5
               ! [5: if the possible item is not lit and the possible item is not the sack , let the transferred item be the possible item]
                 if ((~~((I7GetEitherOr(t_2,light)))) && (~~((t_2 == t_0)))) {   t_1 = t_2;     }
               ! phrase 6
               ! [6: end repeat]
               }

            ! phrase 7
            ! [7: if the transferred item is not nothing begin]
              if (~~((t_1 == nothing)))   {
               ! phrase 8
               ! [8: issue library message taking action number 13 for the transferred item]
                 GL__M(##Take,13,t_1);  
               ! phrase 9
               ! [9: silently try the actor trying inserting the transferred item into the sack]
                 @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Insert, t_1, t_0);; @pull keep_silent;  
               ! phrase 10
               ! [10: if the transferred item is not in the sack , stop the action]
                 if (~~((t_0 == I7_InWhat(t_1)))) {   rtrue;     }
               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_42, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_43 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_43);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor , stop the action with library message taking action number 12 for the actor]
        if ((  (Prop_5(actor))   >= AccessProp(actor,capacity))) {   return GL__M(##Take,12,actor);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_43, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B117_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor taking ( this is the standard taking rule ):
[ R_44 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_44);
      ! phrase 1
      ! [1: now the actor carries the noun]
        I7_Move(noun,actor);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_44, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B118_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor taking ( this is the don't report successful implicit takes rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor taking ( this is the don't report successful implicit takes rule ):
[ R_45 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_45);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: end any i6 parser implicit take]
           notheld_mode=onotheld_mode;  
         ! phrase 3
         ! [3: if the thing implicitly taken is not nothing , stop the action]
           if (~~(((MStack-->MstVO(20001,0)) == nothing))) {   rtrue;     }
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_45, true);
   rfalse;
];
! From the Standard Rules
! Report an actor taking ( this is the standard report taking rule ):
[ R_46 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_46);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking action number 1 for the noun]
        if ((actor == player)) {   GL__M(##Take,1,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] picks up [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_10;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say4;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_46, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B119_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_47 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_47);
      ! phrase 1
      ! [1: if the holder of the noun is not the second noun , stop the action with library message removing it from action number 2 for the noun]
        if (~~((  (I7_Holder(noun))   == second))) {   return GL__M(##Remove,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_47, true);
   rfalse;
];
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_48 
    t_0 ! Local variable e.g. 'owner' = OBJECT_TY
    ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_48);
      ! phrase 1
      ! [1: if the holder of the noun is a person ( called the owner ) , stop the action with library message taking action number 6 for the owner]
        if (((t_0=  (I7_Holder(noun))  ) && (  (I7_Holder(noun))   ofclass K8_person))) {   return GL__M(##Take,6,t_0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_48, true);
   rfalse;
];
! From the Standard Rules
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_49 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_49);
      ! phrase 1
      ! [1: convert to the taking action on the noun]
        return GVS_Convert(##Take,noun,0);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_49, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B122_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_50 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_50);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message putting it on action number 4]
        if ((noun == actor)) {   return GL__M(##PutOn,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_50, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_51 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_51);
      ! phrase 1
      ! [1: if the noun is in the holder of the actor , stop the action with library message dropping action number 1 for the noun]
        if ((  (I7_Holder(actor))   == I7_InWhat(noun))) {   return GL__M(##Drop,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_51, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_52 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_52);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
        if ((actor == I7_CarriedBy(noun))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
        if ((actor == I7_WornBy(noun))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message dropping action number 2 for the noun]
        return GL__M(##Drop,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_52, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_53 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_53);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
           GL__M(##Drop,3,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_53, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_54 
    t_0 ! Local variable e.g. 'H' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_54);
      ! phrase 1
      ! [1: let h be the holder of the actor]
        t_0 =   (I7_Holder(actor))  ;  
      ! phrase 2
      ! [2: if h is a room , continue the action]
        if ((t_0 ofclass K1_room)) {   rfalse;     }
      ! phrase 3
      ! [3: if h provides the property carrying capacity begin]
        if ((  (I7_Provides(t_0, false,capacity))  ))   {
         ! phrase 4
         ! [4: if h is a supporter begin]
           if ((t_0 ofclass K6_supporter))   {
            ! phrase 5
            ! [5: if the number of things on h is at least the carrying capacity of h begin]
              if ((  (Prop_6(t_0))   >= AccessProp(t_0,capacity)))   {
               ! phrase 6
               ! [6: if the actor is the player , say ~There is no more room on [the H].~]
                 if ((actor == player)) { say__c=0; say__p=1;  print (I7_string) SC_12;    print (the) t_0;    print (I7_string) SC_11;   new_line; .L_Say5;   }
               ! phrase 7
               ! [7: stop the action]
                 rtrue;  
               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: otherwise if h is a container]
              } else if ((t_0 ofclass K5_container)) {  
            ! phrase 10
            ! [10: if the number of things in h is at least the carrying capacity of h begin]
              if ((  (Prop_7(t_0))   >= AccessProp(t_0,capacity)))   {
               ! phrase 11
               ! [11: if the actor is the player , say ~There is no more room in [the H].~]
                 if ((actor == player)) { say__c=0; say__p=1;  print (I7_string) SC_13;    print (the) t_0;    print (I7_string) SC_11;   new_line; .L_Say6;   }
               ! phrase 12
               ! [12: stop the action]
                 rtrue;  
               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_54, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B123_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_55 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_55);
      ! phrase 1
      ! [1: now the noun is in the holder of the actor]
        I7_Move(noun,  (I7_Holder(actor))  );  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_55, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B124_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_56 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_56);
      ! phrase 1
      ! [1: if the actor is the player , issue library message dropping action number 4 for the noun]
        if ((actor == player)) {   GL__M(##Drop,4,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts down [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_14;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say7;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_56, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B125_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor putting something on ( this is the can't put onto something being carried rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_57 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_57);
      ! phrase 1
      ! [1: if the second noun is down or the actor is on the second noun , convert to the dropping action on the noun]
        if (((second == d_obj)) || ((second == I7_OnWhat(actor)))) {   return GVS_Convert(##Drop,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_57, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_58 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_58);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
        if ((actor == I7_CarriedBy(noun))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
        if ((actor == I7_WornBy(noun))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message putting it on action number 1 for the noun]
        return GL__M(##PutOn,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_58, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_59 
    t_0 ! Local variable e.g. 'noun-CPC' = OBJECT_TY
    t_1 ! Local variable e.g. 'second-CPC' = OBJECT_TY
    t_2 ! Local variable e.g. 'transfer ceiling' = OBJECT_TY
    ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_59);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
        t_0 =   OIU_Core(noun)  ;  
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
        t_1 =   OIU_Core(second)  ;  
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
        t_2 =   (OIU_CommonAncestor(t_0, t_1))  ;  
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message putting it on action number 2 for the noun]
        if ((t_2 == t_0)) {   return GL__M(##PutOn,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_59, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_60 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_60);
      ! phrase 1
      ! [1: if the second noun is not a supporter , stop the action with library message putting it on action number 3 for the second noun]
        if ((Prop_8(second))) {   return GL__M(##PutOn,3,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_60, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto something being carried rule ):
[ R_61 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_61);
      ! phrase 1
      ! [1: if the actor encloses the second noun , stop the action with library message putting it on action number 4 for the second noun]
        if ((I7_IndirectlyContains(actor,second))) {   return GL__M(##PutOn,4,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_61, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_62 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_62);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message putting it on action number 5 for the noun]
           GL__M(##PutOn,5,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_62, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_63 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_63);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
        if ((  (I7_Provides(second, false,capacity))  ))   {
         ! phrase 2
         ! [2: if the number of things on the second noun is at least the carrying capacity of the second noun , stop the action with library message putting it on action number 6 for the second noun]
           if ((  (Prop_9(second))   >= AccessProp(second,capacity))) {   return GL__M(##PutOn,6,second);     }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_63, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B126_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_64 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_64);
      ! phrase 1
      ! [1: now the noun is on the second noun]
        I7_Move(noun,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_64, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B127_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_65 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_65);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message putting it on action number 7 for the noun]
        if (((actor == player)) && ((  (multiflag==1)  ))) {   return GL__M(##PutOn,7,noun);     }
      ! phrase 2
      ! [2: otherwise continue the action]
        else {   rfalse;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_65, true);
   rfalse;
];
! From the Standard Rules
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_66 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_66);
      ! phrase 1
      ! [1: if the actor is the player , issue library message putting it on action number 8 for the noun]
        if ((actor == player)) {   GL__M(##PutOn,8,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts [the noun] on [the second noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_15;    print (the) noun;    print (I7_string) SC_16;    print (the) second;    print (I7_string) SC_11;   new_line; .L_Say8;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_66, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B128_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_67 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_67);
      ! phrase 1
      ! [1: if the second noun is down or the actor is in the second noun , convert to the dropping action on the noun]
        if (((second == d_obj)) || ((second == I7_InWhat(actor)))) {   return GVS_Convert(##Drop,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_67, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_68 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_68);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
        if ((actor == I7_CarriedBy(noun))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
        if ((actor == I7_WornBy(noun))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message inserting it into action number 1 for the noun]
        return GL__M(##Insert,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_68, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_69 
    t_0 ! Local variable e.g. 'noun-CPC' = OBJECT_TY
    t_1 ! Local variable e.g. 'second-CPC' = OBJECT_TY
    t_2 ! Local variable e.g. 'transfer ceiling' = OBJECT_TY
    ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_69);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
        t_0 =   OIU_Core(noun)  ;  
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
        t_1 =   OIU_Core(second)  ;  
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
        t_2 =   (OIU_CommonAncestor(t_0, t_1))  ;  
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message inserting it into action number 5 for the noun]
        if ((t_2 == t_0)) {   return GL__M(##Insert,5,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_69, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_70 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_70);
      ! phrase 1
      ! [1: if the second noun is a closed container , stop the action with library message inserting it into action number 3 for the second noun]
        if (((second ofclass K5_container) && (I7GetEitherOr(second,open)==false))) {   return GL__M(##Insert,3,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_70, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_71 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_71);
      ! phrase 1
      ! [1: if the second noun is not a container , stop the action with library message inserting it into action number 2 for the second noun]
        if ((Prop_10(second))) {   return GL__M(##Insert,2,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_71, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_72 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_72);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message inserting it into action number 6 for the noun]
           GL__M(##Insert,6,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_72, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_73 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_73);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
        if ((  (I7_Provides(second, false,capacity))  ))   {
         ! phrase 2
         ! [2: if the number of things in the second noun is at least the carrying capacity of the second noun , stop the action with library message inserting it into action number 7 for the second noun]
           if ((  (Prop_11(second))   >= AccessProp(second,capacity))) {   return GL__M(##Insert,7,second);     }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_73, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B129_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_74 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_74);
      ! phrase 1
      ! [1: now the noun is in the second noun]
        I7_Move(noun,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_74, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B130_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_75 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_75);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message inserting it into action number 8 for the noun]
        if (((actor == player)) && ((  (multiflag==1)  ))) {   return GL__M(##Insert,8,noun);     }
      ! phrase 2
      ! [2: otherwise continue the action]
        else {   rfalse;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_75, true);
   rfalse;
];
! From the Standard Rules
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_76 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_76);
      ! phrase 1
      ! [1: if the actor is the player , issue library message inserting it into action number 9 for the noun]
        if ((actor == player)) {   GL__M(##Insert,9,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts [the noun] into [the second noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_15;    print (the) noun;    print (I7_string) SC_17;    print (the) second;    print (I7_string) SC_11;   new_line; .L_Say9;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_76, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B131_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_77 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_77);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not edible , stop the action with library message eating action number 1 for the noun]
        if (((Prop_12(noun))) || (~~((I7GetEitherOr(noun,edible))))) {   return GL__M(##Eat,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_77, true);
   rfalse;
];
! From the Standard Rules
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_78 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_78);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
           GL__M(##Drop,3,noun);  
         ! phrase 3
         ! [3: try the actor trying taking off the noun]
           I7_TryAction(0, actor, ##Disrobe, noun, 0);;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_78, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B132_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor eating ( this is the standard eating rule ):
[ R_79 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_79);
      ! phrase 1
      ! [1: remove the noun from play]
        I7_Remove(noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_79, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B133_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor eating ( this is the standard report eating rule ):
[ R_80 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_80);
      ! phrase 1
      ! [1: if the actor is the player , issue library message eating action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Eat,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] eats [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_18;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say10;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_80, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B134_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor going ( this is the can't go through undescribed doors rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor going ( this is the determine map connection rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor going ( this is the can't go that way rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_82 
    t_0 ! Local variable e.g. 'H' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_82);
      ! phrase 1
      ! [1: let h be the holder of the actor]
        t_0 =   (I7_Holder(actor))  ;  
      ! phrase 2
      ! [2: if h is the room gone from , continue the action]
        if ((t_0 == (MStack-->MstVO(20007,0)))) {   rfalse;     }
      ! phrase 3
      ! [3: if h is the vehicle gone by , continue the action]
        if ((t_0 == (MStack-->MstVO(20007,3)))) {   rfalse;     }
      ! phrase 4
      ! [4: stop the action with library message going action number 1 for h]
        return GL__M(##Go,1,t_0);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_82, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the can't go through undescribed doors rule ):
[ R_83 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_83);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is undescribed , stop the action with library message going action number 2 for the room gone from]
        if ((~~(((MStack-->MstVO(20007,2)) == nothing))) && ((I7GetEitherOr((MStack-->MstVO(20007,2)),concealed)))) {   return GL__M(##Go,2,(MStack-->MstVO(20007,0)));     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_83, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_84 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_84);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is closed begin]
        if ((~~(((MStack-->MstVO(20007,2)) == nothing))) && ((I7GetEitherOr((MStack-->MstVO(20007,2)),open)==false)))   {
         ! phrase 2
         ! [2: if the noun is up , stop the action with library message going action number 3 for the door gone through]
           if ((noun == u_obj)) {   return GL__M(##Go,3,(MStack-->MstVO(20007,2)));     }
         ! phrase 3
         ! [3: if the noun is down , stop the action with library message going action number 4 for the door gone through]
           if ((noun == d_obj)) {   return GL__M(##Go,4,(MStack-->MstVO(20007,2)));     }
         ! phrase 4
         ! [4: stop the action with library message going action number 5 for the door gone through]
           return GL__M(##Go,5,(MStack-->MstVO(20007,2)));  
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_84, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the determine map connection rule ):
[ R_85 
    t_0 ! Local variable e.g. 'target' = OBJECT_TY
    t_1 ! Local variable e.g. 'direction D' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_85);
      ! phrase 1
      ! [1: let the target be nothing]
        t_0 = nothing;  
      ! phrase 2
      ! [2: if the noun is a direction begin]
        if ((noun ofclass K3_direction))   {
         ! phrase 3
         ! [3: let direction d be the noun]
           t_1 = noun;  
         ! phrase 4
         ! [4: let the target be the room-or-door direction d from the room gone from]
           t_0 = (Resolver_0(t_1,(MStack-->MstVO(20007,0)),"source", 1296));  
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: if the noun is a door , let the target be the noun]
           if ((noun ofclass K4_door)) {   t_0 = noun;     }
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if the target is a door begin]
        if ((t_0 ofclass K4_door))   {
         ! phrase 9
         ! [9: now the target is the other side of the target from the room gone from]
           t_0 = (Resolver_1(t_0,(MStack-->MstVO(20007,0)),"source", 0));  
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: now the room gone to is the target]
        (MStack-->MstVO(20007,1)) = t_0;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_85, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the can't go that way rule ):
[ R_86 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_86);
      ! phrase 1
      ! [1: if the room gone to is nothing begin]
        if (((MStack-->MstVO(20007,1)) == nothing))   {
         ! phrase 2
         ! [2: if the door gone through is nothing , stop the action with library message going action number 2 for the room gone from]
           if (((MStack-->MstVO(20007,2)) == nothing)) {   return GL__M(##Go,2,(MStack-->MstVO(20007,0)));     }
         ! phrase 3
         ! [3: stop the action with library message going action number 6 for the door gone through]
           return GL__M(##Go,6,(MStack-->MstVO(20007,2)));  
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_86, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B135_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Carry out an actor going ( this is the move floating objects rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_87 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_87);
      ! phrase 1
      ! [1: if the vehicle gone by is nothing , surreptitiously move the actor to the room gone to]
        if (((MStack-->MstVO(20007,3)) == nothing)) {   I7_SurreptitiousMove(actor, (MStack-->MstVO(20007,1)));     }
      ! phrase 2
      ! [2: otherwise surreptitiously move the vehicle gone by to the room gone to]
        else {   I7_SurreptitiousMove((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1)));     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_87, true);
   rfalse;
];
! From the Standard Rules
! Carry out an actor going ( this is the move floating objects rule ):
[ R_88 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_88);
      ! phrase 1
      ! [1: if the actor is the player , surreptitiously move floating objects]
        if ((actor == player)) {   MoveFloatingObjects();     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_88, true);
   rfalse;
];
! From the Standard Rules
! Carry out an actor going ( this is the check light in new location rule ):
[ R_89 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_89);
      ! phrase 1
      ! [1: if the actor is the player , surreptitiously reckon dark in move from the room gone from to the room gone to]
        if ((actor == player)) { (Resolver_3((MStack-->MstVO(20007,0)),(MStack-->MstVO(20007,1)),"source", 1325));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_89, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B136_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor going ( this is the describe room gone into rule ):
[ R_90 
    t_0 ! Local variable e.g. 'back way' = OBJECT_TY
    t_1 ! Local variable e.g. 'room back the other way' = OBJECT_TY
    t_2 ! Local variable e.g. 'room normally this way' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_90);
      ! phrase 1
      ! [1: if the player is the actor begin]
        if ((player == actor))   {
         ! phrase 2
         ! [2: produce a room description with going spacing conventions]
           I7_RoomDescriptionForGoing();  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor]~]
         say__c=0; say__p=1;  print (The) actor;   .L_Say11;
         ! phrase 5
         ! [5: if the noun is a direction begin]
           if ((noun ofclass K3_direction))   {
            ! phrase 6
            ! [6: if the location is the room gone from , say ~ goes ~]
              if ((real_location == (MStack-->MstVO(20007,0)))) { say__c=0; say__p=1;  print (I7_string) SC_19;   .L_Say12;   }
            ! phrase 7
            ! [7: otherwise say ~ arrives~]
              else { say__c=0; say__p=1;  print (I7_string) SC_20;   .L_Say13;   }
            ! phrase 8
            ! [8: let the back way be the opposite of the noun]
              t_0 = AccessProp(noun,p10_opposite);  
            ! phrase 9
            ! [9: if the location is the room gone to begin]
              if ((real_location == (MStack-->MstVO(20007,1))))   {
               ! phrase 10
               ! [10: let the room back the other way be the room back way from the location]
                 t_1 = (Resolver_4(t_0,real_location,"source", 1341));  
               ! phrase 11
               ! [11: let the room normally this way be the room noun from the room gone from]
                 t_2 = (Resolver_4(noun,(MStack-->MstVO(20007,0)),"source", 1343));  
               ! phrase 12
               ! [12: if the room back the other way is the room gone from or the room back the other way is the room normally this way begin]
                 if (((t_1 == (MStack-->MstVO(20007,0)))) || ((t_1 == t_2)))   {
                  ! phrase 13
                  ! [13: say ~ from [if the back way is up]above[otherwise if the	back way is down]below[otherwise]the [back way]~]
                  say__c=0; say__p=1;  print (I7_string) SC_21;   
.L_Say14; if (((t_0 == u_obj))) say__c=true; else jump L_Say15;    print (I7_string) SC_22;   
.L_Say15; if (say__c==false) { say__c=((((t_0 == d_obj)))==true);
		if (say__c==false) jump L_Say16;
	} else jump L_Say16;
   print (I7_string) SC_23;  
.L_Say16; if (say__c==false) say__c=true; else jump L_Say17;    print (I7_string) SC_24;    print (name) t_0;   .L_Say17;
                  ! phrase 14
                  ! [14: end if]
                  }

               ! phrase 15
               ! [15: otherwise]
               } else {

               ! phrase 16
               ! [16: if the location is the room gone from begin]
                 if ((real_location == (MStack-->MstVO(20007,0))))   {
                  ! phrase 17
                  ! [17: say ~[if the noun is up]up[otherwise if the	noun is down]down[otherwise][noun]~]
                  say__c=0; say__p=1; 
.L_Say18; if (((noun == u_obj))) say__c=true; else jump L_Say19;    print (I7_string) SC_25;   
.L_Say19; if (say__c==false) { say__c=((((noun == d_obj)))==true);
		if (say__c==false) jump L_Say20;
	} else jump L_Say20;
   print (I7_string) SC_26;  
.L_Say20; if (say__c==false) say__c=true; else jump L_Say21;    print (name) noun;   .L_Say21;
                  ! phrase 18
                  ! [18: otherwise]
                  } else {

                  ! phrase 19
                  ! [19: say ~ at [the room gone to] from [if the back way is	up]above[otherwise if the back way is	down]below[otherwise]the [back way]~]
                  say__c=0; say__p=1;  print (I7_string) SC_27;    print (the) (MStack-->MstVO(20007,1));    print (I7_string) SC_21;   
.L_Say22; if (((t_0 == u_obj))) say__c=true; else jump L_Say23;    print (I7_string) SC_22;   
.L_Say23; if (say__c==false) { say__c=((((t_0 == d_obj)))==true);
		if (say__c==false) jump L_Say24;
	} else jump L_Say24;
   print (I7_string) SC_23;  
.L_Say24; if (say__c==false) say__c=true; else jump L_Say25;    print (I7_string) SC_24;    print (name) t_0;   .L_Say25;
                  ! phrase 20
                  ! [20: end if]
                  }

               ! phrase 21
               ! [21: end if]
               }

            ! phrase 22
            ! [22: otherwise]
            } else {

            ! phrase 23
            ! [23: say ~[if the location is the room gone from] goes through	[otherwise] arrives from [end if][the noun]~]
            say__c=0; say__p=1; 
.L_Say26; if (((real_location == (MStack-->MstVO(20007,0))))) say__c=true; else jump L_Say27;    print (I7_string) SC_28;  
.L_Say27; if (say__c==false) say__c=true; else jump L_Say28;    print (I7_string) SC_29;   
.L_Say28; say__c = false;    print (the) noun;   .L_Say29;
            ! phrase 24
            ! [24: end if]
            }

         ! phrase 25
         ! [25: if the vehicle gone by is not nothing begin]
           if (~~(((MStack-->MstVO(20007,3)) == nothing)))   {
            ! phrase 26
            ! [26: if the vehicle gone by is a supporter , say ~ on ~]
              if (((MStack-->MstVO(20007,3)) ofclass K6_supporter)) { say__c=0; say__p=1;  print (I7_string) SC_16;   .L_Say30;   }
            ! phrase 27
            ! [27: otherwise say ~ in ~]
              else { say__c=0; say__p=1;  print (I7_string) SC_30;   .L_Say31;   }
            ! phrase 28
            ! [28: say ~[the vehicle gone by]~]
            say__c=0; say__p=1;  print (the) (MStack-->MstVO(20007,3));   .L_Say32;
            ! phrase 29
            ! [29: end if]
            }

         ! phrase 30
         ! [30: if the thing gone with is not nothing begin]
           if (~~(((MStack-->MstVO(20007,4)) == nothing)))   {
            ! phrase 31
            ! [31: say ~, pushing [the thing gone with]~]
            say__c=0; say__p=1;  print (I7_string) SC_31;    print (the) (MStack-->MstVO(20007,4));   .L_Say33;
            ! phrase 32
            ! [32: if the player is within the thing gone with begin]
              if (((MStack-->MstVO(20007,4)) == I7_InWhat(player)))   {
               ! phrase 33
               ! [33: say ~ in front, and you along too~]
               say__c=0; say__p=1;  print (I7_string) SC_32;   .L_Say34;
               ! phrase 34
               ! [34: otherwise if the player is within the vehicle gone by]
                 } else if (((MStack-->MstVO(20007,3)) == I7_InWhat(player))) {  
               ! phrase 35
               ! [35: say ~ in front~]
               say__c=0; say__p=1;  print (I7_string) SC_33;   .L_Say35;
               ! phrase 36
               ! [36: otherwise if the location is the room gone from]
                 } else if ((real_location == (MStack-->MstVO(20007,0)))) {  
               ! phrase 37
               ! [37: say ~ away~]
               say__c=0; say__p=1;  print (I7_string) SC_34;   .L_Say36;
               ! phrase 38
               ! [38: otherwise]
               } else {

               ! phrase 39
               ! [39: say ~ in~]
               say__c=0; say__p=1;  print (I7_string) SC_35;   .L_Say37;
               ! phrase 40
               ! [40: end if]
               }

            ! phrase 41
            ! [41: end if]
            }

         ! phrase 42
         ! [42: if the player is within the vehicle gone by and the player is not within the thing gone with begin]
           if ((((MStack-->MstVO(20007,3)) == I7_InWhat(player))) && (~~(((MStack-->MstVO(20007,4)) == I7_InWhat(player)))))   {
            ! phrase 43
            ! [43: say ~, taking you along.~]
            say__c=0; say__p=1;  print (I7_string) SC_36;   new_line; .L_Say38;
            ! phrase 44
            ! [44: try looking]
              I7_TryAction(0, player, ##Look, 0, 0);;  
            ! phrase 45
            ! [45: continue the action]
              rfalse;  
            ! phrase 46
            ! [46: end if]
            }

         ! phrase 47
         ! [47: say ~.~]
         say__c=0; say__p=1;  print (I7_string) SC_11;   new_line; .L_Say39;
         ! phrase 48
         ! [48: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_90, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B137_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_91 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_91);
      ! phrase 1
      ! [1: if the noun is a door , convert to the going action on the noun]
        if ((noun ofclass K4_door)) {   return GVS_Convert(##Go,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_91, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_92 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_92);
      ! phrase 1
      ! [1: if the noun is a direction , convert to the going action on the noun]
        if ((noun ofclass K3_direction)) {   return GVS_Convert(##Go,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_92, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_93 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_93);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message entering action number 1 for the noun]
        if ((t_0 == noun)) {   return GL__M(##Enter,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_93, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_94 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_94);
      ! phrase 1
      ! [1: if the noun is not enterable , stop the action with library message entering action number 2 for the noun]
        if (~~((I7GetEitherOr(noun,enterable)))) {   return GL__M(##Enter,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_94, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_95 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_95);
      ! phrase 1
      ! [1: if the noun is a closed container , stop the action with library message entering action number 3 for the noun]
        if (((noun ofclass K5_container) && (I7GetEitherOr(noun,open)==false))) {   return GL__M(##Enter,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_95, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_96 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_96);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: if the local ceiling is the actor , stop the action with library message entering action number 4 for the noun]
        if ((t_0 == actor)) {   return GL__M(##Enter,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_96, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_97 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    t_1 ! Local variable e.g. 'target' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_97);
      ! phrase 1
      ! [1: if the holder of the actor is the holder of the noun , continue the action]
        if ((  (I7_Holder(actor))   ==   (I7_Holder(noun))  )) {   rfalse;     }
      ! phrase 2
      ! [2: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 3
      ! [3: while the holder of the actor is not the local ceiling begin]
        while (~~((  (I7_Holder(actor))   == t_0)))   {
         ! phrase 4
         ! [4: let the target be the holder of the actor]
           t_1 =   (I7_Holder(actor))  ;  
         ! phrase 5
         ! [5: issue library message entering action number 6 for the target]
           GL__M(##Enter,6,t_1);  
         ! phrase 6
         ! [6: silently try the actor trying exiting]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent;  
         ! phrase 7
         ! [7: if the holder of the actor is the target , stop the action]
           if ((  (I7_Holder(actor))   == t_1)) {   rtrue;     }
         ! phrase 8
         ! [8: end while]
         }

      ! phrase 9
      ! [9: if the holder of the actor is the noun , stop the action]
        if ((  (I7_Holder(actor))   == noun)) {   rtrue;     }
      ! phrase 10
      ! [10: if the holder of the actor is the holder of the noun , continue the action]
        if ((  (I7_Holder(actor))   ==   (I7_Holder(noun))  )) {   rfalse;     }
      ! phrase 11
      ! [11: let the target be the holder of the noun]
        t_1 =   (I7_Holder(noun))  ;  
      ! phrase 12
      ! [12: if the noun is part of the target , let the target be the holder of the target]
        if ((t_1 == (noun.component_parent))) {   t_1 =   (I7_Holder(t_1))  ;     }
      ! phrase 13
      ! [13: while the target is a thing begin]
        while ((t_1 ofclass K2_thing))   {
         ! phrase 14
         ! [14: if the holder of the target is the local ceiling begin]
           if ((  (I7_Holder(t_1))   == t_0))   {
            ! phrase 15
            ! [15: issue library message entering action number 7 for the target]
              GL__M(##Enter,7,t_1);  
            ! phrase 16
            ! [16: silently try the actor trying entering the target]
              @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Enter, t_1, 0);; @pull keep_silent;  
            ! phrase 17
            ! [17: if the holder of the actor is not the target , stop the action]
              if (~~((  (I7_Holder(actor))   == t_1))) {   rtrue;     }
            ! phrase 18
            ! [18: convert to the entering action on the noun]
              return GVS_Convert(##Enter,noun,0);  
            ! phrase 19
            ! [19: continue the action]
              rfalse;  
            ! phrase 20
            ! [20: end if]
            }

         ! phrase 21
         ! [21: let the target be the holder of the target]
           t_1 =   (I7_Holder(t_1))  ;  
         ! phrase 22
         ! [22: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_97, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B138_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor entering ( this is the standard entering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor entering ( this is the standard entering rule ):
[ R_98 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_98);
      ! phrase 1
      ! [1: move the actor to the noun at object tree level]
        move actor to noun;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_98, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B139_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor entering ( this is the standard report entering rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor entering ( this is the standard report entering rule ):
[ R_99 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_99);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message entering action number 5 for the noun]
           GL__M(##Enter,5,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor] gets [if the noun is a container]into[otherwise]onto[end if] [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_37;   
.L_Say40; if (((noun ofclass K5_container))) say__c=true; else jump L_Say41;    print (I7_string) SC_38;  
.L_Say41; if (say__c==false) say__c=true; else jump L_Say42;    print (I7_string) SC_39;   
.L_Say42; say__c = false;    print (I7_string) SC_40;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say43;
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_99, true);
   rfalse;
];
! From the Standard Rules
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_100 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_100);
      ! phrase 1
      ! [1: if the actor is the player , describe the locale of the noun]
        if ((actor == player)) {   Locale(noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_100, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B140_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor exiting ( this is the convert exit into go out rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor exiting ( this is the convert exit into get off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_102 
    t_0 ! Local variable e.g. 'local room' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_102);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
        t_0 =   I7_Location(actor)  ;  
      ! phrase 2
      ! [2: if the container exited from is the local room begin]
        if (((MStack-->MstVO(20009,0)) == t_0))   {
         ! phrase 3
         ! [3: if the room-or-door outside from the local room is not nothing , convert to the going action on the outside]
           if (~~(((Resolver_5(out_obj,t_0,"source", 0)) == nothing))) {   return GVS_Convert(##Go,out_obj,0);     }
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_102, true);
   rfalse;
];
! From the Standard Rules
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_103 
    t_0 ! Local variable e.g. 'local room' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_103);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
        t_0 =   I7_Location(actor)  ;  
      ! phrase 2
      ! [2: if the container exited from is the local room , stop the action with library message exiting action number 1 for the actor]
        if (((MStack-->MstVO(20009,0)) == t_0)) {   return GL__M(##Exit,1,actor);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_103, true);
   rfalse;
];
! From the Standard Rules
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_104 
    t_0 ! Local variable e.g. 'cage' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_104);
      ! phrase 1
      ! [1: if the actor is in a closed container ( called the cage ) , stop the action with library message exiting action number 2 for the cage]
        if (((t_0=I7_InWhat(actor)) && (I7_InWhat(actor) ofclass K5_container) && (I7GetEitherOr(I7_InWhat(actor),open)==false))) {   return GL__M(##Exit,2,t_0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_104, true);
   rfalse;
];
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_105 
    t_0 ! Local variable e.g. 'platform' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_105);
      ! phrase 1
      ! [1: if the actor is on a supporter ( called the platform ) , convert to the getting off action on the platform]
        if (((t_0=I7_OnWhat(actor)) && (I7_OnWhat(actor) ofclass K6_supporter))) {   return GVS_Convert(##GetOff,t_0,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_105, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B141_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor exiting ( this is the standard exiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_106 
    t_0 ! Local variable e.g. 'former exterior' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_106);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the container exited from]
        t_0 =   (OIU_Parent((MStack-->MstVO(20009,0))))  ;  
      ! phrase 2
      ! [2: move the actor to the former exterior at object tree level]
        move actor to t_0;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_106, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B142_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor exiting ( this is the describe room emerged into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_107 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_107);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the container exited from]
           GL__M(##Exit,3,(MStack-->MstVO(20009,0)));  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor] gets out of [the container exited from].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_41;    print (the) (MStack-->MstVO(20009,0));    print (I7_string) SC_11;   new_line; .L_Say44;
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_107, true);
   rfalse;
];
! From the Standard Rules
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_108 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_108);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
        if ((actor == player)) {   I7_RoomDescriptionForGoing();     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_108, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B143_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor getting off ( this is the can't get off things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor getting off ( this is the can't get off things rule ):
[ R_109 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_109);
      ! phrase 1
      ! [1: if the actor is on the noun , continue the action]
        if ((noun == I7_OnWhat(actor))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is carried by the noun , continue the action]
        if ((noun == I7_CarriedBy(actor))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message getting off action number 1 for the noun]
        return GL__M(##GetOff,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_109, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B144_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor getting off ( this is the standard getting off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_110 
    t_0 ! Local variable e.g. 'former exterior' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_110);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the noun]
        t_0 =   (OIU_Parent(noun))  ;  
      ! phrase 2
      ! [2: move the actor to the former exterior at object tree level]
        move actor to t_0;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_110, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B145_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor getting off ( this is the describe room stood up into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_111 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_111);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the noun]
           GL__M(##Exit,3,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor] gets off [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_42;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say45;
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_111, true);
   rfalse;
];
! From the Standard Rules
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_112 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_112);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
        if ((actor == player)) {   I7_RoomDescriptionForGoing();     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_112, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B147_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Carry out looking ( this is the room description heading rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Carry out looking ( this is the room description body text rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Carry out looking ( this is the check new arrival rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out looking ( this is the room description heading rule ):
[ R_114 
    t_0 ! Local variable e.g. 'intermediate level' = OBJECT_TY
    t_1 ! Local variable e.g. '?-1,-1?' = NUMBER_TY
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_114);
      ! phrase 1
      ! [1: say bold type]
      say__c=0; say__p=1;  style bold;   .L_Say46;
      ! phrase 2
      ! [2: if the visibility level count is 0 begin]
        if (((MStack-->MstVO(20011,1)) == 0))   {
         ! phrase 3
         ! [3: say short name of the darkness pseudo-room]
         say__c=0; say__p=1;  print (name) thedark;   .L_Say47;
         ! phrase 4
         ! [4: otherwise if the visibility ceiling is the location]
           } else if (((MStack-->MstVO(20011,2)) == real_location)) {  
         ! phrase 5
         ! [5: say ~[visibility ceiling]~]
         say__c=0; say__p=1;  print (name) (MStack-->MstVO(20011,2));   .L_Say48;
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: say ~[The visibility ceiling]~]
         say__c=0; say__p=1;  print (The) (MStack-->MstVO(20011,2));   .L_Say49;
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: say roman type]
      say__c=0; say__p=1;  style roman;   .L_Say50;
      ! phrase 10
      ! [10: let intermediate level be the visibility-holder of the actor]
        t_0 =   Vis_parent(actor)  ;  
      ! phrase 11
      ! [11: repeat with intermediate level count running from 2 to the visibility level count begin]
        for (t_1=2: t_1<=(MStack-->MstVO(20011,1)): t_1++)   {
         ! phrase 12
         ! [12: issue library message looking action number 8 for the intermediate level]
           GL__M(##Look,8,t_0);  
         ! phrase 13
         ! [13: let the intermediate level be the visibility-holder of the intermediate level]
           t_0 =   Vis_parent(t_0)  ;  
         ! phrase 14
         ! [14: end repeat]
         }

      ! phrase 15
      ! [15: say line break]
      say__c=0; say__p=1;  new_line;   .L_Say51;
      ! phrase 16
      ! [16: say run paragraph on with special look spacing]
      say__c=0; say__p=1;  I7_RunOnParagraph();   .L_Say52;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_114, true);
   rfalse;
];
! From the Standard Rules
! Carry out looking ( this is the room description body text rule ):
[ R_115 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_115);
      ! phrase 1
      ! [1: describe main room area for the visibility ceiling]
        I7_RoomDescPara((MStack-->MstVO(20011,2)));  
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_115, true);
   rfalse;
];
! From the Standard Rules
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_116 
    t_0 ! Local variable e.g. 'intermediate position' = OBJECT_TY
    t_1 ! Local variable e.g. 'IP count' = NUMBER_TY
    t_2 ! Local variable e.g. 'top-down IP count' = NUMBER_TY
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_116);
      ! phrase 1
      ! [1: if the visibility level count is 0 begin]
        if (((MStack-->MstVO(20011,1)) == 0))   {
         ! phrase 2
         ! [2: describe locale for the darkness pseudo-room]
           Locale(thedark);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: let the intermediate position be the actor]
           t_0 = actor;  
         ! phrase 5
         ! [5: let the ip count be the visibility level count]
           t_1 = (MStack-->MstVO(20011,1));  
         ! phrase 6
         ! [6: while the ip count is greater than 0 begin]
           while ((t_1 > 0))   {
            ! phrase 7
            ! [7: now the intermediate position is marked for listing]
              I7SetEitherOr(t_0,workflag);  
            ! phrase 8
            ! [8: let the intermediate position be the visibility-holder of the intermediate position]
              t_0 =   Vis_parent(t_0)  ;  
            ! phrase 9
            ! [9: decrease the ip count by 1]
              t_1 = t_1 - 1;  
            ! phrase 10
            ! [10: end while]
            }

         ! phrase 11
         ! [11: let the top-down ip count be the visibility level count]
           t_2 = (MStack-->MstVO(20011,1));  
         ! phrase 12
         ! [12: while the top-down ip count is greater than 0 begin]
           while ((t_2 > 0))   {
            ! phrase 13
            ! [13: let the intermediate position be the actor]
              t_0 = actor;  
            ! phrase 14
            ! [14: let the ip count be 0]
              t_1 = 0;  
            ! phrase 15
            ! [15: while the ip count is less than the top-down ip count begin]
              while ((t_1 < t_2))   {
               ! phrase 16
               ! [16: let the intermediate position be the visibility-holder of the intermediate position]
                 t_0 =   Vis_parent(t_0)  ;  
               ! phrase 17
               ! [17: increase the ip count by 1]
                 t_1 = t_1 + 1;  
               ! phrase 18
               ! [18: end while]
               }

            ! phrase 19
            ! [19: describe locale for the intermediate position]
              Locale(t_0);  
            ! phrase 20
            ! [20: decrease the top-down ip count by 1]
              t_2 = t_2 - 1;  
            ! phrase 21
            ! [21: end while]
            }

         ! phrase 22
         ! [22: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_116, true);
   rfalse;
];
! From the Standard Rules
! Carry out looking ( this is the check new arrival rule ):
[ R_117 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_117);
      ! phrase 1
      ! [1: if in darkness begin]
        if ((  (location==thedark)  ))   {
         ! phrase 2
         ! [2: mark the darkness pseudo-room as visited]
           give thedark visited;  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the location is a room , now the location is visited]
           if ((real_location ofclass K1_room)) {   I7SetEitherOr(real_location,visited);     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_117, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B148_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor looking ( this is the other people looking rule ):
[ R_118 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_118);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks around.~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_43;   new_line; .L_Say53;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_118, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B150_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Carry out examining ( this is the examine undescribed containers rule ):
!   === which is equally specific with ===
! Rule 2/6 ! Carry out examining ( this is the examine undescribed devices rule ):
!   === which is equally specific with ===
! Rule 3/6 ! Carry out examining ( this is the examine undescribed things rule ):
!   === which is equally specific with ===
! Rule 4/6 ! Carry out examining ( this is the examine directions rule ):
!   === which is equally specific with ===
! Rule 5/6 ! Carry out examining ( this is the standard examining rule ):
!   === which is equally specific with ===
! Rule 6/6 ! Carry out examining ( this is the examine described devices rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out examining ( this is the examine undescribed containers rule ):
[ R_119 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_119);
      ! phrase 1
      ! [1: if the noun goes undescribed by source text and the noun is a container , convert to the searching action on the noun]
        if (((  (noun.description == 0)  )) && ((noun ofclass K5_container))) {   return GVS_Convert(##Search,noun,0);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_119, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine undescribed devices rule ):
[ R_120 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_120);
      ! phrase 1
      ! [1: if the noun goes undescribed by source text and the noun is a device , stop the action with library message examining action number 3 for the noun]
        if (((  (noun.description == 0)  )) && ((noun ofclass K11_device))) {   return GL__M(##Examine,3,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_120, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine undescribed things rule ):
[ R_121 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_121);
      ! phrase 1
      ! [1: if the noun goes undescribed by source text , stop the action with library message examining action number 2 for the noun]
        if ((  (noun.description == 0)  )) {   return GL__M(##Examine,2,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_121, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine directions rule ):
[ R_122 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_122);
      ! phrase 1
      ! [1: if the noun is a direction begin]
        if ((noun ofclass K3_direction))   {
         ! phrase 2
         ! [2: say ~You see nothing unexpected in that direction.~]
         say__c=0; say__p=1;  print (I7_string) SC_44;   new_line; .L_Say54;
         ! phrase 3
         ! [3: stop the action]
           rtrue;  
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_122, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the standard examining rule ):
[ R_123 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_123);
      ! phrase 1
      ! [1: say ~[the description of the noun][line break]~]
      say__c=0; say__p=1;#ifdef TARGET_ZCODE; @push self; #ifnot; @copy self sp; #endif;   print (I7_string) AccessProp(self=noun,description);  #ifdef TARGET_ZCODE; @pull self; #ifnot; @copy sp self; #endif;   new_line;   .L_Say55;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_123, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine described devices rule ):
[ R_124 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_124);
      ! phrase 1
      ! [1: if the noun is a device , stop the action with library message examining action number 3 for the noun]
        if ((noun ofclass K11_device)) {   return GL__M(##Examine,3,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_124, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B151_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor examining ( this is the report other people examining rule ):
[ R_125 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_125);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks closely at [the noun].~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_45;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say56;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_125, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B153_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_126 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_126);
      ! phrase 1
      ! [1: stop the action with library message looking under action number 2 for the noun]
        return GL__M(##LookUnder,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_126, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B154_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_127 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_127);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks under [the noun].~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_46;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say57;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_127, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B155_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_128 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_128);
      ! phrase 1
      ! [1: if the noun is not a container and the noun is not a supporter , stop the action with library message searching action number 4 for the noun]
        if (((Prop_13(noun))) && ((Prop_14(noun)))) {   return GL__M(##Search,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_128, true);
   rfalse;
];
! From the Standard Rules
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_129 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_129);
      ! phrase 1
      ! [1: if the noun is a closed opaque container , stop the action with library message searching action number 5 for the noun]
        if (((noun ofclass K5_container) && (I7GetEitherOr(noun,open)==false) && (I7GetEitherOr(noun,transparent)==false))) {   return GL__M(##Search,5,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_129, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B157_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report searching a container ( this is the standard search containers rule ):
[ R_130 ;
   if ( (actor==player) && (noun ofclass K5_container)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_130);
      ! phrase 1
      ! [1: if the noun contains a described thing which is not scenery , issue library message searching action number 7 for the noun]
        if ((Prop_15(noun))) {   GL__M(##Search,7,noun);     }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 6 for the noun]
        else {   GL__M(##Search,6,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_130, true);
   rfalse;
];
! From the Standard Rules
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_131 ;
   if ( (actor==player) && (noun ofclass K6_supporter)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_131);
      ! phrase 1
      ! [1: if the noun supports a described thing which is not scenery , issue library message searching action number 3 for the noun]
        if ((Prop_16(noun))) {   GL__M(##Search,3,noun);     }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 2 for the noun]
        else {   GL__M(##Search,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_131, true);
   rfalse;
];
! From the Standard Rules
! Report an actor searching ( this is the report other people searching rule ):
[ R_132 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_132);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] searches [the noun].~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_47;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say58;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_132, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B160_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_133 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_133);
      ! phrase 1
      ! [1: if the actor is the player , issue library message consulting it about action number 1 for the noun]
        if ((actor == player)) {   GL__M(##Consult,1,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] looks at [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_48;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say59;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_133, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B161_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor locking something with ( this is the can't lock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_134 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_134);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
        if (((  (I7_Provides(noun, true,lockable))  )) && ((I7GetEitherOr(noun,lockable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message locking it with action number 1 for the noun]
        return GL__M(##Lock,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_134, true);
   rfalse;
];
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_135 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_135);
      ! phrase 1
      ! [1: if the noun is locked , stop the action with library message locking it with action number 2 for the noun]
        if ((I7GetEitherOr(noun,locked))) {   return GL__M(##Lock,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_135, true);
   rfalse;
];
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_136 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_136);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message locking it with action number 3 for the noun]
        if ((I7GetEitherOr(noun,open))) {   return GL__M(##Lock,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_136, true);
   rfalse;
];
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_137 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_137);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message locking it with action number 4 for the second noun]
        if ((~~((  (I7_Holder(second))   == actor))) || (((  (I7_Provides(noun, false,with_key)==false)  )) || (~~((AccessProp(noun,with_key) == second))))) {   return GL__M(##Lock,4,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_137, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B162_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_138 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_138);
      ! phrase 1
      ! [1: now the noun is locked]
        I7SetEitherOr(noun,locked);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_138, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B163_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_139 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_139);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message locking it with action number 5 for the noun]
           GL__M(##Lock,5,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , say ~[The actor] locks [the noun].~]
           if ((Adj_1(actor))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_49;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say60;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_139, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B164_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_140 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_140);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
        if (((  (I7_Provides(noun, true,lockable))  )) && ((I7GetEitherOr(noun,lockable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message unlocking it with action number 1 for the noun]
        return GL__M(##Unlock,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_140, true);
   rfalse;
];
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_141 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_141);
      ! phrase 1
      ! [1: if the noun is not locked , stop the action with library message unlocking it with action number 2 for the noun]
        if (~~((I7GetEitherOr(noun,locked)))) {   return GL__M(##Unlock,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_141, true);
   rfalse;
];
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_142 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_142);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message unlocking it with action number 3 for the second noun]
        if ((~~((  (I7_Holder(second))   == actor))) || (((  (I7_Provides(noun, false,with_key)==false)  )) || (~~((AccessProp(noun,with_key) == second))))) {   return GL__M(##Unlock,3,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_142, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B165_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_143 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_143);
      ! phrase 1
      ! [1: now the noun is not locked]
        I7SetEitherOr(noun,locked,true);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_143, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B166_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_144 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_144);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message unlocking it with action number 4 for the noun]
           GL__M(##Unlock,4,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , say ~[The actor] unlocks [the noun].~]
           if ((Adj_1(actor))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_50;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say61;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_144, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B167_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_145 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_145);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
        if ((  (I7_Provides(noun, true,on))  )) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message switching on action number 1 for the noun]
        return GL__M(##SwitchOn,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_145, true);
   rfalse;
];
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_146 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_146);
      ! phrase 1
      ! [1: if the noun is switched on , stop the action with library message switching on action number 2 for the noun]
        if ((I7GetEitherOr(noun,on))) {   return GL__M(##SwitchOn,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_146, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B168_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_147 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_147);
      ! phrase 1
      ! [1: now the noun is switched on]
        I7SetEitherOr(noun,on);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_147, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B169_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_148 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_148);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching on action number 3 for the noun]
        if ((actor == player)) {   GL__M(##SwitchOn,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] switches [the noun] on.~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_51;    print (the) noun;    print (I7_string) SC_52;   new_line; .L_Say62;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_148, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B170_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_149 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_149);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
        if ((  (I7_Provides(noun, true,on))  )) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message switching off action number 1 for the noun]
        return GL__M(##SwitchOff,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_149, true);
   rfalse;
];
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_150 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_150);
      ! phrase 1
      ! [1: if the noun is switched off , stop the action with library message switching off action number 2 for the noun]
        if ((I7GetEitherOr(noun,on)==false)) {   return GL__M(##SwitchOff,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_150, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B171_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_151 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_151);
      ! phrase 1
      ! [1: now the noun is switched off]
        I7SetEitherOr(noun,on,true);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_151, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B172_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_152 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_152);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching off action number 3 for the noun]
        if ((actor == player)) {   GL__M(##SwitchOff,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] switches [the noun] off.~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_51;    print (the) noun;    print (I7_string) SC_53;   new_line; .L_Say63;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_152, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B173_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_153 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_153);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
        if (((  (I7_Provides(noun, true,openable))  )) && ((I7GetEitherOr(noun,openable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message opening action number 1 for the noun]
        return GL__M(##Open,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_153, true);
   rfalse;
];
! From the Standard Rules
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_154 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_154);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is locked , stop the action with library message opening action number 2 for the noun]
        if (((  (I7_Provides(noun, true,lockable))  )) && ((I7GetEitherOr(noun,locked)))) {   return GL__M(##Open,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_154, true);
   rfalse;
];
! From the Standard Rules
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_155 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_155);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message opening action number 3 for the noun]
        if ((I7GetEitherOr(noun,open))) {   return GL__M(##Open,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_155, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B174_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor opening ( this is the standard opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor opening ( this is the standard opening rule ):
[ R_156 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_156);
      ! phrase 1
      ! [1: now the noun is open]
        I7SetEitherOr(noun,open);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_156, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B175_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_157 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_157);
      ! phrase 1
      ! [1: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor , stop the action with library message opening action number 4 for the noun]
        if (((actor == player)) && ((((noun ofclass K5_container) && (I7GetEitherOr(noun,transparent)==false))) && ((~~((  (child(noun))   == nothing))) && (~~((I7_IndirectlyContains(noun,actor))))))) {   return GL__M(##Open,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_157, true);
   rfalse;
];
! From the Standard Rules
! Report an actor opening ( this is the standard report opening rule ):
[ R_158 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_158);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message opening action number 5 for the noun]
           GL__M(##Open,5,noun);  
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
           } else if ((I7_CanSee(player,actor))) {  
         ! phrase 4
         ! [4: say ~[The actor] opens [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_54;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say64;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~[The noun] opens.~]
         say__c=0; say__p=1;  print (The) noun;    print (I7_string) SC_55;   new_line; .L_Say65;
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_158, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B176_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_159 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_159);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
        if (((  (I7_Provides(noun, true,openable))  )) && ((I7GetEitherOr(noun,openable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message closing action number 1 for the noun]
        return GL__M(##Close,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_159, true);
   rfalse;
];
! From the Standard Rules
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_160 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_160);
      ! phrase 1
      ! [1: if the noun is closed , stop the action with library message closing action number 2 for the noun]
        if ((I7GetEitherOr(noun,open)==false)) {   return GL__M(##Close,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_160, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B177_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor closing ( this is the standard closing rule ):
[ R_161 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_161);
      ! phrase 1
      ! [1: now the noun is closed]
        I7SetEitherOr(noun,open,true);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_161, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B178_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor closing ( this is the standard report closing rule ):
[ R_162 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_162);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message closing action number 3 for the noun]
           GL__M(##Close,3,noun);  
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
           } else if ((I7_CanSee(player,actor))) {  
         ! phrase 4
         ! [4: say ~[The actor] closes [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_56;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say66;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~[The noun] closes.~]
         say__c=0; say__p=1;  print (The) noun;    print (I7_string) SC_57;   new_line; .L_Say67;
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_162, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B179_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_163 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_163);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not wearable , stop the action with library message wearing action number 1 for the noun]
        if (((Prop_17(noun))) || (~~((I7GetEitherOr(noun,clothing))))) {   return GL__M(##Wear,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_163, true);
   rfalse;
];
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_164 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_164);
      ! phrase 1
      ! [1: if the holder of the noun is not the actor , stop the action with library message wearing action number 2 for the noun]
        if (~~((  (I7_Holder(noun))   == actor))) {   return GL__M(##Wear,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_164, true);
   rfalse;
];
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_165 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_165);
      ! phrase 1
      ! [1: if the actor is wearing the noun , stop the action with library message wearing action number 3 for the noun]
        if ((actor == I7_WornBy(noun))) {   return GL__M(##Wear,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_165, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B180_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_166 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_166);
      ! phrase 1
      ! [1: now the actor wears the noun]
        I7_Wear(noun,actor);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_166, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B181_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_167 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_167);
      ! phrase 1
      ! [1: if the actor is the player , issue library message wearing action number 4 for the noun]
        if ((actor == player)) {   GL__M(##Wear,4,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts on [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_58;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say68;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_167, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B182_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_168 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_168);
      ! phrase 1
      ! [1: if the actor is not wearing the noun , stop the action with library message taking off action number 1 for the noun]
        if (~~((actor == I7_WornBy(noun)))) {   return GL__M(##Disrobe,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_168, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B183_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_169 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_169);
      ! phrase 1
      ! [1: now the actor carries the noun]
        I7_Move(noun,actor);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_169, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B184_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_170 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_170);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking off action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Disrobe,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] takes off [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_59;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say69;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_170, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B185_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor giving something to ( this is the block giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_171 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_171);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message giving it to action number 1 for the noun]
        if (~~((actor ==   (I7_Holder(noun))  ))) {   return GL__M(##Give,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_171, true);
   rfalse;
];
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_172 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_172);
      ! phrase 1
      ! [1: if the actor is the second noun , stop the action with library message giving it to action number 2 for the noun]
        if ((actor == second)) {   return GL__M(##Give,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_172, true);
   rfalse;
];
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_173 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_173);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message giving it to action number 4 for the second noun]
        if ((Prop_18(second))) {   return GL__M(##Give,4,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_173, true);
   rfalse;
];
! From the Standard Rules
! Check an actor giving something to ( this is the block giving rule ):
[ R_174 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_174);
      ! phrase 1
      ! [1: stop the action with library message giving it to action number 3 for the second noun]
        return GL__M(##Give,3,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_174, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Giving it to (B186_carry_out_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor giving something to ( this is the standard giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_175 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_175);
      ! phrase 1
      ! [1: move the noun to the second noun]
        I7_Move(noun, second, 0, 0);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_175, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B187_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor giving something to ( this is the standard report giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_176 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_176);
      ! phrase 1
      ! [1: if the actor is the player , say ~You give [the noun] to [the second noun].~]
        if ((actor == player)) { say__c=0; say__p=1;  print (I7_string) SC_60;    print (the) noun;    print (I7_string) SC_61;    print (the) second;    print (I7_string) SC_11;   new_line; .L_Say70;   }
      ! phrase 2
      ! [2: otherwise say ~[The actor] gives [the noun] to [if the second noun is the	player]you[otherwise][the second noun][end if].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_62;    print (the) noun;    print (I7_string) SC_61;   
.L_Say71; if (((second == player))) say__c=true; else jump L_Say72;    print (I7_string) SC_63;  
.L_Say72; if (say__c==false) say__c=true; else jump L_Say73;    print (the) second;   
.L_Say73; say__c = false;    print (I7_string) SC_11;   new_line; .L_Say74;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_176, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B188_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor showing something to ( this is the block showing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_177 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_177);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message showing it to action number 1 for the noun]
        if (~~((actor ==   (I7_Holder(noun))  ))) {   return GL__M(##Show,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_177, true);
   rfalse;
];
! From the Standard Rules
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_178 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_178);
      ! phrase 1
      ! [1: if the actor is the second noun , convert to the examining action on the noun]
        if ((actor == second)) {   return GVS_Convert(##Examine,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_178, true);
   rfalse;
];
! From the Standard Rules
! Check an actor showing something to ( this is the block showing rule ):
[ R_179 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_179);
      ! phrase 1
      ! [1: stop the action with library message showing it to action number 2 for the second noun]
        return GL__M(##Show,2,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_179, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B191_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waking ( this is the block waking rule ):
[ R_180 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_180);
      ! phrase 1
      ! [1: stop the action with library message waking action number 1 for the noun]
        return GL__M(##WakeOther,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_180, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B194_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_181 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_181);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
           GL__M(##Drop,3,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_181, true);
   rfalse;
];
! From the Standard Rules
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_182 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_182);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message throwing it at action number 1 for the second noun]
        if ((Prop_19(second))) {   return GL__M(##ThrowAt,1,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_182, true);
   rfalse;
];
! From the Standard Rules
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_183 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_183);
      ! phrase 1
      ! [1: stop the action with library message throwing it at action number 2 for the noun]
        return GL__M(##ThrowAt,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_183, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B197_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor attacking ( this is the block attacking rule ):
[ R_184 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_184);
      ! phrase 1
      ! [1: stop the action with library message attacking action number 1 for the noun]
        return GL__M(##Attack,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_184, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B200_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_185 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_185);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message touching action number 3 for the noun]
        if ((noun == actor)) {   return GL__M(##Touch,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_185, true);
   rfalse;
];
! From the Standard Rules
! Check an actor kissing ( this is the block kissing rule ):
[ R_186 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_186);
      ! phrase 1
      ! [1: stop the action with library message kissing action number 1 for the noun]
        return GL__M(##Kiss,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_186, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Answering it that (B205_report_answering_it_tha)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor answering something that ( this is the block answering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor answering something that ( this is the block answering rule ):
[ R_187 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_187);
      ! phrase 1
      ! [1: stop the action with library message answering it that action number 1 for the noun]
        return GL__M(##Answer,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_187, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B206_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_188 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_188);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message telling it about action number 1 for the noun]
        if ((actor == noun)) {   return GL__M(##Tell,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_188, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Telling it about (B208_report_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor telling something about ( this is the block telling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor telling something about ( this is the block telling rule ):
[ R_189 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_189);
      ! phrase 1
      ! [1: stop the action with library message telling it about action number 2 for the noun]
        return GL__M(##Tell,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_189, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Asking it about (B211_report_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor asking something about ( this is the block asking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor asking something about ( this is the block asking rule ):
[ R_190 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_190);
      ! phrase 1
      ! [1: stop the action with library message asking it about action number 1 for the noun]
        return GL__M(##Ask,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_190, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B212_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_191 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_191);
      ! phrase 1
      ! [1: if the actor is the noun and the actor is the player , try taking inventory instead]
        if (((actor == noun)) && ((actor == player))) {   I7_TryAction(0, player, ##Inv, 0, 0);;     rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_191, true);
   rfalse;
];
! From the Standard Rules
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_192 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_192);
      ! phrase 1
      ! [1: convert to request of the noun to perform giving it to action with the second noun and the actor]
        I7_TryAction(true, noun, ##Give, second, actor); rtrue;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_192, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B217_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_193 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_193);
      ! phrase 1
      ! [1: if the actor is the player , stop the action with library message waiting action number 1 for the actor]
        if ((actor == player)) {   return GL__M(##Wait,1,actor);     }
      ! phrase 2
      ! [2: say ~[The actor] waits.~]
      say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_64;   new_line; .L_Say75;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_193, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B220_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor touching ( this is the report touching yourself rule ):
[ R_194 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_194);
      ! phrase 1
      ! [1: if the noun is the actor begin]
        if ((noun == actor))   {
         ! phrase 2
         ! [2: if the actor is the player , issue library message touching action number 3 for the noun]
           if ((actor == player)) {   GL__M(##Touch,3,noun);     }
         ! phrase 3
         ! [3: otherwise say ~[The actor] touches	[if the actor is female]herself[otherwise]himself[end if].~]
           else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_65;   
.L_Say76; if (((I7GetEitherOr(actor,female)))) say__c=true; else jump L_Say77;    print (I7_string) SC_66;  
.L_Say77; if (say__c==false) say__c=true; else jump L_Say78;    print (I7_string) SC_67;   
.L_Say78; say__c = false;    print (I7_string) SC_11;   new_line; .L_Say79;   }
         ! phrase 4
         ! [4: stop the action]
           rtrue;  
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_194, true);
   rfalse;
];
! From the Standard Rules
! Report an actor touching ( this is the report touching other people rule ):
[ R_195 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_195);
      ! phrase 1
      ! [1: if the noun is a person begin]
        if ((noun ofclass K8_person))   {
         ! phrase 2
         ! [2: if the actor is the player , issue library message touching action number 1 for the noun]
           if ((actor == player)) {   GL__M(##Touch,1,noun);     }
         ! phrase 3
         ! [3: otherwise say ~[The actor] touches	[if the noun is the player]you[otherwise][the noun][end if].~]
           else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_65;   
.L_Say80; if (((noun == player))) say__c=true; else jump L_Say81;    print (I7_string) SC_63;  
.L_Say81; if (say__c==false) say__c=true; else jump L_Say82;    print (the) noun;   
.L_Say82; say__c = false;    print (I7_string) SC_11;   new_line; .L_Say83;   }
         ! phrase 4
         ! [4: stop the action]
           rtrue;  
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_195, true);
   rfalse;
];
! From the Standard Rules
! Report an actor touching ( this is the report touching things rule ):
[ R_196 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_196);
      ! phrase 1
      ! [1: if the actor is the player , issue library message touching action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Touch,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] touches [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_68;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say84;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_196, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B221_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_197 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_197);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message waving action number 1 for the noun]
        if (~~((actor ==   (I7_Holder(noun))  ))) {   return GL__M(##Wave,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_197, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B223_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor waving ( this is the report waving things rule ):
[ R_198 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_198);
      ! phrase 1
      ! [1: if the actor is the player , issue library message waving action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Wave,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] waves [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_69;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say85;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_198, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B224_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_199 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_199);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pulling action number 1 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Pull,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_199, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_200 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_200);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pulling action number 2 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Pull,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_200, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pulling ( this is the can't pull people rule ):
[ R_201 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_201);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pulling action number 4 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Pull,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_201, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B226_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor pulling ( this is the report pulling rule ):
[ R_202 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_202);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pulling action number 3 for the noun]
        if ((actor == player)) {   GL__M(##Pull,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] pulls [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_70;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say86;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_202, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B227_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_203 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_203);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pushing action number 1 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Push,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_203, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_204 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_204);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pushing action number 2 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Push,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_204, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pushing something ( this is the can't push people rule ):
[ R_205 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_205);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pushing action number 4 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Push,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_205, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B229_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor pushing something ( this is the report pushing rule ):
[ R_206 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_206);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pushing action number 3 for the noun]
        if ((actor == player)) {   GL__M(##Push,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] pushes [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_71;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say87;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_206, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B230_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_207 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_207);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message turning action number 1 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Turn,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_207, true);
   rfalse;
];
! From the Standard Rules
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_208 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_208);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message turning action number 2 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Turn,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_208, true);
   rfalse;
];
! From the Standard Rules
! Check an actor turning ( this is the can't turn people rule ):
[ R_209 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_209);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message turning action number 4 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Turn,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_209, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B232_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor turning ( this is the report turning rule ):
[ R_210 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_210);
      ! phrase 1
      ! [1: if the actor is the player , issue library message turning action number 3 for the noun]
        if ((actor == player)) {   GL__M(##Turn,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] turns [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_72;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say88;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_210, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B233_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_211 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_211);
      ! phrase 1
      ! [1: stop the action with library message pushing it to action number 1 for the noun]
        return GL__M(##PushDir,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_211, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B236_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_212 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_212);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message squeezing action number 1 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Squeeze,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_212, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B238_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_213 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_213);
      ! phrase 1
      ! [1: if the actor is the player , issue library message squeezing action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Squeeze,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] squeezes [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_73;    print (the) noun;    print (I7_string) SC_11;   new_line; .L_Say89;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_213, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying yes (B239_check_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying yes ( this is the block saying yes rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_214 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_214);
      ! phrase 1
      ! [1: stop the action with library message saying yes action number 1]
        return GL__M(##Yes,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_214, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying no (B242_check_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying no ( this is the block saying no rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor saying no ( this is the block saying no rule ):
[ R_215 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_215);
      ! phrase 1
      ! [1: stop the action with library message saying no action number 1]
        return GL__M(##No,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_215, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Burning (B245_check_burning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor burning ( this is the block burning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor burning ( this is the block burning rule ):
[ R_216 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_216);
      ! phrase 1
      ! [1: stop the action with library message burning action number 1]
        return GL__M(##Burn,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_216, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking up (B248_check_waking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking up ( this is the block waking up rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waking up ( this is the block waking up rule ):
[ R_217 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_217);
      ! phrase 1
      ! [1: stop the action with library message waking up action number 1]
        return GL__M(##Wake,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_217, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Thinking (B251_check_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor thinking ( this is the block thinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor thinking ( this is the block thinking rule ):
[ R_218 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_218);
      ! phrase 1
      ! [1: stop the action with library message thinking action number 1]
        return GL__M(##Think,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_218, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Smelling (B254_check_smelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor smelling ( this is the block smelling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor smelling ( this is the block smelling rule ):
[ R_219 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_219);
      ! phrase 1
      ! [1: stop the action with library message smelling action number 1 for the noun]
        return GL__M(##Smell,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_219, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Listening to (B257_check_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor listening ( this is the block listening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor listening ( this is the block listening rule ):
[ R_220 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_220);
      ! phrase 1
      ! [1: stop the action with library message listening to action number 1 for the noun]
        return GL__M(##Listen,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_220, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tasting (B260_check_tasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tasting ( this is the block tasting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor tasting ( this is the block tasting rule ):
[ R_221 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_221);
      ! phrase 1
      ! [1: stop the action with library message tasting action number 1 for the noun]
        return GL__M(##Taste,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_221, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B263_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor cutting ( this is the block cutting rule ):
[ R_222 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_222);
      ! phrase 1
      ! [1: stop the action with library message cutting action number 1 for the noun]
        return GL__M(##Cut,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_222, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Jumping (B266_check_jumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor jumping ( this is the block jumping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor jumping ( this is the block jumping rule ):
[ R_223 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_223);
      ! phrase 1
      ! [1: stop the action with library message jumping action number 1]
        return GL__M(##Jump,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_223, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tying it to (B269_check_tying_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tying ( this is the block tying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor tying ( this is the block tying rule ):
[ R_224 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_224);
      ! phrase 1
      ! [1: stop the action with library message tying it to action number 1 for the noun]
        return GL__M(##Tie,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_224, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Drinking (B272_check_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor drinking ( this is the block drinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor drinking ( this is the block drinking rule ):
[ R_225 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_225);
      ! phrase 1
      ! [1: stop the action with library message drinking action number 1 for the noun]
        return GL__M(##Drink,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_225, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying sorry (B275_check_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying sorry ( this is the block saying sorry rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_226 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_226);
      ! phrase 1
      ! [1: stop the action with library message saying sorry action number 1]
        return GL__M(##Sorry,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_226, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing obscenely (B278_check_swearing_obscenel)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
[ R_227 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_227);
      ! phrase 1
      ! [1: stop the action with library message swearing obscenely action number 1]
        return GL__M(##Strong,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_227, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing mildly (B281_check_swearing_mildly)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing mildly ( this is the block swearing mildly rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor swearing mildly ( this is the block swearing mildly rule ):
[ R_228 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_228);
      ! phrase 1
      ! [1: stop the action with library message swearing mildly action number 1]
        return GL__M(##Mild,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_228, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swinging (B284_check_swinging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swinging ( this is the block swinging rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor swinging ( this is the block swinging rule ):
[ R_229 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_229);
      ! phrase 1
      ! [1: stop the action with library message swinging action number 1 for the noun]
        return GL__M(##Swing,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_229, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B287_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor rubbing ( this is the block rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor rubbing ( this is the block rubbing rule ):
[ R_230 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_230);
      ! phrase 1
      ! [1: stop the action with library message rubbing action number 1 for the noun]
        return GL__M(##Rub,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_230, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Setting it to (B290_check_setting_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor setting something to ( this is the block setting it to rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor setting something to ( this is the block setting it to rule ):
[ R_231 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_231);
      ! phrase 1
      ! [1: stop the action with library message setting it to action number 1 for the noun]
        return GL__M(##SetTo,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_231, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving hands (B293_check_waving_hands)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving hands ( this is the block waving hands rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waving hands ( this is the block waving hands rule ):
[ R_232 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_232);
      ! phrase 1
      ! [1: stop the action with library message waving hands action number 1]
        return GL__M(##WaveHands,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_232, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B296_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor buying ( this is the block buying rule ):
[ R_233 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_233);
      ! phrase 1
      ! [1: stop the action with library message buying action number 1 for the noun]
        return GL__M(##Buy,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_233, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Singing (B299_check_singing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor singing ( this is the block singing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor singing ( this is the block singing rule ):
[ R_234 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_234);
      ! phrase 1
      ! [1: stop the action with library message singing action number 1]
        return GL__M(##Sing,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_234, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Climbing (B302_check_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor climbing ( this is the block climbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor climbing ( this is the block climbing rule ):
[ R_235 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_235);
      ! phrase 1
      ! [1: stop the action with library message climbing action number 1 for the noun]
        return GL__M(##Climb,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_235, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Sleeping (B305_check_sleeping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor sleeping ( this is the block sleeping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor sleeping ( this is the block sleeping rule ):
[ R_236 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_236);
      ! phrase 1
      ! [1: stop the action with library message sleeping action number 1]
        return GL__M(##Sleep,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_236, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! Definitions of miscellaneous remaining rules

! From the Standard Rules
! Definition:
[ R_0 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_1 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_2 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_3 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_4 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_5 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_6 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_7 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_8 
    t_0 ! Call parameter 'it' = OBJECT_TY
    ;
   rfalse;
];


Array I7TimerTable table 0 0;

Array I7TimerTableTimes table 0 0;


[ TurnEndPrimitive;
	actor = player; self = player; act_requester = 0;
	BeginActionProcessing();
	ProcessRulebook(TURNEND_RB);
	EndActionProcessing();
];

[ BeforeRoutines x; self = noun;
	ChronologyPoint();
	rfalse;
];

[ AfterRoutines; self = noun;
	if (ProcessRulebook(AFTER_RB)) rtrue;
	if (keep_silent == 1) rtrue;
	return ProcessRulebook(REPLY_RB);
];


Array EMPTY_RULEBOOK -> $ff $ff $ff $ff; ! 4 bytes needed in case of Glulx
Array rulebooks_array --> B0_action_processing B1_before B2_instead B3_after B4_procedural B5_accessibility B6_action_specific B7_carry_out B8_general_report B9_turn_sequence B10_reaching_inside B11_reaching_outside B12_general_before B13_actor_specific_before B14_location_specific_before B15_reaction_before B16_object_specific_before B17_general_after B18_actor_specific_after B19_location_specific_after B20_reaction_after B21_object_specific_after B22_when_play_begins B23_when_play_ends B24_every_turn B25_check B26_report B27_persuasion B28_unsuccessful_attempt_by B29_visibility B30_does_the_player_mean B31_setting_action_variables B32_scene_changing B33_when_entire_game_begins B34_when_entire_game_ends B35_before_printing_the_name B36_for_printing_the_name B37_after_printing_the_name B38_before_listing_contents B39_for_listing_contents B40_after_listing_contents B41_before_grouping_together B42_for_grouping_together B43_after_grouping_together B44_before_constructing_the_ B45_for_constructing_the_sta B46_after_constructing_the_s B47_before_listing_nondescri B48_for_listing_nondescript_ B49_after_listing_nondescrip B50_before_deciding_the_scop B51_for_deciding_the_scope B52_after_deciding_the_scope B53_before_supplying_a_missi B54_for_supplying_a_missing_ B55_after_supplying_a_missin B56_before_supplying_a_missi B57_for_supplying_a_missing_ B58_after_supplying_a_missin B59_before_reading_a_command B60_for_reading_a_command B61_after_reading_a_command B62_before_deciding_whether_ B63_for_deciding_whether_all B64_after_deciding_whether_a B65_before_printing_the_play B66_for_printing_the_player_ B67_after_printing_the_playe B68_before_amusing_a_victori B69_for_amusing_a_victorious B70_after_amusing_a_victorio B71_before_printing_the_bann B72_for_printing_the_banner_ B73_after_printing_the_banne B74_before_printing_the_plur B75_for_printing_the_plural_ B76_after_printing_the_plura B77_before_deciding_the_conc B78_for_deciding_the_conceal B79_after_deciding_the_conce B80_before_printing_a_refusa B81_for_printing_a_refusal_t B82_after_printing_a_refusal B83_before_printing_the_anno B84_for_printing_the_announc B85_after_printing_the_annou B86_before_printing_the_name B87_for_printing_the_name_of B88_after_printing_the_name_ B89_before_printing_the_desc B90_for_printing_the_descrip B91_after_printing_the_descr B92_before_printing_room_des B93_for_printing_room_descri B94_after_printing_room_desc B95_before_printing_a_parser B96_for_printing_a_parser_er B97_after_printing_a_parser_ B98_before_implicitly_taking B99_for_implicitly_taking B100_after_implicitly_taking B101_before_starting_the_vir B102_for_starting_the_virtua B103_after_starting_the_virt B104_before_clarifying_the_p B105_for_clarifying_the_pars B106_after_clarifying_the_pa B107_before_asking_which_do_ B108_for_asking_which_do_you B109_after_asking_which_do_y B110_before_writing_a_paragr B111_for_writing_a_paragraph B112_after_writing_a_paragra B113_check_taking_inventory B114_carry_out_taking_invent B115_report_taking_inventory B116_check_taking B117_carry_out_taking B118_report_taking B119_check_removing_it_from B120_carry_out_removing_it_f B121_report_removing_it_from B122_check_dropping B123_carry_out_dropping B124_report_dropping B125_check_putting_it_on B126_carry_out_putting_it_on B127_report_putting_it_on B128_check_inserting_it_into B129_carry_out_inserting_it_ B130_report_inserting_it_int B131_check_eating B132_carry_out_eating B133_report_eating B134_check_going B135_carry_out_going B136_report_going B137_check_entering B138_carry_out_entering B139_report_entering B140_check_exiting B141_carry_out_exiting B142_report_exiting B143_check_getting_off B144_carry_out_getting_off B145_report_getting_off B146_check_looking B147_carry_out_looking B148_report_looking B149_check_examining B150_carry_out_examining B151_report_examining B152_check_looking_under B153_carry_out_looking_under B154_report_looking_under B155_check_searching B156_carry_out_searching B157_report_searching B158_check_consulting_it_abo B159_carry_out_consulting_it B160_report_consulting_it_ab B161_check_locking_it_with B162_carry_out_locking_it_wi B163_report_locking_it_with B164_check_unlocking_it_with B165_carry_out_unlocking_it_ B166_report_unlocking_it_wit B167_check_switching_on B168_carry_out_switching_on B169_report_switching_on B170_check_switching_off B171_carry_out_switching_off B172_report_switching_off B173_check_opening B174_carry_out_opening B175_report_opening B176_check_closing B177_carry_out_closing B178_report_closing B179_check_wearing B180_carry_out_wearing B181_report_wearing B182_check_taking_off B183_carry_out_taking_off B184_report_taking_off B185_check_giving_it_to B186_carry_out_giving_it_to B187_report_giving_it_to B188_check_showing_it_to B189_carry_out_showing_it_to B190_report_showing_it_to B191_check_waking B192_carry_out_waking B193_report_waking B194_check_throwing_it_at B195_carry_out_throwing_it_a B196_report_throwing_it_at B197_check_attacking B198_carry_out_attacking B199_report_attacking B200_check_kissing B201_carry_out_kissing B202_report_kissing B203_check_answering_it_that B204_carry_out_answering_it_ B205_report_answering_it_tha B206_check_telling_it_about B207_carry_out_telling_it_ab B208_report_telling_it_about B209_check_asking_it_about B210_carry_out_asking_it_abo B211_report_asking_it_about B212_check_asking_it_for B213_carry_out_asking_it_for B214_report_asking_it_for B215_check_waiting B216_carry_out_waiting B217_report_waiting B218_check_touching B219_carry_out_touching B220_report_touching B221_check_waving B222_carry_out_waving B223_report_waving B224_check_pulling B225_carry_out_pulling B226_report_pulling B227_check_pushing B228_carry_out_pushing B229_report_pushing B230_check_turning B231_carry_out_turning B232_report_turning B233_check_pushing_it_to B234_carry_out_pushing_it_to B235_report_pushing_it_to B236_check_squeezing B237_carry_out_squeezing B238_report_squeezing B239_check_saying_yes B240_carry_out_saying_yes B241_report_saying_yes B242_check_saying_no B243_carry_out_saying_no B244_report_saying_no B245_check_burning B246_carry_out_burning B247_report_burning B248_check_waking_up B249_carry_out_waking_up B250_report_waking_up B251_check_thinking B252_carry_out_thinking B253_report_thinking B254_check_smelling B255_carry_out_smelling B256_report_smelling B257_check_listening_to B258_carry_out_listening_to B259_report_listening_to B260_check_tasting B261_carry_out_tasting B262_report_tasting B263_check_cutting B264_carry_out_cutting B265_report_cutting B266_check_jumping B267_carry_out_jumping B268_report_jumping B269_check_tying_it_to B270_carry_out_tying_it_to B271_report_tying_it_to B272_check_drinking B273_carry_out_drinking B274_report_drinking B275_check_saying_sorry B276_carry_out_saying_sorry B277_report_saying_sorry B278_check_swearing_obscenel B279_carry_out_swearing_obsc B280_report_swearing_obscene B281_check_swearing_mildly B282_carry_out_swearing_mild B283_report_swearing_mildly B284_check_swinging B285_carry_out_swinging B286_report_swinging B287_check_rubbing B288_carry_out_rubbing B289_report_rubbing B290_check_setting_it_to B291_carry_out_setting_it_to B292_report_setting_it_to B293_check_waving_hands B294_carry_out_waving_hands B295_report_waving_hands B296_check_buying B297_carry_out_buying B298_report_buying B299_check_singing B300_carry_out_singing B301_report_singing B302_check_climbing B303_carry_out_climbing B304_report_climbing B305_check_sleeping B306_carry_out_sleeping B307_report_sleeping B308_check_requesting_the_sc B309_carry_out_requesting_th B310_report_requesting_the_s B311_check_quitting_the_game B312_carry_out_quitting_the_ B313_report_quitting_the_gam B314_check_saving_the_game B315_carry_out_saving_the_ga B316_report_saving_the_game B317_check_restoring_the_gam B318_carry_out_restoring_the B319_report_restoring_the_ga B320_check_restarting_the_ga B321_carry_out_restarting_th B322_report_restarting_the_g B323_check_verifying_the_sto B324_carry_out_verifying_the B325_report_verifying_the_st B326_check_requesting_the_st B327_carry_out_requesting_th B328_report_requesting_the_s B329_check_switching_the_sto B330_carry_out_switching_the B331_report_switching_the_st B332_check_switching_the_sto B333_carry_out_switching_the B334_report_switching_the_st B335_check_preferring_abbrev B336_carry_out_preferring_ab B337_report_preferring_abbre B338_check_preferring_unabbr B339_carry_out_preferring_un B340_report_preferring_unabb B341_check_preferring_someti B342_carry_out_preferring_so B343_report_preferring_somet B344_check_requesting_the_pr B345_carry_out_requesting_th B346_report_requesting_the_p B347_check_switching_score_n B348_carry_out_switching_sco B349_report_switching_score_ B350_check_switching_score_n B351_carry_out_switching_sco B352_report_switching_score_ 0;

Array B0_action_processing -->  R_17 PA_R CR_R R_18 R_19 R_20 R_21 I6_NULL;
Array B1_before -->  R_15 I6_NULL;
Constant B2_instead = EMPTY_RULEBOOK;
Array B3_after -->  R_16 R_649 I6_NULL;
Constant B4_procedural = EMPTY_RULEBOOK;
Array B5_accessibility -->  OIU_Barrier OIU_Scoped I6_NULL;
Array B6_action_specific -->  R_22 I6_NULL;
Constant B7_carry_out = EMPTY_RULEBOOK;
Constant B8_general_report = EMPTY_RULEBOOK;
Array B9_turn_sequence -->  R_11 R_10 I7ResetChooseObjects ProcessI7Timers TS1_R TS4_R R_12 TS5_R TS6_R I6_NULL;
Array B10_reaching_inside -->  OIUB_RI OIUB_CCI I6_NULL;
Array B11_reaching_outside -->  OIUB_CCO I6_NULL;
Constant B12_general_before = EMPTY_RULEBOOK;
Constant B13_actor_specific_before = EMPTY_RULEBOOK;
Constant B14_location_specific_before = EMPTY_RULEBOOK;
Constant B15_reaction_before = EMPTY_RULEBOOK;
Constant B16_object_specific_before = EMPTY_RULEBOOK;
Constant B17_general_after = EMPTY_RULEBOOK;
Constant B18_actor_specific_after = EMPTY_RULEBOOK;
Constant B19_location_specific_after = EMPTY_RULEBOOK;
Constant B20_reaction_after = EMPTY_RULEBOOK;
Constant B21_object_specific_after = EMPTY_RULEBOOK;
Array B22_when_play_begins -->  R_9 I6_NULL;
Constant B23_when_play_ends = EMPTY_RULEBOOK;
Constant B24_every_turn = EMPTY_RULEBOOK;
Constant B25_check = EMPTY_RULEBOOK;
Constant B26_report = EMPTY_RULEBOOK;
Constant B27_persuasion = EMPTY_RULEBOOK;
Constant B28_unsuccessful_attempt_by = EMPTY_RULEBOOK;
Array B29_visibility -->  CSITDR I6_NULL;
Array B30_does_the_player_mean -->  R_14 I6_NULL;
Array B31_setting_action_variables -->  R_30 R_81 R_113 R_101 I6_NULL;
Array B32_scene_changing -->  R_13 I6_NULL;
Constant B33_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B34_when_entire_game_ends = EMPTY_RULEBOOK;
Array B35_before_printing_the_name -->  R_25 I6_NULL;
Array B36_for_printing_the_name -->  R_23 I6_NULL;
Constant B37_after_printing_the_name = EMPTY_RULEBOOK;
Constant B38_before_listing_contents = EMPTY_RULEBOOK;
Array B39_for_listing_contents -->  R_24 I6_NULL;
Constant B40_after_listing_contents = EMPTY_RULEBOOK;
Constant B41_before_grouping_together = EMPTY_RULEBOOK;
Constant B42_for_grouping_together = EMPTY_RULEBOOK;
Constant B43_after_grouping_together = EMPTY_RULEBOOK;
Constant B44_before_constructing_the_ = EMPTY_RULEBOOK;
Constant B45_for_constructing_the_sta = EMPTY_RULEBOOK;
Constant B46_after_constructing_the_s = EMPTY_RULEBOOK;
Constant B47_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B48_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B49_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B50_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B51_for_deciding_the_scope = EMPTY_RULEBOOK;
Constant B52_after_deciding_the_scope = EMPTY_RULEBOOK;
Constant B53_before_supplying_a_missi = EMPTY_RULEBOOK;
Array B54_for_supplying_a_missing_ -->  R_237 R_238 R_239 I6_NULL;
Constant B55_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B56_before_supplying_a_missi = EMPTY_RULEBOOK;
Constant B57_for_supplying_a_missing_ = EMPTY_RULEBOOK;
Constant B58_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B59_before_reading_a_command = EMPTY_RULEBOOK;
Constant B60_for_reading_a_command = EMPTY_RULEBOOK;
Constant B61_after_reading_a_command = EMPTY_RULEBOOK;
Constant B62_before_deciding_whether_ = EMPTY_RULEBOOK;
Constant B63_for_deciding_whether_all = EMPTY_RULEBOOK;
Constant B64_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B65_before_printing_the_play = EMPTY_RULEBOOK;
Array B66_for_printing_the_player_ -->  OBIT_HEAD OBIT_FINAL OBIT_DISP I6_NULL;
Constant B67_after_printing_the_playe = EMPTY_RULEBOOK;
Constant B68_before_amusing_a_victori = EMPTY_RULEBOOK;
Constant B69_for_amusing_a_victorious = EMPTY_RULEBOOK;
Constant B70_after_amusing_a_victorio = EMPTY_RULEBOOK;
Constant B71_before_printing_the_bann = EMPTY_RULEBOOK;
Constant B72_for_printing_the_banner_ = EMPTY_RULEBOOK;
Constant B73_after_printing_the_banne = EMPTY_RULEBOOK;
Constant B74_before_printing_the_plur = EMPTY_RULEBOOK;
Constant B75_for_printing_the_plural_ = EMPTY_RULEBOOK;
Constant B76_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B77_before_deciding_the_conc = EMPTY_RULEBOOK;
Constant B78_for_deciding_the_conceal = EMPTY_RULEBOOK;
Constant B79_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B80_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B81_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B82_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B83_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B84_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B85_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B86_before_printing_the_name = EMPTY_RULEBOOK;
Constant B87_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B88_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B89_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B90_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B91_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B92_before_printing_room_des = EMPTY_RULEBOOK;
Constant B93_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B94_after_printing_room_desc = EMPTY_RULEBOOK;
Constant B95_before_printing_a_parser = EMPTY_RULEBOOK;
Constant B96_for_printing_a_parser_er = EMPTY_RULEBOOK;
Constant B97_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B98_before_implicitly_taking = EMPTY_RULEBOOK;
Constant B99_for_implicitly_taking = EMPTY_RULEBOOK;
Constant B100_after_implicitly_taking = EMPTY_RULEBOOK;
Constant B101_before_starting_the_vir = EMPTY_RULEBOOK;
Constant B102_for_starting_the_virtua = EMPTY_RULEBOOK;
Constant B103_after_starting_the_virt = EMPTY_RULEBOOK;
Constant B104_before_clarifying_the_p = EMPTY_RULEBOOK;
Constant B105_for_clarifying_the_pars = EMPTY_RULEBOOK;
Constant B106_after_clarifying_the_pa = EMPTY_RULEBOOK;
Constant B107_before_asking_which_do_ = EMPTY_RULEBOOK;
Constant B108_for_asking_which_do_you = EMPTY_RULEBOOK;
Constant B109_after_asking_which_do_y = EMPTY_RULEBOOK;
Constant B110_before_writing_a_paragr = EMPTY_RULEBOOK;
Constant B111_for_writing_a_paragraph = EMPTY_RULEBOOK;
Constant B112_after_writing_a_paragra = EMPTY_RULEBOOK;
Constant B113_check_taking_inventory = EMPTY_RULEBOOK;
Array B114_carry_out_taking_invent -->  R_26 R_27 R_28 I6_NULL;
Array B115_report_taking_inventory -->  R_29 I6_NULL;
Array B116_check_taking -->  R_31 R_32 R_33 R_34 R_35 R_36 R_37 R_38 R_39 R_40 R_41 R_42 R_43 I6_NULL;
Array B117_carry_out_taking -->  R_44 I6_NULL;
Array B118_report_taking -->  R_45 R_46 I6_NULL;
Array B119_check_removing_it_from -->  R_34 R_47 R_48 R_49 I6_NULL;
Constant B120_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B121_report_removing_it_from = EMPTY_RULEBOOK;
Array B122_check_dropping -->  R_50 R_51 R_52 R_53 R_54 I6_NULL;
Array B123_carry_out_dropping -->  R_55 I6_NULL;
Array B124_report_dropping -->  R_56 I6_NULL;
Array B125_check_putting_it_on -->  R_57 R_58 R_59 R_60 R_61 R_62 R_63 I6_NULL;
Array B126_carry_out_putting_it_on -->  R_64 I6_NULL;
Array B127_report_putting_it_on -->  R_65 R_66 I6_NULL;
Array B128_check_inserting_it_into -->  R_67 R_68 R_69 R_70 R_71 R_72 R_73 I6_NULL;
Array B129_carry_out_inserting_it_ -->  R_74 I6_NULL;
Array B130_report_inserting_it_int -->  R_75 R_76 I6_NULL;
Array B131_check_eating -->  R_77 R_78 I6_NULL;
Array B132_carry_out_eating -->  R_79 I6_NULL;
Array B133_report_eating -->  R_80 I6_NULL;
Array B134_check_going -->  R_82 R_83 R_84 R_85 R_86 I6_NULL;
Array B135_carry_out_going -->  R_87 R_88 R_89 I6_NULL;
Array B136_report_going -->  R_90 I6_NULL;
Array B137_check_entering -->  R_91 R_92 R_93 R_94 R_95 R_96 R_97 I6_NULL;
Array B138_carry_out_entering -->  R_98 I6_NULL;
Array B139_report_entering -->  R_99 R_100 I6_NULL;
Array B140_check_exiting -->  R_102 R_103 R_104 R_105 I6_NULL;
Array B141_carry_out_exiting -->  R_106 I6_NULL;
Array B142_report_exiting -->  R_107 R_108 I6_NULL;
Array B143_check_getting_off -->  R_109 I6_NULL;
Array B144_carry_out_getting_off -->  R_110 I6_NULL;
Array B145_report_getting_off -->  R_111 R_112 I6_NULL;
Constant B146_check_looking = EMPTY_RULEBOOK;
Array B147_carry_out_looking -->  R_114 R_115 R_116 R_117 I6_NULL;
Array B148_report_looking -->  R_118 I6_NULL;
Constant B149_check_examining = EMPTY_RULEBOOK;
Array B150_carry_out_examining -->  R_119 R_120 R_121 R_122 R_123 R_124 I6_NULL;
Array B151_report_examining -->  R_125 I6_NULL;
Constant B152_check_looking_under = EMPTY_RULEBOOK;
Array B153_carry_out_looking_under -->  R_126 I6_NULL;
Array B154_report_looking_under -->  R_127 I6_NULL;
Array B155_check_searching -->  R_128 R_129 I6_NULL;
Constant B156_carry_out_searching = EMPTY_RULEBOOK;
Array B157_report_searching -->  R_130 R_131 R_132 I6_NULL;
Constant B158_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B159_carry_out_consulting_it = EMPTY_RULEBOOK;
Array B160_report_consulting_it_ab -->  R_133 I6_NULL;
Array B161_check_locking_it_with -->  R_134 R_135 R_136 R_137 I6_NULL;
Array B162_carry_out_locking_it_wi -->  R_138 I6_NULL;
Array B163_report_locking_it_with -->  R_139 I6_NULL;
Array B164_check_unlocking_it_with -->  R_140 R_141 R_142 I6_NULL;
Array B165_carry_out_unlocking_it_ -->  R_143 I6_NULL;
Array B166_report_unlocking_it_wit -->  R_144 I6_NULL;
Array B167_check_switching_on -->  R_145 R_146 I6_NULL;
Array B168_carry_out_switching_on -->  R_147 I6_NULL;
Array B169_report_switching_on -->  R_148 I6_NULL;
Array B170_check_switching_off -->  R_149 R_150 I6_NULL;
Array B171_carry_out_switching_off -->  R_151 I6_NULL;
Array B172_report_switching_off -->  R_152 I6_NULL;
Array B173_check_opening -->  R_153 R_154 R_155 I6_NULL;
Array B174_carry_out_opening -->  R_156 I6_NULL;
Array B175_report_opening -->  R_157 R_158 I6_NULL;
Array B176_check_closing -->  R_159 R_160 I6_NULL;
Array B177_carry_out_closing -->  R_161 I6_NULL;
Array B178_report_closing -->  R_162 I6_NULL;
Array B179_check_wearing -->  R_163 R_164 R_165 I6_NULL;
Array B180_carry_out_wearing -->  R_166 I6_NULL;
Array B181_report_wearing -->  R_167 I6_NULL;
Array B182_check_taking_off -->  R_168 I6_NULL;
Array B183_carry_out_taking_off -->  R_169 I6_NULL;
Array B184_report_taking_off -->  R_170 I6_NULL;
Array B185_check_giving_it_to -->  R_171 R_172 R_173 R_174 I6_NULL;
Array B186_carry_out_giving_it_to -->  R_175 I6_NULL;
Array B187_report_giving_it_to -->  R_176 I6_NULL;
Array B188_check_showing_it_to -->  R_177 R_178 R_179 I6_NULL;
Constant B189_carry_out_showing_it_to = EMPTY_RULEBOOK;
Constant B190_report_showing_it_to = EMPTY_RULEBOOK;
Array B191_check_waking -->  R_180 I6_NULL;
Constant B192_carry_out_waking = EMPTY_RULEBOOK;
Constant B193_report_waking = EMPTY_RULEBOOK;
Array B194_check_throwing_it_at -->  R_181 R_182 R_183 I6_NULL;
Constant B195_carry_out_throwing_it_a = EMPTY_RULEBOOK;
Constant B196_report_throwing_it_at = EMPTY_RULEBOOK;
Array B197_check_attacking -->  R_184 I6_NULL;
Constant B198_carry_out_attacking = EMPTY_RULEBOOK;
Constant B199_report_attacking = EMPTY_RULEBOOK;
Array B200_check_kissing -->  R_185 R_186 I6_NULL;
Constant B201_carry_out_kissing = EMPTY_RULEBOOK;
Constant B202_report_kissing = EMPTY_RULEBOOK;
Constant B203_check_answering_it_that = EMPTY_RULEBOOK;
Constant B204_carry_out_answering_it_ = EMPTY_RULEBOOK;
Array B205_report_answering_it_tha -->  R_187 I6_NULL;
Array B206_check_telling_it_about -->  R_188 I6_NULL;
Constant B207_carry_out_telling_it_ab = EMPTY_RULEBOOK;
Array B208_report_telling_it_about -->  R_189 I6_NULL;
Constant B209_check_asking_it_about = EMPTY_RULEBOOK;
Constant B210_carry_out_asking_it_abo = EMPTY_RULEBOOK;
Array B211_report_asking_it_about -->  R_190 I6_NULL;
Array B212_check_asking_it_for -->  R_191 R_192 I6_NULL;
Constant B213_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B214_report_asking_it_for = EMPTY_RULEBOOK;
Constant B215_check_waiting = EMPTY_RULEBOOK;
Constant B216_carry_out_waiting = EMPTY_RULEBOOK;
Array B217_report_waiting -->  R_193 I6_NULL;
Constant B218_check_touching = EMPTY_RULEBOOK;
Constant B219_carry_out_touching = EMPTY_RULEBOOK;
Array B220_report_touching -->  R_194 R_195 R_196 I6_NULL;
Array B221_check_waving -->  R_197 I6_NULL;
Constant B222_carry_out_waving = EMPTY_RULEBOOK;
Array B223_report_waving -->  R_198 I6_NULL;
Array B224_check_pulling -->  R_199 R_200 R_201 I6_NULL;
Constant B225_carry_out_pulling = EMPTY_RULEBOOK;
Array B226_report_pulling -->  R_202 I6_NULL;
Array B227_check_pushing -->  R_203 R_204 R_205 I6_NULL;
Constant B228_carry_out_pushing = EMPTY_RULEBOOK;
Array B229_report_pushing -->  R_206 I6_NULL;
Array B230_check_turning -->  R_207 R_208 R_209 I6_NULL;
Constant B231_carry_out_turning = EMPTY_RULEBOOK;
Array B232_report_turning -->  R_210 I6_NULL;
Array B233_check_pushing_it_to -->  R_211 I6_NULL;
Constant B234_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B235_report_pushing_it_to = EMPTY_RULEBOOK;
Array B236_check_squeezing -->  R_212 I6_NULL;
Constant B237_carry_out_squeezing = EMPTY_RULEBOOK;
Array B238_report_squeezing -->  R_213 I6_NULL;
Array B239_check_saying_yes -->  R_214 I6_NULL;
Constant B240_carry_out_saying_yes = EMPTY_RULEBOOK;
Constant B241_report_saying_yes = EMPTY_RULEBOOK;
Array B242_check_saying_no -->  R_215 I6_NULL;
Constant B243_carry_out_saying_no = EMPTY_RULEBOOK;
Constant B244_report_saying_no = EMPTY_RULEBOOK;
Array B245_check_burning -->  R_216 I6_NULL;
Constant B246_carry_out_burning = EMPTY_RULEBOOK;
Constant B247_report_burning = EMPTY_RULEBOOK;
Array B248_check_waking_up -->  R_217 I6_NULL;
Constant B249_carry_out_waking_up = EMPTY_RULEBOOK;
Constant B250_report_waking_up = EMPTY_RULEBOOK;
Array B251_check_thinking -->  R_218 I6_NULL;
Constant B252_carry_out_thinking = EMPTY_RULEBOOK;
Constant B253_report_thinking = EMPTY_RULEBOOK;
Array B254_check_smelling -->  R_219 I6_NULL;
Constant B255_carry_out_smelling = EMPTY_RULEBOOK;
Constant B256_report_smelling = EMPTY_RULEBOOK;
Array B257_check_listening_to -->  R_220 I6_NULL;
Constant B258_carry_out_listening_to = EMPTY_RULEBOOK;
Constant B259_report_listening_to = EMPTY_RULEBOOK;
Array B260_check_tasting -->  R_221 I6_NULL;
Constant B261_carry_out_tasting = EMPTY_RULEBOOK;
Constant B262_report_tasting = EMPTY_RULEBOOK;
Array B263_check_cutting -->  R_222 I6_NULL;
Constant B264_carry_out_cutting = EMPTY_RULEBOOK;
Constant B265_report_cutting = EMPTY_RULEBOOK;
Array B266_check_jumping -->  R_223 I6_NULL;
Constant B267_carry_out_jumping = EMPTY_RULEBOOK;
Constant B268_report_jumping = EMPTY_RULEBOOK;
Array B269_check_tying_it_to -->  R_224 I6_NULL;
Constant B270_carry_out_tying_it_to = EMPTY_RULEBOOK;
Constant B271_report_tying_it_to = EMPTY_RULEBOOK;
Array B272_check_drinking -->  R_225 I6_NULL;
Constant B273_carry_out_drinking = EMPTY_RULEBOOK;
Constant B274_report_drinking = EMPTY_RULEBOOK;
Array B275_check_saying_sorry -->  R_226 I6_NULL;
Constant B276_carry_out_saying_sorry = EMPTY_RULEBOOK;
Constant B277_report_saying_sorry = EMPTY_RULEBOOK;
Array B278_check_swearing_obscenel -->  R_227 I6_NULL;
Constant B279_carry_out_swearing_obsc = EMPTY_RULEBOOK;
Constant B280_report_swearing_obscene = EMPTY_RULEBOOK;
Array B281_check_swearing_mildly -->  R_228 I6_NULL;
Constant B282_carry_out_swearing_mild = EMPTY_RULEBOOK;
Constant B283_report_swearing_mildly = EMPTY_RULEBOOK;
Array B284_check_swinging -->  R_229 I6_NULL;
Constant B285_carry_out_swinging = EMPTY_RULEBOOK;
Constant B286_report_swinging = EMPTY_RULEBOOK;
Array B287_check_rubbing -->  R_230 I6_NULL;
Constant B288_carry_out_rubbing = EMPTY_RULEBOOK;
Constant B289_report_rubbing = EMPTY_RULEBOOK;
Array B290_check_setting_it_to -->  R_231 I6_NULL;
Constant B291_carry_out_setting_it_to = EMPTY_RULEBOOK;
Constant B292_report_setting_it_to = EMPTY_RULEBOOK;
Array B293_check_waving_hands -->  R_232 I6_NULL;
Constant B294_carry_out_waving_hands = EMPTY_RULEBOOK;
Constant B295_report_waving_hands = EMPTY_RULEBOOK;
Array B296_check_buying -->  R_233 I6_NULL;
Constant B297_carry_out_buying = EMPTY_RULEBOOK;
Constant B298_report_buying = EMPTY_RULEBOOK;
Array B299_check_singing -->  R_234 I6_NULL;
Constant B300_carry_out_singing = EMPTY_RULEBOOK;
Constant B301_report_singing = EMPTY_RULEBOOK;
Array B302_check_climbing -->  R_235 I6_NULL;
Constant B303_carry_out_climbing = EMPTY_RULEBOOK;
Constant B304_report_climbing = EMPTY_RULEBOOK;
Array B305_check_sleeping -->  R_236 I6_NULL;
Constant B306_carry_out_sleeping = EMPTY_RULEBOOK;
Constant B307_report_sleeping = EMPTY_RULEBOOK;
Constant B308_check_requesting_the_sc = EMPTY_RULEBOOK;
Array B309_carry_out_requesting_th -->  ScoreSub_O1 I6_NULL;
Constant B310_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B311_check_quitting_the_game = EMPTY_RULEBOOK;
Array B312_carry_out_quitting_the_ -->  QuitSub_O1 I6_NULL;
Constant B313_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B314_check_saving_the_game = EMPTY_RULEBOOK;
Array B315_carry_out_saving_the_ga -->  SaveSub_O1 I6_NULL;
Constant B316_report_saving_the_game = EMPTY_RULEBOOK;
Constant B317_check_restoring_the_gam = EMPTY_RULEBOOK;
Array B318_carry_out_restoring_the -->  RestoreSub_O1 I6_NULL;
Constant B319_report_restoring_the_ga = EMPTY_RULEBOOK;
Constant B320_check_restarting_the_ga = EMPTY_RULEBOOK;
Array B321_carry_out_restarting_th -->  RestartSub_O1 I6_NULL;
Constant B322_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B323_check_verifying_the_sto = EMPTY_RULEBOOK;
Array B324_carry_out_verifying_the -->  VerifySub_O1 I6_NULL;
Constant B325_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B326_check_requesting_the_st = EMPTY_RULEBOOK;
Array B327_carry_out_requesting_th -->  VersionSub_O1 I6_NULL;
Constant B328_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B329_check_switching_the_sto = EMPTY_RULEBOOK;
Array B330_carry_out_switching_the -->  ScriptOnSub_O1 I6_NULL;
Constant B331_report_switching_the_st = EMPTY_RULEBOOK;
Constant B332_check_switching_the_sto = EMPTY_RULEBOOK;
Array B333_carry_out_switching_the -->  ScriptOffSub_O1 I6_NULL;
Constant B334_report_switching_the_st = EMPTY_RULEBOOK;
Constant B335_check_preferring_abbrev = EMPTY_RULEBOOK;
Array B336_carry_out_preferring_ab -->  LMode3Sub_O1 I6_NULL;
Constant B337_report_preferring_abbre = EMPTY_RULEBOOK;
Constant B338_check_preferring_unabbr = EMPTY_RULEBOOK;
Array B339_carry_out_preferring_un -->  LMode2Sub_O1 I6_NULL;
Constant B340_report_preferring_unabb = EMPTY_RULEBOOK;
Constant B341_check_preferring_someti = EMPTY_RULEBOOK;
Array B342_carry_out_preferring_so -->  LMode1Sub_O1 I6_NULL;
Constant B343_report_preferring_somet = EMPTY_RULEBOOK;
Constant B344_check_requesting_the_pr = EMPTY_RULEBOOK;
Array B345_carry_out_requesting_th -->  PronounsSub_O1 I6_NULL;
Constant B346_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B347_check_switching_score_n = EMPTY_RULEBOOK;
Array B348_carry_out_switching_sco -->  NotifyOnSub_O1 I6_NULL;
Constant B349_report_switching_score_ = EMPTY_RULEBOOK;
Constant B350_check_switching_score_n = EMPTY_RULEBOOK;
Array B351_carry_out_switching_sco -->  NotifyOffSub_O1 I6_NULL;
Constant B352_report_switching_score_ = EMPTY_RULEBOOK;

! MStack.i6 segment
! Providing a second in-memory stack for temporary variables attached to
! rulebooks, activities, actions and the like

Constant MAX_MSTACK_FRAME = 2 + 5;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0;

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2, 1);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		print "Variable stack exhausted^";
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	! Mstack_Backtrace();
	rtrue;
];

Global MStack_Frame_Extent = 0;

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];

[ Mstack_Destroy_Frame creator id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	if (creator) creator.call(pos, -1);
	rtrue;
];

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable: ", id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! because word 0 is 0 == nothing in I6 terms
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

! Blocks can be attached to rulebooks (id = allocation id) or to activities
! (id = 10000 + allocation id) or to actions (20000 + allocation id)

Array rulebook_var_creators --> RBSTVC_0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
[  RBSTVC_0 pos state;
  if (state == 1) {
    MStack-->pos = selfobj; pos++;
  } else {
    pos++;
  }
  return 1;
];

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;


[ MStack_CreateRBVars rb cr;
	cr = rulebook_var_creators-->rb;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
	cr = rulebook_var_creators-->rb;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, rb);
];

[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, av + 10000);
];

! End of MStack.i6 segment


! RTP.i6 segment
! Reporting of run-time problems in a format which can be parsed by the
! Inform application

Global I7_enable_rte = true;

Constant RTP_BACKDROP 1;
Constant RTP_EXITDOOR 2;
Constant RTP_NOEXIT 3;
Constant RTP_CANTCHANGE 4;
Constant RTP_IMPREL 5;
Constant RTP_RULESTACK 6;
Constant RTP_TOOMANYRULEBOOKS 7;
Constant RTP_TOOMANYEVENTS 8;
Constant RTP_BADPROPERTY 9;
Constant RTP_UNPROVIDED 10;
Constant RTP_UNSET 11;
Constant RTP_TOOMANYACTS 12;
Constant RTP_CANTABANDON 13;
Constant RTP_CANTEND 14;
Constant RTP_CANTMOVENOTHING 15;
Constant RTP_CANTREMOVENOTHING 16;
Constant RTP_DIVZERO 17;
Constant RTP_BADVALUEPROPERTY 18;
Constant RTP_NOTBACKDROP 19;
Constant RTP_TABLE_NOCOL 20;
Constant RTP_TABLE_NOCORR 21;
Constant RTP_TABLE_NOROW 22;
Constant RTP_TABLE_NOENTRY 23;
Constant RTP_TABLE_NOTABLE 24;
Constant RTP_TABLE_NOMOREBLANKS 25;
Constant RTP_TABLE_NOROWS 26;
Constant RTP_TABLE_CANTSORT 27;
Constant RTP_NOTINAROOM 28;
Constant RTP_BADTOPIC 29;
Constant RTP_ROUTELESS 30;
Constant RTP_PROPOFNOTHING 31;
Constant RTP_DECIDEONWRONGKIND 32;
Constant RTP_DECIDEONNOTHING 33;
Constant RTP_TABLE_CANTSAVE 34;
Constant RTP_TABLE_WONTFIT 35;
Constant RTP_TABLE_BADFILE 36;

[ RunTimeProblem n obj obj2 ln obj3 i c;
	! if (I7_enable_rte == false) return;
	I7_enable_rte = false;
	print "^*** Run-time problem P", n;
	! if (ln == 0) ln=1;
	if (ln) print " (at paragraph ", ln, " in the source text)";
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) obj, " (a backdrop) to ", (the) obj2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) obj,
				", which is not a player-character.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) obj2, " exit of ", (the) obj,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) obj2, " exit of ", (the) obj,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) obj,
				", violating '";
			for (i=0: RelationList-->i ~= I6_NULL: i=i+3) {
				c = RelationList-->(i+1);
				if (((c == Relation_VtoV) || (c == Relation_Sym_VtoV))
					&& (obj2 == RelationList-->i)) {
					print (string) RelationList-->(i+2), "'.^";
				}
			}
		RTP_RULESTACK:
			print "Too many procedural rules acting all at once.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) obj, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) obj, " is not allowed the property ~",
					(string) obj2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) obj, " is allowed to have the property ~",
				(string) obj2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", obj, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) obj, " (not a backdrop) to ", (the) obj2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", obj2,
				", row ", obj3, " of the table '", (PrintTableName) obj, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				obj, ").^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_CANTSAVE:
			print "Attempt to save a table to a file whose data is unstable: table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_WONTFIT:
			print "File being read has too many rows or columns to fit into table: table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_BADFILE:
			print "File being read is not a previously saved table: table '",
				(PrintTableName) obj, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) obj, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object.^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		}
	print "^";
];

! Protected Z-machine division routines:

[ I7_Divide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];

[ I7_Rem A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];

! Checked return values:

[ I7_VerifyK V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];

! Protected Z-machine property and attribute access:

[ I7_Provides o either_or p;
	return HypotheticalProperty(either_or, o, p);
];

[ I7GetEitherOr o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (p<I7_FBNA) {
		if (o has p) rtrue;
		rfalse;
	}
	if ((o provides p) && (o.p)) rtrue;
	rfalse;
];
[ I7SetEitherOr o p negate;
	if (p<0) { p = ~p; negate = ~negate; }
	if (negate) {
		if (PermitAttribute(true, o, p)) {
			if (p<I7_FBNA) give o ~p; else o.p = false;
		}
		return;
	}
	if (PermitAttribute(true, o, p)) {
		if (p<I7_FBNA) give o p; else o.p = true;
	}
];
[ PermitAttributeR obj off i;
	! print "Asking permission of ", (the) obj, "^";
	i=off; while (property_metadata-->i >= 0) {
	if (obj == property_metadata-->i) rtrue; i++; }
	rfalse;
];
[ HypotheticalProperty f obj att off textual i a l; if (att<0) att = ~att;
	if (metaclass(obj) ~= Object) rfalse;
	if (f) {
		if (att < I7_FBNA) off = attribute_offsets-->att;
		else off = attribute_offsets-->(50+att-I7_FBNA);
	} else off = property_offsets-->att;
	if (off<0) rfalse;
	textual = property_metadata-->off; off++;
	if (PermitAttributeR(obj, off)) jump Okay;
	if (obj provides i7_kind) { l = (obj.#i7_kind)/2; a = obj.&i7_kind;
	for (i=0: i<l: i++) if (PermitAttributeR(a-->i, off)) jump Okay; }
	rfalse;
	.Okay; if (f) rtrue;
	if (obj provides att) rtrue;
	rfalse;
];
[ PermitAttribute f obj att off textual i a l; if (att<0) att = ~att;
	if (metaclass(obj) ~= Object) rfalse;
	if (f) {
		if (att < I7_FBNA) off = attribute_offsets-->att;
		else off = attribute_offsets-->(50+att-I7_FBNA);
	} else off = property_offsets-->att;
	if (off<0) return RunTimeProblem(RTP_BADPROPERTY, obj);
	textual = property_metadata-->off; off++;
	if (PermitAttributeR(obj, off)) jump Okay;
	if (obj provides i7_kind) { l = (obj.#i7_kind)/2; a = obj.&i7_kind;
	for (i=0: i<l: i++) if (PermitAttributeR(a-->i, off)) jump Okay; }
	RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;
	.Okay; if (f) rtrue;
	if (obj provides att) rtrue;
	RunTimeProblem(RTP_UNSET, obj, textual);
	rfalse;
];
[ AccessProp obj pr;
	if (Value_Property_Holder provides pr) {
		if ((obj<=0) || (obj > (Value_Property_Holder.pr)-->0)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY);
			rfalse;
		}
		return (Value_Property_Holder.pr)-->(obj+COL_HSIZE);
	}
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if ((pr == door_to) && (obj provides pr)) return obj.pr();
	if (PermitAttribute(false, obj, pr)) return obj.pr;
	rfalse;
];
[ WriteAccessProp obj pr val;
	if (Value_Property_Holder provides pr) {
		if ((obj<=0) || (obj > (Value_Property_Holder.pr)-->0))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		(Value_Property_Holder.pr)-->(obj+COL_HSIZE) = val;
		return;
	}
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (PermitAttribute(false, obj, pr)) obj.pr = val;
];

! Type checking failing at run-time

[ Runtime_Type_Error file line arg;
	print ">--> A mistake in the source (~", (string) file,
		"~, line ", line, ") meant that argument ", arg,
		" had the wrong type.^";
];

! End of RTP.i6 segment

! Printing.i6

!Constant TRACE_I7_SPACING;

[ I7_DefaultPrinter x;
	print x;
];
[ I7_PrintText x;
	if (x ofclass String) print (string) x;
	if (x ofclass Routine) (x)();
];
Global debug_rule_nesting;
[ SetString31 d;
	switch(d) {
		0: string 31 "";
		1: string 31 "    ";
		2: string 31 "		  ";
		3: string 31 "			  ";
		4: string 31 "					";
		default:
		   string 31 "						";
	}
];

[ I7_DivideParagraph;
#ifdef TRACE_I7_SPACING;
	print "[DP", say__p, say__pc, "]";
#endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		if (say__pc & PARA_LINEBREAK) say__pc = say__pc - PARA_LINEBREAK;
		if (say__pc & PARA_FORCELINEBREAK)
			say__pc = say__pc - PARA_FORCELINEBREAK;
	}
#ifdef TRACE_I7_SPACING;
	print "[TO", say__p, say__pc, "]";
#endif;
];

[ I7_RunOnParagraph said;
#ifdef TRACE_I7_SPACING;
	print "[ROP(", said, ")", say__p, say__pc, "]";
#endif;
	say__p = 0; say__pc = say__pc | PARA_LINEBREAK;
	if (said) say__pc = say__pc | PARA_FORCELINEBREAK;
];

[ I7_CommandClarificationBreak;
	say__p = true; I7_DivideParagraph(); say__pc = 0; ! i.e., clear PARA_COMPLETED
];

[ I7_SpliceSnippet A B s1 s2;
	s1 = say__pc; s2 = say__p;
	SpliceSnippet(A, B);
	say__pc = s1; say__p = s2;
];

[ I7_Prompt i;
	style roman;
	if ((say__p) ||
		((say__pc & PARA_LINEBREAK) && ((say__pc & PARA_FORCELINEBREAK)==0))) {
		new_line; say__p=0; say__pc = 0;
	}
	switch(metaclass(I7_prompt_text)) {
		String: print (string) I7_prompt_text;
		Routine: I7_prompt_text();
	}
	say__p = 0; say__pc = 0;
	if (I7_box) {
		for (i=0: I7_boxes_appeared-->i: i++)
			if (I7_boxes_appeared-->i == I7_box) {
					I7_box = 0;
					return;
			}
		I7_boxes_appeared-->i = I7_box;
		I7_box();
		I7_box = 0;
		say__p = 0; say__pc = 0;
	}
	I7_enable_rte = true;
];
[ SL_Score_Moves;
	 if (I7_uninitialised) return;
	#ifdef I7_NOSCORE; print sline2; #ifnot; print sline1, "/", sline2; #endif;
];
[ SL_Location;
	 if (I7_uninitialised) return;
	 if (location == thedark) print (name) location;
	 else
	 {   FindVisibilityLevels();
		 if (visibility_ceiling == location)
			 print (name) location;
		 else print (The) visibility_ceiling;
	 }
];

#Ifdef TARGET_ZCODE;
#IfV5;
#Iftrue (#version_number == 6);

Constant DrawStatusLine_Preempted;

[ DrawStatusLine width x charw scw s spc;
	(0-->8) = (0-->8) &~ $$00000100;
	s = say__p; spc = say__pc;
	BeginActivity(3);
	StatusLineHeight(gg_statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	MoveCursor(1, 1);
	@set_font 4 -> x;
	width = ScreenWidth();
	spaces width;
	say__p = 0; say__pc = 0;
	if (ForActivity(3) == false) {
	! Back to standard font for the display. We use output_stream 3 to
	! measure the space required, the aim being to get 50 characters
	! worth of space for the location name.
	MoveCursor(1, 2);
	@set_font 1 -> x;
	switch (metaclass(I7_left_sl)) {
		String: print (string) I7_left_sl;
		Routine: I7_left_sl();
	}
	@get_wind_prop 1 3 -> width;
	@get_wind_prop 1 13 -> charw;
	charw = charw & $FF;
	@output_stream 3 StorageForShortName;
	print (I7_string) I7_right_sl;
	@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
	x = 1+width-scw;
	@set_cursor 1 x; print (I7_string) I7_right_sl;
	}
	! Reselect roman, as Infocom's interpreters interpreters go funny
	! if reverse is selected twice.
	MainWindow();
	say__p = 0; say__pc = 0;
	EndActivity(3);
	say__p = s; say__pc = spc;
];

#Endif; ! #version_number == 6
#Endif; ! V5
#Endif; ! TARGET_ZCODE

#Ifndef DrawStatusLine_Preempted;
[ DrawStatusLine width posb s spc;
	s = say__p; spc = say__pc;
	BeginActivity(3);
	StatusLineHeight(1); MoveCursor(1, 1); 
	width = ScreenWidth(); posb = width-15;
	spaces width;
	say__p = 0; say__pc = 0;
	if (ForActivity(3) == false) {
		MoveCursor(1, 2);
		switch(metaclass(I7_left_sl)) {
			String: print (string) I7_left_sl;
			Routine: I7_left_sl();
		}
		MoveCursor(1, posb);
		switch(metaclass(I7_right_sl)) {
			String: print (string) I7_right_sl;
			Routine: I7_right_sl();
		}
	}
	MoveCursor(1, 1); MainWindow();
	say__p = 0; say__pc = 0;
	EndActivity(3);
	say__p = s; say__pc = spc;
];
#Endif; ! DrawStatusLine_Preempted

[ I7_say_s; if (say__n ~= 1) print "s"; ];
[ I7_string s; if (s ofclass String) { print (string) s; return; }
	indirect(s);
];
[ I7SwapWF obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has i7listflag) lst = true;
		give obj ~i7listflag;
		if (obj has workflag) give obj i7listflag;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];
[ I7List supp obj par flag mixed ct defart;
	objectloop (obj ofclass Object && obj has i7listflag) {
		ct++;
		if (flag == false) {
			flag = true; par = parent(obj);
		} else {
			if (parent(obj) ~= par) mixed = true;
		}
	}
	if (ct == 0) { print "nothing"; return; }
	if (supp < 0) { supp = -supp; mixed = true; defart = true; }
	if (supp & ISARE_BIT) {
		if (ct > 1) print "are "; else print "is ";
		supp = supp - ISARE_BIT;
	}
	if ((mixed == false) && (par)) {
		ct = c_style;
		I7SwapWF();
		! print "<";
		WriteListFrom(child(par), ENGLISH_BIT+WORKFLAG_BIT+supp);
		I7SwapWF();
		! print ">";
		c_style = ct;
		return;
	}

	objectloop (obj ofclass Object && obj has i7listflag) {
		give obj ~i7listflag;
		if (supp & DEFART_BIT) {
			if (defart) print (The) obj; else print (the) obj;
			defart = false;
		} else print (a) obj;
		ct--;
#ifdef US_DIALECT;
		if (ct == 1) print ", and ";
#ifnot;
		if (ct == 1) print " and ";
#endif;
		if (ct > 1) print ", ";
 }
! print ">";
];
[ I7WriteListFrom A opt;
	if (opt & EXTRAINDENT_BIT) {
		opt = opt - EXTRAINDENT_BIT;
		if (opt & WORKFLAG_BIT) opt = opt - WORKFLAG_BIT + EXTRA_WORKFLAG_BIT;
		WriteListFrom(A, opt, 1);
	}
	else WriteListFrom(A, opt);
];

[ I7_Locale L T1 T2;
	objectloop (L ofclass Object) give L ~I7_mentioned;
];

! End of Printing.i6

! Rulebooks.i6 segment

! (i) Rulebooks are numbered, and we need I6 constants for the numbers of
! some commonly used ones. (These numbers must correspond to those in the
! source of NI, and to the creation sequence in the Standard Rules.)

Constant APROC_RB				= 0;
Constant AFTER_RB				= 3;
Constant PROC_RB				= 4;
Constant ACCESS_RB				= 5;
Constant GENERIC_CARRYOUT_RB	= 7;
Constant REPLY_RB				= 8;
Constant TURNEND_RB				= 9;
Constant REACHIN_RB				= 10;
Constant REACHOUT_RB			= 11;
Constant GAME_BEGINS_RB			= 22;
Constant GAME_ENDS_RB			= 23;
Constant GENERIC_CHECK_RB		= 25;
Constant GENERIC_REPORT_RB		= 26;
Constant PERSUADE_RB			= 27;
Constant UNABLE_RB				= 28;
Constant VISIBLE_RB				= 29;
Constant SETACTIONVARS_RB		= 31;

! (ii) We maintain a "rule change stack" to keep track of any temporary
! abolition or modification of rules otherwise used in the rulebooks.
! The rule change stack contains 3-word (6 byte) records, and is defined
! in Main.i6. 

[ PushRuleChange usage rule1 rule2;
	if (rulechange_sp >= RS_CAPACITY) {
		return RunTimeProblem(RTP_RULESTACK);
	}
	rulechange_stack-->rulechange_sp++ = usage;
	rulechange_stack-->rulechange_sp++ = rule1;
	rulechange_stack-->rulechange_sp++ = rule2;
];

! The first word of each record indicates a usage type, of which one value
! is special and indicates the start of a frame. A new frame is opened on
! the stack each time a new "follow" occurs; recall that this processes a
! rulebook after consulting procedural rules, which may in turn modify
! the behaviour of other rules. These frame divisions, therefore, mark
! local scopes for modifications: anything from the top of the stack down
! to the topmost frame marker is currently in force.

Global rule_frames = 0;

Constant RS_FRAME = -1;

! The other possible values of usage are as follows:

Constant RS_DONOTRUN	= 1;
Constant RS_RUN			= 2;
Constant RS_MOVEBEFORE	= 3;
Constant RS_MOVEAFTER	= 4;
Constant RS_DONOTUSE	= 5;
Constant RS_USE			= 6;
Constant RS_SUBSTITUTE	= 7;
Constant RS_SUCCEEDS	= 8;
Constant RS_FAILS		= 9;
Constant RS_NEITHER		= 10;

! (iii) To "follow" a rulebook, we start a new frame, process the
! procedural rules, then process the rulebook, then clear the frame back off
! the stack:

[ BeginFollowRulebook;
	PushRuleChange(RS_FRAME, RS_FRAME, RS_FRAME);
	rule_frames++;
	! print "+<", rule_frames, "/", rulechange_sp, ">";
	if (rule_frames == 20) {
		RunTimeProblem(RTP_TOOMANYRULEBOOKS);
		rule_frames = -1;
		return;
	}
	ProcessRulebook(PROC_RB, 0, 1);
];
[ EndFollowRulebook r x y;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) r = 1;
	else if (rulechange_stack-->rulechange_sp == RS_FAILS) r = 0;
	else r = -1;
	if (r ~= -1) {
		x = rulechange_stack-->(rulechange_sp+1);
		y = rulechange_stack-->(rulechange_sp+2);
	}
	rule_frames--;
	while (rulechange_sp > 0) {
		rulechange_sp = rulechange_sp - 3;
		if (rulechange_stack-->rulechange_sp == RS_FRAME) break;
	}
	if (rulechange_sp == 0) rule_frames = 0;
	if (r == 1) rulechange_stack-->rulechange_sp = RS_SUCCEEDS;
	else if (r == 0) rulechange_stack-->rulechange_sp = RS_FAILS;
	if (r ~= -1) {
		rulechange_stack-->(rulechange_sp+1) = x;
		rulechange_stack-->(rulechange_sp+2) = y;
	}
	! print "-<", rule_frames, "/", rulechange_sp, ">";
];

[ FollowRulebook rulebook par activity_flag rv;
	! print "^{", rulebook, "}";
	if (rulebook ~= PROC_RB) BeginFollowRulebook();
	rv = ProcessRulebook(rulebook, par, activity_flag);
	if (rulebook ~= PROC_RB) EndFollowRulebook();
	! print "{/", rulebook, "}";
	if (rv) rtrue; rfalse;
];

[ FollowRulebookSelfed R o ss rv;
	ss = self; if (o) self = o;
	rv = FollowRulebook(R, o, true);
	self = ss; return rv;
];

[ ConsiderRulebook rulebook par bits rv;
	!print "[Considering rb ", rulebook, " for ", (the) par, "]^";
	rv = ProcessRulebook(rulebook, par, bits);
	!print "[Considered rb ", rulebook, " for ", (the) par, " outcome ", rv, "]^";
	return rv;
];

[ AbideByRulebook rulebook par bits rv;
	rv = ProcessRulebook(rulebook, par, bits);
	return rv;
];

! (iv) The main rulebook processing routine is
!   ProcessRulebook(rulebook/rule)
! which returns true if the rulebook or rule chose to "succeed" or "fail",
! and false if it made no choice. In the event that a choice was made, the
! result is left as a record above the top of the stack, and should be
! collected immediately.
! First a variable logging the depth of recursion of rulebook processing,
! which at present is used only to print neatly formatted debugging:

Global process_rulebook_count;

! The following bitmap is used in a simple state machine while working
! through a given routine:

Constant RS_ACTIVE_BIT		= 1;
Constant RS_MOVED_BIT		= 2;
Constant RS_USERESULT_BIT	= 4;
Constant RS_ACTIVITY		= 8;
Constant RS_NOSKIPS			= 16;

! The following flag records whether we are tracing rule invocations:
Global debugging_rules = false;

[ ProcessRulebook rulebook par bits rv
	x frame_base substituted_rule usage original_deadflag ssrb;
! if ((rulebook >= 0) && (rulebook < HIGHEST_RULEBOOK_NO)) {
!	print "Rulebook ", rulebook, "^";
! }
	if ((Protect_I7_Arrays-->0 ~= 16339) ||
		(Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (bits) bits = RS_ACTIVITY + RS_NOSKIPS;
	if (rule_frames<0) rfalse;
	original_deadflag = deadflag;
	if (par) parameter_object = par;
	for (x = rulechange_sp-3: x>=0: x = x - 3) {
		usage = rulechange_stack-->x;
		if (usage == RS_FRAME) { x=x+3; break; }
		if (rulechange_stack-->(x+1) == rulebook) {
			if (usage == RS_MOVEBEFORE) bits = bits | (RS_MOVED_BIT);
			if (usage == RS_MOVEAFTER) bits = bits | (RS_MOVED_BIT);
		}
	} if (x<0) x=0; frame_base = x;
	if ((bits & RS_MOVED_BIT) && (rv == false)) { rfalse; }
	! rv was a call parameter: it's no longer needed and is now reused
	bits = bits | RS_ACTIVE_BIT;
	bits = bits | RS_USERESULT_BIT;
	substituted_rule = rulebook; rv = 0;
	for (: x<rulechange_sp: x = x + 3) {
		usage = rulechange_stack-->x;
		if (rulechange_stack-->(x+1) == rulebook) {
			if (usage == RS_DONOTRUN) bits = bits & (~RS_ACTIVE_BIT);
			if (usage == RS_RUN) bits = bits | (RS_ACTIVE_BIT);
			if (usage == RS_DONOTUSE) bits = bits & (~RS_USERESULT_BIT);
			if (usage == RS_USE) bits = bits | (RS_USERESULT_BIT);
			if (usage == RS_SUBSTITUTE)
				substituted_rule = rulechange_stack-->(x+2);
		}
		if ((usage == RS_MOVEBEFORE) && (rulechange_stack-->(x+2) == rulebook)) {
			rv = ProcessRulebook(rulechange_stack-->(x+1),
				par, (bits & RS_ACTIVITY ~= 0), true);
			if (rv) return rv;
		}
	}
	if ((bits & RS_ACTIVE_BIT) == 0) rfalse;
	! We now reuse usage to keep the stack frame slimmer
	usage = debugging_rules;
	#ifdef DEBUG;
	AdjustDbr(substituted_rule);
	#endif;
	#ifndef I7_ECONOMY;
	if (debugging_rules) DebugRulebooks(substituted_rule, par);
	#endif;
	! (A routine defined in the I7 code generator)
	process_rulebook_count = process_rulebook_count + debugging_rules;
	if ((substituted_rule >= 0) && (substituted_rule < HIGHEST_RULEBOOK_NO)) {
		ssrb = substituted_rule;
		if (ssrb ~= APROC_RB) MStack_CreateRBVars(ssrb);
		substituted_rule = rulebooks_array-->substituted_rule;
		for (x=0, rv=0:
			(substituted_rule-->x~=I6_NULL) && (original_deadflag == deadflag):
			x++) {
			if ((rv = (ProcessRulebook(substituted_rule-->x,
				par, (bits & RS_ACTIVITY ~= 0))))
			    && (bits & RS_USERESULT_BIT)) break;
			rv = 0;
		}
		if (ssrb ~= APROC_RB) MStack_DestroyRBVars(ssrb);
	} else {
		if ((say__p) && (bits & RS_NOSKIPS == 0)) I7_DivideParagraph();
		rv = indirect(substituted_rule);
		if (rv) rv = substituted_rule;
	}
	if (rv && (bits & RS_USERESULT_BIT)) {
		#ifdef DEBUG;
		AdjustDbr(substituted_rule);
		#endif;
		  process_rulebook_count = process_rulebook_count - debugging_rules;
		  if (process_rulebook_count < 0) process_rulebook_count = 0;
		#ifndef I7_ECONOMY;
		  if (debugging_rules) {
			spaces(2*process_rulebook_count);
	  	  if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
	  			print "[stopped: success]^";
	  	  if (rulechange_stack-->rulechange_sp == RS_FAILS)
	  			print "[stopped: fail]^";
		}
		#endif;
		debugging_rules = usage;
		return rv;
	}
	for (x=rulechange_sp-3: x>=frame_base: x = x-3) {
		if ((rulechange_stack-->x == RS_MOVEAFTER) &&
			(rulechange_stack-->(x+2) == rulebook)) {
			rv = ProcessRulebook(rulechange_stack-->(x+1),
				par, (bits & RS_ACTIVITY ~= 0), true);
			if (rv) {
				process_rulebook_count--;
			    debugging_rules = usage;
				return rv;
			}
		}
	}
	process_rulebook_count = process_rulebook_count - debugging_rules;
	rulechange_stack-->rulechange_sp = 0;
	debugging_rules = usage;
	rfalse;
];

! (v) The following routines provide a sort of rule-changing API:

[ ResultOfRule a;
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = rulechange_stack-->(rulechange_sp + 1);
		if (a) return rulechange_stack-->(rulechange_sp + 2);
	}
	rfalse;
];

[ ActRulebookSucceeds rule_id;
	if (rule_id) I7_action_deciding_rule = rule_id;
	RulebookSucceeds();
];
[ ActRulebookFails rule_id;
	if (rule_id) I7_action_deciding_rule = rule_id;
	RulebookFails();
];
[ RulebookSucceeds valueflag value;
	PushRuleChange(RS_SUCCEEDS, valueflag, value);
	rulechange_sp = rulechange_sp - 3;
];
[ RulebookFails valueflag value;
	PushRuleChange(RS_FAILS, valueflag, value);
	rulechange_sp = rulechange_sp - 3;
];
[ RuleHasNoOutcome;
	PushRuleChange(RS_NEITHER, 0, 0);
	rulechange_sp = rulechange_sp - 3;
];
[ RulebookSucceeded;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) rtrue;
	rfalse;
];

[ SuppressRule rule;
	PushRuleChange(RS_DONOTRUN, rule, 0);
];
[ ReinstateRule rule;
	PushRuleChange(RS_RUN, rule, 0);
];
[ DonotuseRule rule;
	PushRuleChange(RS_DONOTUSE, rule, 0);
];
[ UseRule rule;
	PushRuleChange(RS_USE, rule, 0);
];
[ SubstituteRule rule1 rule2;
	PushRuleChange(RS_SUBSTITUTE, rule2, rule1);
];
[ MoveRuleBefore rule1 rule2;
	PushRuleChange(RS_MOVEBEFORE, rule1, rule2);
];
[ MoveRuleAfter rule1 rule2;
	PushRuleChange(RS_MOVEAFTER, rule1, rule2);
];

! (vi) This is the I6 printing rule used for a value of kind "rule", which
! is the I6 packed address of the rule's routine:

#IFNDEF I7_ECONOMY;
Array RulebookNames -->
    "Action-processing rulebook" ! 0
    "Before rulebook" ! 1
    "Instead rulebook" ! 2
    "After rulebook" ! 3
    "Procedural rulebook" ! 4
    "Accessibility rulebook" ! 5
    "Action-specific rulebook" ! 6
    "Carry out rulebook" ! 7
    "General report rulebook" ! 8
    "Turn sequence rulebook" ! 9
    "Reaching inside rulebook" ! 10
    "Reaching outside rulebook" ! 11
    "General before rulebook" ! 12
    "Actor-specific before rulebook" ! 13
    "Location-specific before rulebook" ! 14
    "Reaction before rulebook" ! 15
    "Object-specific before rulebook" ! 16
    "General after rulebook" ! 17
    "Actor-specific after rulebook" ! 18
    "Location-specific after rulebook" ! 19
    "Reaction after rulebook" ! 20
    "Object-specific after rulebook" ! 21
    "When play begins rulebook" ! 22
    "When play ends rulebook" ! 23
    "Every turn rulebook" ! 24
    "Check rulebook" ! 25
    "Report rulebook" ! 26
    "Persuasion rulebook" ! 27
    "Unsuccessful attempt by rulebook" ! 28
    "Visibility rulebook" ! 29
    "does the player mean rulebook" ! 30
    "Setting action variables rulebook" ! 31
    "Scene changing rulebook" ! 32
    "when Entire Game begins rulebook" ! 33
    "when Entire Game ends rulebook" ! 34
    "before Printing the name rulebook" ! 35
    "for Printing the name rulebook" ! 36
    "after Printing the name rulebook" ! 37
    "before Listing contents rulebook" ! 38
    "for Listing contents rulebook" ! 39
    "after Listing contents rulebook" ! 40
    "before Grouping together rulebook" ! 41
    "for Grouping together rulebook" ! 42
    "after Grouping together rulebook" ! 43
    "before Constructing the status line rulebook" ! 44
    "for Constructing the status line rulebook" ! 45
    "after Constructing the status line rulebook" ! 46
    "before Listing nondescript items rulebook" ! 47
    "for Listing nondescript items rulebook" ! 48
    "after Listing nondescript items rulebook" ! 49
    "before Deciding the scope rulebook" ! 50
    "for Deciding the scope rulebook" ! 51
    "after Deciding the scope rulebook" ! 52
    "before Supplying a missing noun rulebook" ! 53
    "for Supplying a missing noun rulebook" ! 54
    "after Supplying a missing noun rulebook" ! 55
    "before Supplying a missing second noun rulebook" ! 56
    "for Supplying a missing second noun rulebook" ! 57
    "after Supplying a missing second noun rulebook" ! 58
    "before Reading a command rulebook" ! 59
    "for Reading a command rulebook" ! 60
    "after Reading a command rulebook" ! 61
    "before Deciding whether all includes rulebook" ! 62
    "for Deciding whether all includes rulebook" ! 63
    "after Deciding whether all includes rulebook" ! 64
    "before Printing the player's obituary rulebook" ! 65
    "for Printing the player's obituary rulebook" ! 66
    "after Printing the player's obituary rulebook" ! 67
    "before Amusing a victorious player rulebook" ! 68
    "for Amusing a victorious player rulebook" ! 69
    "after Amusing a victorious player rulebook" ! 70
    "before Printing the banner text rulebook" ! 71
    "for Printing the banner text rulebook" ! 72
    "after Printing the banner text rulebook" ! 73
    "before Printing the plural name rulebook" ! 74
    "for Printing the plural name rulebook" ! 75
    "after Printing the plural name rulebook" ! 76
    "before Deciding the concealed possessions rulebook" ! 77
    "for Deciding the concealed possessions rulebook" ! 78
    "after Deciding the concealed possessions rulebook" ! 79
    "before Printing a refusal to act in the dark rulebook" ! 80
    "for Printing a refusal to act in the dark rulebook" ! 81
    "after Printing a refusal to act in the dark rulebook" ! 82
    "before Printing the announcement of darkness rulebook" ! 83
    "for Printing the announcement of darkness rulebook" ! 84
    "after Printing the announcement of darkness rulebook" ! 85
    "before Printing the name of a dark room rulebook" ! 86
    "for Printing the name of a dark room rulebook" ! 87
    "after Printing the name of a dark room rulebook" ! 88
    "before Printing the description of a dark room rulebook" ! 89
    "for Printing the description of a dark room rulebook" ! 90
    "after Printing the description of a dark room rulebook" ! 91
    "before Printing room description details rulebook" ! 92
    "for Printing room description details rulebook" ! 93
    "after Printing room description details rulebook" ! 94
    "before Printing a parser error rulebook" ! 95
    "for Printing a parser error rulebook" ! 96
    "after Printing a parser error rulebook" ! 97
    "before Implicitly taking rulebook" ! 98
    "for Implicitly taking rulebook" ! 99
    "after Implicitly taking rulebook" ! 100
    "before Starting the virtual machine rulebook" ! 101
    "for Starting the virtual machine rulebook" ! 102
    "after Starting the virtual machine rulebook" ! 103
    "before Clarifying the parser's choice rulebook" ! 104
    "for Clarifying the parser's choice rulebook" ! 105
    "after Clarifying the parser's choice rulebook" ! 106
    "before Asking which do you mean rulebook" ! 107
    "for Asking which do you mean rulebook" ! 108
    "after Asking which do you mean rulebook" ! 109
    "before Writing a paragraph about rulebook" ! 110
    "for Writing a paragraph about rulebook" ! 111
    "after Writing a paragraph about rulebook" ! 112
    "check Taking inventory rulebook" ! 113
    "carry out Taking inventory rulebook" ! 114
    "report Taking inventory rulebook" ! 115
    "check Taking rulebook" ! 116
    "carry out Taking rulebook" ! 117
    "report Taking rulebook" ! 118
    "check Removing it from rulebook" ! 119
    "carry out Removing it from rulebook" ! 120
    "report Removing it from rulebook" ! 121
    "check Dropping rulebook" ! 122
    "carry out Dropping rulebook" ! 123
    "report Dropping rulebook" ! 124
    "check Putting it on rulebook" ! 125
    "carry out Putting it on rulebook" ! 126
    "report Putting it on rulebook" ! 127
    "check Inserting it into rulebook" ! 128
    "carry out Inserting it into rulebook" ! 129
    "report Inserting it into rulebook" ! 130
    "check Eating rulebook" ! 131
    "carry out Eating rulebook" ! 132
    "report Eating rulebook" ! 133
    "check Going rulebook" ! 134
    "carry out Going rulebook" ! 135
    "report Going rulebook" ! 136
    "check Entering rulebook" ! 137
    "carry out Entering rulebook" ! 138
    "report Entering rulebook" ! 139
    "check Exiting rulebook" ! 140
    "carry out Exiting rulebook" ! 141
    "report Exiting rulebook" ! 142
    "check Getting off rulebook" ! 143
    "carry out Getting off rulebook" ! 144
    "report Getting off rulebook" ! 145
    "check Looking rulebook" ! 146
    "carry out Looking rulebook" ! 147
    "report Looking rulebook" ! 148
    "check Examining rulebook" ! 149
    "carry out Examining rulebook" ! 150
    "report Examining rulebook" ! 151
    "check Looking under rulebook" ! 152
    "carry out Looking under rulebook" ! 153
    "report Looking under rulebook" ! 154
    "check Searching rulebook" ! 155
    "carry out Searching rulebook" ! 156
    "report Searching rulebook" ! 157
    "check Consulting it about rulebook" ! 158
    "carry out Consulting it about rulebook" ! 159
    "report Consulting it about rulebook" ! 160
    "check Locking it with rulebook" ! 161
    "carry out Locking it with rulebook" ! 162
    "report Locking it with rulebook" ! 163
    "check Unlocking it with rulebook" ! 164
    "carry out Unlocking it with rulebook" ! 165
    "report Unlocking it with rulebook" ! 166
    "check Switching on rulebook" ! 167
    "carry out Switching on rulebook" ! 168
    "report Switching on rulebook" ! 169
    "check Switching off rulebook" ! 170
    "carry out Switching off rulebook" ! 171
    "report Switching off rulebook" ! 172
    "check Opening rulebook" ! 173
    "carry out Opening rulebook" ! 174
    "report Opening rulebook" ! 175
    "check Closing rulebook" ! 176
    "carry out Closing rulebook" ! 177
    "report Closing rulebook" ! 178
    "check Wearing rulebook" ! 179
    "carry out Wearing rulebook" ! 180
    "report Wearing rulebook" ! 181
    "check Taking off rulebook" ! 182
    "carry out Taking off rulebook" ! 183
    "report Taking off rulebook" ! 184
    "check Giving it to rulebook" ! 185
    "carry out Giving it to rulebook" ! 186
    "report Giving it to rulebook" ! 187
    "check Showing it to rulebook" ! 188
    "carry out Showing it to rulebook" ! 189
    "report Showing it to rulebook" ! 190
    "check Waking rulebook" ! 191
    "carry out Waking rulebook" ! 192
    "report Waking rulebook" ! 193
    "check Throwing it at rulebook" ! 194
    "carry out Throwing it at rulebook" ! 195
    "report Throwing it at rulebook" ! 196
    "check Attacking rulebook" ! 197
    "carry out Attacking rulebook" ! 198
    "report Attacking rulebook" ! 199
    "check Kissing rulebook" ! 200
    "carry out Kissing rulebook" ! 201
    "report Kissing rulebook" ! 202
    "check Answering it that rulebook" ! 203
    "carry out Answering it that rulebook" ! 204
    "report Answering it that rulebook" ! 205
    "check Telling it about rulebook" ! 206
    "carry out Telling it about rulebook" ! 207
    "report Telling it about rulebook" ! 208
    "check Asking it about rulebook" ! 209
    "carry out Asking it about rulebook" ! 210
    "report Asking it about rulebook" ! 211
    "check Asking it for rulebook" ! 212
    "carry out Asking it for rulebook" ! 213
    "report Asking it for rulebook" ! 214
    "check Waiting rulebook" ! 215
    "carry out Waiting rulebook" ! 216
    "report Waiting rulebook" ! 217
    "check Touching rulebook" ! 218
    "carry out Touching rulebook" ! 219
    "report Touching rulebook" ! 220
    "check Waving rulebook" ! 221
    "carry out Waving rulebook" ! 222
    "report Waving rulebook" ! 223
    "check Pulling rulebook" ! 224
    "carry out Pulling rulebook" ! 225
    "report Pulling rulebook" ! 226
    "check Pushing rulebook" ! 227
    "carry out Pushing rulebook" ! 228
    "report Pushing rulebook" ! 229
    "check Turning rulebook" ! 230
    "carry out Turning rulebook" ! 231
    "report Turning rulebook" ! 232
    "check Pushing it to rulebook" ! 233
    "carry out Pushing it to rulebook" ! 234
    "report Pushing it to rulebook" ! 235
    "check Squeezing rulebook" ! 236
    "carry out Squeezing rulebook" ! 237
    "report Squeezing rulebook" ! 238
    "check Saying yes rulebook" ! 239
    "carry out Saying yes rulebook" ! 240
    "report Saying yes rulebook" ! 241
    "check Saying no rulebook" ! 242
    "carry out Saying no rulebook" ! 243
    "report Saying no rulebook" ! 244
    "check Burning rulebook" ! 245
    "carry out Burning rulebook" ! 246
    "report Burning rulebook" ! 247
    "check Waking up rulebook" ! 248
    "carry out Waking up rulebook" ! 249
    "report Waking up rulebook" ! 250
    "check Thinking rulebook" ! 251
    "carry out Thinking rulebook" ! 252
    "report Thinking rulebook" ! 253
    "check Smelling rulebook" ! 254
    "carry out Smelling rulebook" ! 255
    "report Smelling rulebook" ! 256
    "check Listening to rulebook" ! 257
    "carry out Listening to rulebook" ! 258
    "report Listening to rulebook" ! 259
    "check Tasting rulebook" ! 260
    "carry out Tasting rulebook" ! 261
    "report Tasting rulebook" ! 262
    "check Cutting rulebook" ! 263
    "carry out Cutting rulebook" ! 264
    "report Cutting rulebook" ! 265
    "check Jumping rulebook" ! 266
    "carry out Jumping rulebook" ! 267
    "report Jumping rulebook" ! 268
    "check Tying it to rulebook" ! 269
    "carry out Tying it to rulebook" ! 270
    "report Tying it to rulebook" ! 271
    "check Drinking rulebook" ! 272
    "carry out Drinking rulebook" ! 273
    "report Drinking rulebook" ! 274
    "check Saying sorry rulebook" ! 275
    "carry out Saying sorry rulebook" ! 276
    "report Saying sorry rulebook" ! 277
    "check Swearing obscenely rulebook" ! 278
    "carry out Swearing obscenely rulebook" ! 279
    "report Swearing obscenely rulebook" ! 280
    "check Swearing mildly rulebook" ! 281
    "carry out Swearing mildly rulebook" ! 282
    "report Swearing mildly rulebook" ! 283
    "check Swinging rulebook" ! 284
    "carry out Swinging rulebook" ! 285
    "report Swinging rulebook" ! 286
    "check Rubbing rulebook" ! 287
    "carry out Rubbing rulebook" ! 288
    "report Rubbing rulebook" ! 289
    "check Setting it to rulebook" ! 290
    "carry out Setting it to rulebook" ! 291
    "report Setting it to rulebook" ! 292
    "check Waving hands rulebook" ! 293
    "carry out Waving hands rulebook" ! 294
    "report Waving hands rulebook" ! 295
    "check Buying rulebook" ! 296
    "carry out Buying rulebook" ! 297
    "report Buying rulebook" ! 298
    "check Singing rulebook" ! 299
    "carry out Singing rulebook" ! 300
    "report Singing rulebook" ! 301
    "check Climbing rulebook" ! 302
    "carry out Climbing rulebook" ! 303
    "report Climbing rulebook" ! 304
    "check Sleeping rulebook" ! 305
    "carry out Sleeping rulebook" ! 306
    "report Sleeping rulebook" ! 307
    "check Requesting the score rulebook" ! 308
    "carry out Requesting the score rulebook" ! 309
    "report Requesting the score rulebook" ! 310
    "check Quitting the game rulebook" ! 311
    "carry out Quitting the game rulebook" ! 312
    "report Quitting the game rulebook" ! 313
    "check Saving the game rulebook" ! 314
    "carry out Saving the game rulebook" ! 315
    "report Saving the game rulebook" ! 316
    "check Restoring the game rulebook" ! 317
    "carry out Restoring the game rulebook" ! 318
    "report Restoring the game rulebook" ! 319
    "check Restarting the game rulebook" ! 320
    "carry out Restarting the game rulebook" ! 321
    "report Restarting the game rulebook" ! 322
    "check Verifying the story file rulebook" ! 323
    "carry out Verifying the story file rulebook" ! 324
    "report Verifying the story file rulebook" ! 325
    "check Requesting the story file version rulebook" ! 326
    "carry out Requesting the story file version rulebook" ! 327
    "report Requesting the story file version rulebook" ! 328
    "check Switching the story transcript on rulebook" ! 329
    "carry out Switching the story transcript on rulebook" ! 330
    "report Switching the story transcript on rulebook" ! 331
    "check Switching the story transcript off rulebook" ! 332
    "carry out Switching the story transcript off rulebook" ! 333
    "report Switching the story transcript off rulebook" ! 334
    "check Preferring abbreviated room descriptions rulebook" ! 335
    "carry out Preferring abbreviated room descriptions rulebook" ! 336
    "report Preferring abbreviated room descriptions rulebook" ! 337
    "check Preferring unabbreviated room descriptions rulebook" ! 338
    "carry out Preferring unabbreviated room descriptions rulebook" ! 339
    "report Preferring unabbreviated room descriptions rulebook" ! 340
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 341
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 342
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 343
    "check Requesting the pronoun meanings rulebook" ! 344
    "carry out Requesting the pronoun meanings rulebook" ! 345
    "report Requesting the pronoun meanings rulebook" ! 346
    "check Switching score notification on rulebook" ! 347
    "carry out Switching score notification on rulebook" ! 348
    "report Switching score notification on rulebook" ! 349
    "check Switching score notification off rulebook" ! 350
    "carry out Switching score notification off rulebook" ! 351
    "report Switching score notification off rulebook" ! 352
;


#ENDIF; ! I7_ECONOMY

[ I7_RulePrintingRule R p1;
#ifndef I7_ECONOMY;
	if ((R>=0) && (R<353)) {
		print (string) (RulebookNames-->R);
	} else {
		if (R == R_14) { print "very unlikely to mean taking what's already carried rule"; return; } ! 0, case 1
		if (R == R_23) { print "standard name printing rule"; return; } ! 1, case 1
		if (R == R_24) { print "standard contents listing rule"; return; } ! 2, case 1
		if (R == R_25) { print "make named things mentioned rule"; return; } ! 3, case 1
		if (R == R_26) { print "print empty inventory rule"; return; } ! 4, case 1
		if (R == R_27) { print "print standard inventory rule"; return; } ! 5, case 1
		if (R == R_28) { print "use inventory to set pronouns rule"; return; } ! 6, case 1
		if (R == R_29) { print "report other people taking inventory rule"; return; } ! 7, case 1
		if (R == R_30) { print "standard set taking variables rule"; return; } ! 8, case 1
		if (R == R_31) { print "avoid unnecessary implicit taking rule"; return; } ! 9, case 1
		if (R == R_32) { print "can't take yourself rule"; return; } ! 10, case 1
		if (R == R_33) { print "can't take other people rule"; return; } ! 11, case 1
		if (R == R_34) { print "can't take component parts rule"; return; } ! 12, case 1
		if (R == R_35) { print "can't take people's possessions rule"; return; } ! 13, case 1
		if (R == R_36) { print "can't take items out of play rule"; return; } ! 14, case 1
		if (R == R_37) { print "can't take what you're inside rule"; return; } ! 15, case 1
		if (R == R_38) { print "can't take what's already taken rule"; return; } ! 16, case 1
		if (R == R_39) { print "can't take scenery rule"; return; } ! 17, case 1
		if (R == R_40) { print "can only take things rule"; return; } ! 18, case 1
		if (R == R_41) { print "can't take what's fixed in place rule"; return; } ! 19, case 1
		if (R == R_42) { print "use player's holdall to avoid exceeding carrying capacity rule"; return; } ! 20, case 1
		if (R == R_43) { print "can't exceed carrying capacity rule"; return; } ! 21, case 1
		if (R == R_44) { print "standard taking rule"; return; } ! 22, case 1
		if (R == R_45) { print "don't report successful implicit takes rule"; return; } ! 23, case 1
		if (R == R_46) { print "standard report taking rule"; return; } ! 24, case 1
		if (R == R_47) { print "can't remove what's not inside rule"; return; } ! 25, case 1
		if (R == R_48) { print "can't remove from people rule"; return; } ! 26, case 1
		if (R == R_49) { print "convert remove to take rule"; return; } ! 27, case 1
		if (R == R_50) { print "can't drop yourself rule"; return; } ! 28, case 1
		if (R == R_51) { print "can't drop what's already dropped rule"; return; } ! 29, case 1
		if (R == R_52) { print "can't drop what's not held rule"; return; } ! 30, case 1
		if (R == R_53) { print "can't drop clothes being worn rule"; return; } ! 31, case 1
		if (R == R_54) { print "can't drop if this exceeds carrying capacity rule"; return; } ! 32, case 1
		if (R == R_55) { print "standard dropping rule"; return; } ! 33, case 1
		if (R == R_56) { print "standard report dropping rule"; return; } ! 34, case 1
		if (R == R_57) { print "convert put to drop where possible rule"; return; } ! 35, case 1
		if (R == R_58) { print "can't put what's not held rule"; return; } ! 36, case 1
		if (R == R_59) { print "can't put something on itself rule"; return; } ! 37, case 1
		if (R == R_60) { print "can't put onto what's not a supporter rule"; return; } ! 38, case 1
		if (R == R_61) { print "can't put onto something being carried rule"; return; } ! 39, case 1
		if (R == R_62) { print "can't put clothes being worn rule"; return; } ! 40, case 1
		if (R == R_63) { print "can't put if this exceeds carrying capacity rule"; return; } ! 41, case 1
		if (R == R_64) { print "standard putting rule"; return; } ! 42, case 1
		if (R == R_65) { print "concise report putting rule"; return; } ! 43, case 1
		if (R == R_66) { print "standard report putting rule"; return; } ! 44, case 1
		if (R == R_67) { print "convert insert to drop where possible rule"; return; } ! 45, case 1
		if (R == R_68) { print "can't insert what's not held rule"; return; } ! 46, case 1
		if (R == R_69) { print "can't insert something into itself rule"; return; } ! 47, case 1
		if (R == R_70) { print "can't insert into closed containers rule"; return; } ! 48, case 1
		if (R == R_71) { print "can't insert into what's not a container rule"; return; } ! 49, case 1
		if (R == R_72) { print "can't insert clothes being worn rule"; return; } ! 50, case 1
		if (R == R_73) { print "can't insert if this exceeds carrying capacity rule"; return; } ! 51, case 1
		if (R == R_74) { print "standard inserting rule"; return; } ! 52, case 1
		if (R == R_75) { print "concise report inserting rule"; return; } ! 53, case 1
		if (R == R_76) { print "standard report inserting rule"; return; } ! 54, case 1
		if (R == R_77) { print "can't eat unless edible rule"; return; } ! 55, case 1
		if (R == R_78) { print "can't eat clothing without removing it first rule"; return; } ! 56, case 1
		if (R == R_79) { print "standard eating rule"; return; } ! 57, case 1
		if (R == R_80) { print "standard report eating rule"; return; } ! 58, case 1
		if (R == R_81) { print "standard set going variables rule"; return; } ! 59, case 1
		if (R == R_82) { print "can't travel in what's not a vehicle rule"; return; } ! 60, case 1
		if (R == R_83) { print "can't go through undescribed doors rule"; return; } ! 61, case 1
		if (R == R_84) { print "can't go through closed doors rule"; return; } ! 62, case 1
		if (R == R_85) { print "determine map connection rule"; return; } ! 63, case 1
		if (R == R_86) { print "can't go that way rule"; return; } ! 64, case 1
		if (R == R_87) { print "move player and vehicle rule"; return; } ! 65, case 1
		if (R == R_88) { print "move floating objects rule"; return; } ! 66, case 1
		if (R == R_89) { print "check light in new location rule"; return; } ! 67, case 1
		if (R == R_90) { print "describe room gone into rule"; return; } ! 68, case 1
		if (R == R_91) { print "convert enter door into go rule"; return; } ! 69, case 1
		if (R == R_92) { print "convert enter compass direction into go rule"; return; } ! 70, case 1
		if (R == R_93) { print "can't enter what's already entered rule"; return; } ! 71, case 1
		if (R == R_94) { print "can't enter what's not enterable rule"; return; } ! 72, case 1
		if (R == R_95) { print "can't enter closed containers rule"; return; } ! 73, case 1
		if (R == R_96) { print "can't enter something carried rule"; return; } ! 74, case 1
		if (R == R_97) { print "implicitly pass through other barriers rule"; return; } ! 75, case 1
		if (R == R_98) { print "standard entering rule"; return; } ! 76, case 1
		if (R == R_99) { print "standard report entering rule"; return; } ! 77, case 1
		if (R == R_100) { print "describe contents entered into rule"; return; } ! 78, case 1
		if (R == R_102) { print "convert exit into go out rule"; return; } ! 79, case 1
		if (R == R_103) { print "can't exit when not inside anything rule"; return; } ! 80, case 1
		if (R == R_104) { print "can't exit closed containers rule"; return; } ! 81, case 1
		if (R == R_105) { print "convert exit into get off rule"; return; } ! 82, case 1
		if (R == R_106) { print "standard exiting rule"; return; } ! 83, case 1
		if (R == R_107) { print "standard report exiting rule"; return; } ! 84, case 1
		if (R == R_108) { print "describe room emerged into rule"; return; } ! 85, case 1
		if (R == R_109) { print "can't get off things rule"; return; } ! 86, case 1
		if (R == R_110) { print "standard getting off rule"; return; } ! 87, case 1
		if (R == R_111) { print "standard report getting off rule"; return; } ! 88, case 1
		if (R == R_112) { print "describe room stood up into rule"; return; } ! 89, case 1
		if (R == R_113) { print "determine visibility ceiling rule"; return; } ! 90, case 1
		if (R == R_114) { print "room description heading rule"; return; } ! 91, case 1
		if (R == R_115) { print "room description body text rule"; return; } ! 92, case 1
		if (R == R_116) { print "room description paragraphs about objects rule"; return; } ! 93, case 1
		if (R == R_117) { print "check new arrival rule"; return; } ! 94, case 1
		if (R == R_118) { print "other people looking rule"; return; } ! 95, case 1
		if (R == R_119) { print "examine undescribed containers rule"; return; } ! 96, case 1
		if (R == R_120) { print "examine undescribed devices rule"; return; } ! 97, case 1
		if (R == R_121) { print "examine undescribed things rule"; return; } ! 98, case 1
		if (R == R_122) { print "examine directions rule"; return; } ! 99, case 1
		if (R == R_123) { print "standard examining rule"; return; } ! 100, case 1
		if (R == R_124) { print "examine described devices rule"; return; } ! 101, case 1
		if (R == R_125) { print "report other people examining rule"; return; } ! 102, case 1
		if (R == R_126) { print "standard looking under rule"; return; } ! 103, case 1
		if (R == R_127) { print "report other people looking under rule"; return; } ! 104, case 1
		if (R == R_128) { print "can't search unless container or supporter rule"; return; } ! 105, case 1
		if (R == R_129) { print "can't search closed opaque containers rule"; return; } ! 106, case 1
		if (R == R_130) { print "standard search containers rule"; return; } ! 107, case 1
		if (R == R_131) { print "standard search supporters rule"; return; } ! 108, case 1
		if (R == R_132) { print "report other people searching rule"; return; } ! 109, case 1
		if (R == R_133) { print "block consulting rule"; return; } ! 110, case 1
		if (R == R_134) { print "can't lock without a lock rule"; return; } ! 111, case 1
		if (R == R_135) { print "can't lock what's already locked rule"; return; } ! 112, case 1
		if (R == R_136) { print "can't lock what's open rule"; return; } ! 113, case 1
		if (R == R_137) { print "can't lock without the correct key rule"; return; } ! 114, case 1
		if (R == R_138) { print "standard locking rule"; return; } ! 115, case 1
		if (R == R_139) { print "standard report locking rule"; return; } ! 116, case 1
		if (R == R_140) { print "can't unlock without a lock rule"; return; } ! 117, case 1
		if (R == R_141) { print "can't unlock what's already unlocked rule"; return; } ! 118, case 1
		if (R == R_142) { print "can't unlock without the correct key rule"; return; } ! 119, case 1
		if (R == R_143) { print "standard unlocking rule"; return; } ! 120, case 1
		if (R == R_144) { print "standard report unlocking rule"; return; } ! 121, case 1
		if (R == R_145) { print "can't switch on unless switchable rule"; return; } ! 122, case 1
		if (R == R_146) { print "can't switch on what's already on rule"; return; } ! 123, case 1
		if (R == R_147) { print "standard switching on rule"; return; } ! 124, case 1
		if (R == R_148) { print "standard report switching on rule"; return; } ! 125, case 1
		if (R == R_149) { print "can't switch off unless switchable rule"; return; } ! 126, case 1
		if (R == R_150) { print "can't switch off what's already off rule"; return; } ! 127, case 1
		if (R == R_151) { print "standard switching off rule"; return; } ! 128, case 1
		if (R == R_152) { print "standard report switching off rule"; return; } ! 129, case 1
		if (R == R_153) { print "can't open unless openable rule"; return; } ! 130, case 1
		if (R == R_154) { print "can't open what's locked rule"; return; } ! 131, case 1
		if (R == R_155) { print "can't open what's already open rule"; return; } ! 132, case 1
		if (R == R_156) { print "standard opening rule"; return; } ! 133, case 1
		if (R == R_157) { print "reveal any newly visible interior rule"; return; } ! 134, case 1
		if (R == R_158) { print "standard report opening rule"; return; } ! 135, case 1
		if (R == R_159) { print "can't close unless openable rule"; return; } ! 136, case 1
		if (R == R_160) { print "can't close what's already closed rule"; return; } ! 137, case 1
		if (R == R_161) { print "standard closing rule"; return; } ! 138, case 1
		if (R == R_162) { print "standard report closing rule"; return; } ! 139, case 1
		if (R == R_163) { print "can't wear what's not clothing rule"; return; } ! 140, case 1
		if (R == R_164) { print "can't wear what's not held rule"; return; } ! 141, case 1
		if (R == R_165) { print "can't wear what's already worn rule"; return; } ! 142, case 1
		if (R == R_166) { print "standard wearing rule"; return; } ! 143, case 1
		if (R == R_167) { print "standard report wearing rule"; return; } ! 144, case 1
		if (R == R_168) { print "can't take off what's not worn rule"; return; } ! 145, case 1
		if (R == R_169) { print "standard taking off rule"; return; } ! 146, case 1
		if (R == R_170) { print "standard report taking off rule"; return; } ! 147, case 1
		if (R == R_171) { print "can't give what you haven't got rule"; return; } ! 148, case 1
		if (R == R_172) { print "can't give to yourself rule"; return; } ! 149, case 1
		if (R == R_173) { print "can't give to a non-person rule"; return; } ! 150, case 1
		if (R == R_174) { print "block giving rule"; return; } ! 151, case 1
		if (R == R_175) { print "standard giving rule"; return; } ! 152, case 1
		if (R == R_176) { print "standard report giving rule"; return; } ! 153, case 1
		if (R == R_177) { print "can't show what you haven't got rule"; return; } ! 154, case 1
		if (R == R_178) { print "convert show to yourself to examine rule"; return; } ! 155, case 1
		if (R == R_179) { print "block showing rule"; return; } ! 156, case 1
		if (R == R_180) { print "block waking rule"; return; } ! 157, case 1
		if (R == R_181) { print "implicitly remove thrown clothing rule"; return; } ! 158, case 1
		if (R == R_182) { print "futile to throw things at inanimate objects rule"; return; } ! 159, case 1
		if (R == R_183) { print "block throwing at rule"; return; } ! 160, case 1
		if (R == R_184) { print "block attacking rule"; return; } ! 161, case 1
		if (R == R_185) { print "kissing yourself rule"; return; } ! 162, case 1
		if (R == R_186) { print "block kissing rule"; return; } ! 163, case 1
		if (R == R_187) { print "block answering rule"; return; } ! 164, case 1
		if (R == R_188) { print "telling yourself rule"; return; } ! 165, case 1
		if (R == R_189) { print "block telling rule"; return; } ! 166, case 1
		if (R == R_190) { print "block asking rule"; return; } ! 167, case 1
		if (R == R_191) { print "asking yourself for something rule"; return; } ! 168, case 1
		if (R == R_192) { print "translate asking for to giving rule"; return; } ! 169, case 1
		if (R == R_193) { print "standard report waiting rule"; return; } ! 170, case 1
		if (R == R_194) { print "report touching yourself rule"; return; } ! 171, case 1
		if (R == R_195) { print "report touching other people rule"; return; } ! 172, case 1
		if (R == R_196) { print "report touching things rule"; return; } ! 173, case 1
		if (R == R_197) { print "can't wave what's not held rule"; return; } ! 174, case 1
		if (R == R_198) { print "report waving things rule"; return; } ! 175, case 1
		if (R == R_199) { print "can't pull what's fixed in place rule"; return; } ! 176, case 1
		if (R == R_200) { print "can't pull scenery rule"; return; } ! 177, case 1
		if (R == R_201) { print "can't pull people rule"; return; } ! 178, case 1
		if (R == R_202) { print "report pulling rule"; return; } ! 179, case 1
		if (R == R_203) { print "can't push what's fixed in place rule"; return; } ! 180, case 1
		if (R == R_204) { print "can't push scenery rule"; return; } ! 181, case 1
		if (R == R_205) { print "can't push people rule"; return; } ! 182, case 1
		if (R == R_206) { print "report pushing rule"; return; } ! 183, case 1
		if (R == R_207) { print "can't turn what's fixed in place rule"; return; } ! 184, case 1
		if (R == R_208) { print "can't turn scenery rule"; return; } ! 185, case 1
		if (R == R_209) { print "can't turn people rule"; return; } ! 186, case 1
		if (R == R_210) { print "report turning rule"; return; } ! 187, case 1
		if (R == R_211) { print "block pushing in directions rule"; return; } ! 188, case 1
		if (R == R_212) { print "innuendo about squeezing people rule"; return; } ! 189, case 1
		if (R == R_213) { print "report squeezing rule"; return; } ! 190, case 1
		if (R == R_214) { print "block saying yes rule"; return; } ! 191, case 1
		if (R == R_215) { print "block saying no rule"; return; } ! 192, case 1
		if (R == R_216) { print "block burning rule"; return; } ! 193, case 1
		if (R == R_217) { print "block waking up rule"; return; } ! 194, case 1
		if (R == R_218) { print "block thinking rule"; return; } ! 195, case 1
		if (R == R_219) { print "block smelling rule"; return; } ! 196, case 1
		if (R == R_220) { print "block listening rule"; return; } ! 197, case 1
		if (R == R_221) { print "block tasting rule"; return; } ! 198, case 1
		if (R == R_222) { print "block cutting rule"; return; } ! 199, case 1
		if (R == R_223) { print "block jumping rule"; return; } ! 200, case 1
		if (R == R_224) { print "block tying rule"; return; } ! 201, case 1
		if (R == R_225) { print "block drinking rule"; return; } ! 202, case 1
		if (R == R_226) { print "block saying sorry rule"; return; } ! 203, case 1
		if (R == R_227) { print "block swearing obscenely rule"; return; } ! 204, case 1
		if (R == R_228) { print "block swearing mildly rule"; return; } ! 205, case 1
		if (R == R_229) { print "block swinging rule"; return; } ! 206, case 1
		if (R == R_230) { print "block rubbing rule"; return; } ! 207, case 1
		if (R == R_231) { print "block setting it to rule"; return; } ! 208, case 1
		if (R == R_232) { print "block waving hands rule"; return; } ! 209, case 1
		if (R == R_233) { print "block buying rule"; return; } ! 210, case 1
		if (R == R_234) { print "block singing rule"; return; } ! 211, case 1
		if (R == R_235) { print "block climbing rule"; return; } ! 212, case 1
		if (R == R_236) { print "block sleeping rule"; return; } ! 213, case 1
		if (R == R_237) { print "ambient odour rule"; return; } ! 214, case 1
		if (R == R_238) { print "ambient sound rule"; return; } ! 215, case 1
		if (R == R_239) { print "block vaguely going rule"; return; } ! 216, case 1
		if (R == ScoreSub_O1) { print "announce the score rule"; return; } ! 528, case 1
		if (R == QuitSub_O1) { print "quit the game rule"; return; } ! 532, case 1
		if (R == SaveSub_O1) { print "save the game rule"; return; } ! 536, case 1
		if (R == RestoreSub_O1) { print "restore the game rule"; return; } ! 540, case 1
		if (R == RestartSub_O1) { print "restart the game rule"; return; } ! 544, case 1
		if (R == VerifySub_O1) { print "verify the story file rule"; return; } ! 548, case 1
		if (R == VersionSub_O1) { print "announce the story file version rule"; return; } ! 552, case 1
		if (R == ScriptOnSub_O1) { print "switch the story transcript on rule"; return; } ! 556, case 1
		if (R == ScriptOffSub_O1) { print "switch the story transcript off rule"; return; } ! 560, case 1
		if (R == LMode3Sub_O1) { print "prefer abbreviated room descriptions rule"; return; } ! 564, case 1
		if (R == LMode2Sub_O1) { print "prefer unabbreviated room descriptions rule"; return; } ! 568, case 1
		if (R == LMode1Sub_O1) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 572, case 1
		if (R == PronounsSub_O1) { print "announce the pronoun meanings rule"; return; } ! 576, case 1
		if (R == NotifyOnSub_O1) { print "switch score notification on rule"; return; } ! 580, case 1
		if (R == NotifyOffSub_O1) { print "switch score notification off rule"; return; } ! 584, case 1
		if (R == I7_DO_NOTHING) { print "little-used do nothing rule"; return; } ! 585, case 1
		if (R == TS1_R) { print "advance time rule"; return; } ! 586, case 1
		if (R == TS4_R) { print "update chronological records rule"; return; } ! 587, case 1
		if (R == TS5_R) { print "adjust light rule"; return; } ! 588, case 1
		if (R == TS6_R) { print "note object acquisitions rule"; return; } ! 589, case 1
		if (R == ProcessI7Timers) { print "timed events rule"; return; } ! 590, case 1
		if (R == I7ResetChooseObjects) { print "reset parser disambiguation rule"; return; } ! 591, case 1
		if (R == I7_NPCA) { print "non-player character action rule"; return; } ! 592, case 1
		if (R == OIU_Scoped) { print "access to scoped objects rule"; return; } ! 593, case 1
		if (R == OIU_Barrier) { print "access through barriers rule"; return; } ! 594, case 1
		if (R == OIUB_CCI) { print "can't reach inside closed containers rule"; return; } ! 595, case 1
		if (R == OIUB_CCO) { print "can't reach outside closed containers rule"; return; } ! 596, case 1
		if (R == OIUB_RI) { print "can't reach inside rooms rule"; return; } ! 597, case 1
		if (R == PA_R) { print "basic accessibility rule"; return; } ! 598, case 1
		if (R == CR_R) { print "carrying requirements rule"; return; } ! 599, case 1
		if (R == CSITDR) { print "can't act in the dark rule"; return; } ! 600, case 1
		if (R == OBIT_HEAD) { print "print obituary headline rule"; return; } ! 601, case 1
		if (R == OBIT_FINAL) { print "print final score rule"; return; } ! 602, case 1
		if (R == OBIT_DISP) { print "display final status line rule"; return; } ! 603, case 1
		if (R == R_9) { print "first when play begins rule"; return; } ! 604, case 2
		if (R == R_10) { print "A first turn sequence rule"; return; } ! 605, case 2
		if (R == R_11) { print "A first turn sequence rule"; return; } ! 606, case 2
		if (R == R_12) { print "A last turn sequence rule"; return; } ! 607, case 2
		if (R == R_13) { print "last scene changing rule"; return; } ! 608, case 2
		if (R == R_15) { print "last before rule"; return; } ! 609, case 2
		if (R == R_16) { print "first after rule"; return; } ! 610, case 2
		if (R == R_17) { print "first action-processing rule"; return; } ! 611, case 2
		if (R == R_18) { print "A last action-processing rule"; return; } ! 612, case 2
		if (R == R_19) { print "A last action-processing rule"; return; } ! 613, case 2
		if (R == R_20) { print "A last action-processing rule"; return; } ! 614, case 2
		if (R == R_21) { print "A last action-processing rule"; return; } ! 615, case 2
		if (R == R_22) { print "last action-specific rule"; return; } ! 616, case 2
		if (R == R_101) { print "Setting action variables for exiting"; return; } ! 617, case 2
		if (R == R_649) { print "After taking the idol"; return; } ! 618, case 2
		if (R == I7ResetChooseObjects) { print "reset parser disambiguation rule"; return; } ! 619, case 1
		if (R == ProcessI7Timers) { print "timed events rule"; return; } ! 620, case 1
		if (R == TS1_R) { print "advance time rule"; return; } ! 621, case 1
		if (R == TS4_R) { print "update chronological records rule"; return; } ! 622, case 1
		if (R == TS5_R) { print "adjust light rule"; return; } ! 623, case 1
		if (R == TS6_R) { print "note object acquisitions rule"; return; } ! 624, case 1
		if (R == OIU_Scoped) { print "access to scoped objects rule"; return; } ! 625, case 1
		if (R == OIU_Barrier) { print "access through barriers rule"; return; } ! 626, case 1
		if (R == OIUB_RI) { print "can't reach inside rooms rule"; return; } ! 627, case 1
		if (R == OIUB_CCI) { print "can't reach inside closed containers rule"; return; } ! 628, case 1
		if (R == OIUB_CCO) { print "can't reach outside closed containers rule"; return; } ! 629, case 1
		if (R == CSITDR) { print "can't act in the dark rule"; return; } ! 630, case 1
		if (R == PA_R) { print "basic accessibility rule"; return; } ! 631, case 1
		if (R == CR_R) { print "carrying requirements rule"; return; } ! 632, case 1
		if (R == OBIT_HEAD) { print "print obituary headline rule"; return; } ! 633, case 1
		if (R == OBIT_FINAL) { print "print final score rule"; return; } ! 634, case 1
		if (R == OBIT_DISP) { print "display final status line rule"; return; } ! 635, case 1
		if (R == R_34) { print "can't take component parts rule"; return; } ! 636, case 1

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<353)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];

[ DebugRulebooks subs par i;
	spaces(2*process_rulebook_count);
	print "[", (I7_RulePrintingRule) subs;
	if (par) print " / on O", par;
	print "]^";
];

! (vii) Used from calls compiled in to NI-generated rules, printing a trace
! of which rules are executed:

[ DB_Rule R blocked;
	if (R==0) return;
	print "@31[Rule ~", (I7_RulePrintingRule) R, "~ ";
	if (blocked == false) "applies.]";
	"does not apply.]";
];

! (viii) This the default value for the kind of value 'rule':

[ I7_DO_NOTHING; rfalse; ];

! End of Rulebooks.i6

! Actions.i6

[ _I6_ActionPrimitive;
	#ifdef TARGET_ZCODE;
	indirect(#actions_table-->action);
	#ifnot;
	indirect(#actions_table-->(action+1));
	#endif;
];

[ BeginActionProcessing;
	BeginFollowRulebook();
];
[ EndActionProcessing;
	EndFollowRulebook();
];

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	if (act == -1) return (((bitmap->0) & 1) ~= 0); 
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];
[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];

Global trace_actions = 0;
[ ActionsOnSub; trace_actions = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; "Actions listing off."; ];
[ ActionPrimitive sa sn rv p1 p2 p3 p4 p5 frame_id; ! 
	sa = action; sn = noun;
	self = noun;

	MStack_CreateRBVars(APROC_RB);

	if ((keep_silent == false) && (multiflag == false)) I7_DivideParagraph();
	I7_action_deciding_rule = 0;

	if (action == ##Consult or ##Ask or ##Tell or ##NotUnderstood or ##Answer) {
		inp2 = 1; second = consult_from + 256*consult_words;
		parsed_number = 100*consult_from + consult_words;
	}

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+9))) {
		frame_id = ActionData-->(p1+10);
		Mstack_Create_Frame(ActionData-->(p1+9), frame_id);
	}
	if (I7_VerifyNouns()) {
		if (frame_id ~= -1)
			Mstack_Destroy_Frame(ActionData-->(p1+9), frame_id);
		MStack_DestroyRBVars(APROC_RB);
		return;
	}

	ProcessRulebook(SETACTIONVARS_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^";
	}
	SetString31(++debug_rule_nesting);
	#ENDIF;
	TrackActions();
	BeginActionProcessing();
	if (meta) { _I6_ActionPrimitive(); say__p = 1; }
	else ProcessRulebook(APROC_RB);
	rv = rulechange_stack-->rulechange_sp;
	#IFDEF DEBUG;
	SetString31(--debug_rule_nesting);
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF I7_ECONOMY;
				if (I7_action_deciding_rule)
					print " the ",
						(I7_RulePrintingRule) I7_action_deciding_rule;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^";
		rulechange_stack-->rulechange_sp = rv; ! In case disturbed by activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) {
		SetActionBitmap(noun, action);
		if (action == ##Go) SetActionBitmap(location, ##Enter);
	}
	EndActionProcessing();
	if (frame_id ~= -1) {
		p1 = FindAction(action);
		Mstack_Destroy_Frame(ActionData-->(p1+9), frame_id);
	}
	MStack_DestroyRBVars(APROC_RB);
	action = sa; noun = sn;
	TrackActions(1);
	if ((keep_silent == false) && (multiflag == false)) I7_DivideParagraph();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];

[ DA_Name n; if (n ofclass K3_direction) print (name) n; else print (the) n; ];
[ DA_Topic x a b c d i cf cw;
	cw = x/256; cf = x%256;
	print "~";
	for (a=cf:d<cw:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<cw-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ DA_TruthState n; if (n==0) print "false"; else print "true"; ];
[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t+11;
	}
	rfalse;
];
[ DB_Action ac acr act n s for_say t l j v c clc;
	if ((for_say == 0) && (debug_rule_nesting > 0))
		print "(", debug_rule_nesting, ") ";
	if ((ac ~= player) && (for_say ~= 2)) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " ";
	}
	t = 1;
	while (t <= ActionData-->0) {
		if (act == ActionData-->t) {
			l = t+9; t = t+4;
			while ((v = ActionData-->t) ~= I6_NULL) {
				if (v ofclass Routine) {
					if (for_say == 2) {
						if (ActionData-->(t+1) ~= I6_NULL) {
							if (clc++ > 0) print " ";
							print "it";
						}
					} else {
						if (clc++ > 0) print " ";
						if (c==0) { (v)(n); }
						else { (v)(s); }
						c++;
					}
				} else {
					if (clc++ > 0) print " ";
					print (string) v;
				}
				t++;
				if (t == l) break;
			}
			if ((keep_silent) && (for_say == 0)) print " - silently";
			return;
		}
		t = t+11;
	}
];
[ I7_SayActionName act;
	DB_Action(0, 0, act, 0, 0, 2);
];
[ I7_TryAction req by ac n s stora tbits saved_command text_of_command;
	if (stora) return I7_new_STORED_ACTION_TY(ac, n, s, by, req, stora);
	tbits = req & (16+32);
	req = req & 1;
	@push actor; @push act_requester; @push inp1; @push inp2; @push parsed_number;
	actor = by; if (req) act_requester = player; else act_requester = 0;
!  print inp1, inp2, "^";
	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+2) == I7_OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+3) == I7_OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
		if (((ActionData-->(by+2) == UNDERSTANDING_TY) ||
			(ActionData-->(by+3) == UNDERSTANDING_TY)) && (tbits)) {
			!print "saving...^";
			saved_command = I7_INDEXED_TEXT_TY_Create();
			I7_INDEXED_TEXT_TY_Cast(I7_command, SNIPPET_TY, saved_command);
			text_of_command = I7_INDEXED_TEXT_TY_Create();
			I7_INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			!I7_INDEXED_TEXT_TY_Say(text_of_command); print "...^";
			I7_IT_SetPlayersCommand(text_of_command);
			if (tbits == 16) {
				n = I7_command; inp1 = 1; parsed_number = I7_command;
			} else {
				s = I7_command; inp2 = 1; parsed_number = I7_command;
			}
			I7_Blk_Free(text_of_command);
			@push consult_from;
			@push consult_words;
			consult_from = 1;
			consult_words = parsed_number - 100;
		}
	}
!  print "Made by ITA: ", inp1, inp2, "^";
	InformLibrary.begin_action(ac, n, s);
!  <(ac) n s>;
!  print inp1, inp2, "^";
	if (saved_command) {
		@pull consult_words;
		@pull consult_from;
		I7_IT_SetPlayersCommand(saved_command);
		I7_Blk_Free(saved_command);
	}
	@pull parsed_number; @pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(1);
];

[ I7_NPCA s;
	if ((actor == player) || (act_requester == nothing)) rfalse;
	s = say__p; say__p = FALSE; ProcessRulebook(PERSUADE_RB);
	if (rulechange_stack-->rulechange_sp ~= RS_SUCCEEDS) {
		if (say__p == FALSE) L__M(##Order, 1, actor);
		RulebookFails(); rtrue;
	}
	say__p = s; rfalse;
];

[ I7_VerifyNouns mask noun_kova second_kova at;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+1); noun_kova = ActionData-->(at+2);
!print "at = ", at, " nst = ", noun_kova, "^";
!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
!print "inp1 = ", inp1, " noun = ", noun, "^";
!print "inp2 = ", inp2, " second = ", second, "^";
	if (mask & $$100000) { meta = 1; rfalse; }
	second_kova = ActionData-->(at+3);
!print "sst = ", second_kova, "^";
	if (noun_kova == 59 or 74) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = consult_from + 256*consult_words;
	}
	if (second_kova == 59 or 74) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = consult_from + 256*consult_words;
	}
	if (inp1 == 1) {
	    if (noun_kova == 61) {
	        "You must name an object.^"; }
	} else {
	    if (noun_kova ~= 61) {
	        "You may not name an object.^"; }
	    if ((mask & $$01000) && (noun == nothing)) {
	        CarryOutActivity(6); if (noun == nothing) {
	        if (say__p) rtrue;
	        "You must supply a noun.^"; } }
	    if (((mask & $$01000) == 0) && (noun ~= nothing)) {
	        "You may not supply a noun.^"; }
	}
	if (inp2 == 1) {
	    if (second_kova == 61) {
	        "You must name an object.^"; }
	} else {
	    if (second_kova ~= 61) {
	        "You may not name a second object.^"; }
	    if ((mask & $$10000) && (second == nothing)) {
	        CarryOutActivity(7); if (second == nothing) {
	        if (say__p) rtrue;
	        "You must supply a second noun.^"; } }
	    if (((mask & $$10000) == 0) && (second ~= nothing)) {
	        "You may not supply a second noun.^"; }
	}
	rfalse;
];

[ I7_TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+1); 
	if (mask & match) rtrue; 
	rfalse; 
];
[ I7_NeedToCarryNoun; return I7_TestActionMask($$01000000); ];
[ I7_NeedToCarrySecondNoun; return I7_TestActionMask($$10000000); ];
[ I7_NeedToTouchNoun; return I7_TestActionMask($$00001); ];
[ I7_NeedToTouchSecondNoun; return I7_TestActionMask($$00010); ];
[ I7_NeedLightForAction; return I7_TestActionMask($$00100); ];

[ I7_ImplicitTake obj ks;
	ks = keep_silent; keep_silent = true;
	print "(";
	if (actor ~= player) print (the) actor, " ";
	print "first taking ", (the) obj, ")^"; say__p = 0;
	I7_TryAction(true, actor, ##Take, obj, nothing);
	keep_silent = ks;
	if (obj in actor) rtrue;
	rfalse;
];

! The can't see in the dark rule

[ CSITDR; if (location == thedark) { RulebookSucceeds(); rtrue; } rfalse; ];

! The primitive accessibility rule

[ PA_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+1);

	! print "actor = ", (the) actor, "inp1 = ", inp1, "; inp2 = ", inp2, "^";
	! print "Mask is ", mask, "^";

	if ((mask & $$00100) &&
		(actor == player) &&
		(ProcessRulebook(VISIBLE_RB)) &&
		((rulechange_stack-->rulechange_sp == RS_SUCCEEDS))) {
		BeginActivity(TOODARK_ACT);
		if (ForActivity(TOODARK_ACT)==false) L__M(##Miscellany, 17);
		EndActivity(TOODARK_ACT);
		I7_action_deciding_rule = CSITDR;
		RulebookFails();
		rtrue;
	}

	if ((mask & $$00001) && noun && (inp1 ~= 1)) {
		if (noun in compass) {
			RulebookFails();
			I7_action_deciding_rule = PA_R; 
			if (actor~=player) rtrue;
			"You must name something more substantial.^";
		}
		if (ObjectIsUntouchable(noun, (actor~=player), FALSE, actor)) {
			RulebookFails();
			I7_action_deciding_rule = PA_R;
			rtrue;
		}
	}

	if ((mask & $$00010) && second && (inp2 ~= 1)) {
		if (second in compass) {
			RulebookFails();
			I7_action_deciding_rule = PA_R;
			if (actor~=player) rtrue;
			"You must name something more substantial.^";
		}
		if (ObjectIsUntouchable(second, (actor~=player), FALSE, actor)) {
			RulebookFails();
			I7_action_deciding_rule = PA_R;
			rtrue;
		}
	}
	rfalse;
];

[ CR_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+1);

	if ((mask & $$00001) && noun && (inp1 ~= 1)) {
		if ((mask & $$01000000) && (noun notin actor)) {
			BeginActivity(IMPLICITTAKE_ACT, noun);
            if (ForActivity(IMPLICITTAKE_ACT, noun)==false)
            	I7_ImplicitTake(noun);
            EndActivity(IMPLICITTAKE_ACT, noun);
			if (noun notin actor) {
				RulebookFails();
				I7_action_deciding_rule = CR_R;
				rtrue;
			}
		}
	}

	if ((mask & $$00010) && second && (inp2 ~= 1)) {
		if ((mask & $$10000000) && (second notin actor)) {
			BeginActivity(IMPLICITTAKE_ACT, second);
            if (ForActivity(IMPLICITTAKE_ACT, second)==false)
            	I7_ImplicitTake(second);
            EndActivity(IMPLICITTAKE_ACT, second);
			if (second notin actor) {
				RulebookFails();
				I7_action_deciding_rule = CR_R;
				rtrue;
			}
		}
	}
	rfalse;
];

[ I7_SnippetMatches snip top;
	wn=1;
	if (top == 0) rfalse;
	if (metaclass(top) == Routine) {
		if ((top)(snip/100, snip%100)~=GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];

! End of Actions.i6

! Activities.i6 segment

Global activities_sp = 0;
Array activities_stack --> 25;
Array activities_ostack --> 25;
Global inhibit_flag = 0;
Global inhibit_dr = 0;
[ FixInhibitFlag n i_f;
	for (n=0:n<activities_sp:n++)
		if (activities_stack-->n <= 4) i_f = true;
	if ((inhibit_flag == false) && (i_f)) {
		inhibit_dr = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (i_f == false)) {
		debug_rules = inhibit_dr;
	}
	inhibit_flag = i_f;
];
[ BeginActivity A o x;
!	print "Begin ", A, "^";
	if (activities_sp == 25) return RunTimeProblem(RTP_TOOMANYACTS);
	activities_ostack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = FollowRulebookSelfed(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];
[ ForActivity A o x;
!	print "For ", A, "^";
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = FollowRulebookSelfed(Activity_when_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];
[ EndActivity A o rv x;
!	print "End ", A, "^";
	if (activities_sp == 0) jump BadEnd;
	if (activities_stack-->(activities_sp-1) == A) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = FollowRulebookSelfed(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
!		print "Ended^";
		MStack_DestroyAVVars(A);
		return rv;
	}
	.BadEnd; return RunTimeProblem(RTP_CANTABANDON);
];
[ AbandonActivity A o;
	if (activities_sp == 0) jump BadEnd;
	if (activities_stack-->(activities_sp-1) == A) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	.BadEnd; return RunTimeProblem(RTP_CANTEND);
];
[ CarryOutActivity A o rv;
	BeginActivity(A,o); rv = ForActivity(A,o); EndActivity(A,o); return rv; ];
[ TestActivity A Pattern i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (Pattern == false) rtrue;
			if ((Pattern)(activities_ostack-->i)) rtrue;
		}
	rfalse;
];
[ I7_Amusing_Provided x;
	x = Activity_when_rulebooks-->AMUSING_ACT;
	if (((rulebooks_array-->x)-->0) == I6_NULL)
		rfalse;
	rtrue;
];

[ I7SpotPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		! print "I: ", i, " ", w->#dict_par1, "^";
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];

! End of Activities.i6

! Relations.i6 segment

[ I7_Now1to1 obj1 rel obj2 ol;
	if (obj2) objectloop (ol provides rel)
		if (ol.rel == obj2) ol.rel = nothing;
	if (obj1) obj1.rel = obj2;
];
[ I7_NowN1toV obj1 rel obj2;
	if (obj1.rel == obj2) obj1.rel = nothing;
];
[ I7_NowS1to1 obj1 rel obj2 ol;
	if (obj1 ofclass Object && obj2 ofclass Object &&
		obj1 provides rel && obj2 provides rel) {
		if (obj1.rel) { (obj1.rel).rel = 0; }
		if (obj2.rel) { (obj2.rel).rel = 0; }
		obj1.rel = obj2; obj2.rel = obj1;
	}
];
[ I7_NowSN1to1 obj1 rel obj2 ol;
	if (obj1 ofclass Object && obj2 ofclass Object &&
		obj1 provides rel && obj2 provides rel) {
		if (obj1.rel == obj2) { obj1.rel = 0; obj2.rel = 0; }
	}
];
[ I7_NowVtoV obj1 bp_id obj2 sym pr pr2 i1 i2;
!  I7_ShowVtoV(bp_id);
	if (sym && (obj2 ~= obj1)) { I7_NowVtoV(obj2, bp_id, obj1, false); }
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	if (pr) {
		if ((obj1 ofclass Object) && pr && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, bp_id, 0);
	} else i1 = obj1-1;
	if (pr2) {
 	 if ((obj2 ofclass Object) && pr2 && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, bp_id, 0);
	} else i2 = obj2-1;
!  print "Setting relation", "(", i1, ",", i2, ")^";
	pr = i1*(bp_id-->3) + i2; i1 = 1; i2 = pr%16; while (i2) { i2--; i1=i1*2; }
	pr = pr/16 + 6;
	bp_id-->pr = (bp_id-->pr) | i1;
];
[ I7_NowNVtoV obj1 bp_id obj2 sym pr pr2 i1 i2;
!  I7_ShowVtoV(bp_id);
!  if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (sym && (obj2 ~= obj1)) { I7_NowNVtoV(obj2, bp_id, obj1, false); }
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	if (pr) {
		if ((obj1 ofclass Object) && pr && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, bp_id, 0);
	} else i1 = obj1-1;
	if (pr2) {
 	 if ((obj2 ofclass Object) && pr2 && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, bp_id, 0);
	} else i2 = obj2-1;
!  print "Clearing relation", "(", i1, ",", i2, ")^";
	pr = i1*(bp_id-->3) + i2; i1 = 1; i2 = pr%16; while (i2) { i2--; i1=i1*2; }
	pr = pr/16 + 6;
	if ((bp_id-->pr) & i1) bp_id-->pr = bp_id-->pr - i1;
];
[ I7_NowEquiv obj1 prop obj2 big little;
	big = obj1.prop; little = obj2.prop;
	if (big == little) return;
	if (big < little) { little = obj1.prop; big = obj2.prop; }
	objectloop (obj1 provides prop)
		if (obj1.prop == big) obj1.prop = little;
];
[ I7_NowNEquiv obj1 prop obj2 old new;
	old = obj1.prop; new = obj2.prop;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides prop)
		if (obj2.prop > new) new = obj2.prop;
	new++;
	obj1.prop = new;
];
[ I7_TestVtoV obj1 bp_id obj2 sym pr pr2 i1 i2;
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && pr && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, bp_id, 0); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
 	 if ((obj2 ofclass Object) && pr2 && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, bp_id, 0); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(bp_id-->3) + i2; i1 = 1; i2 = pr%16; while (i2) { i2--; i1=i1*2; }
	pr = pr/16 + 6;
	if ((bp_id-->pr) & i1) rtrue; rfalse;
];
[ I7_ShowVtoV bp_id sym x obj1 obj2 pr pr2 proutine1 proutine2;
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	proutine1 = bp_id-->4;
	proutine2 = bp_id-->5;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (I7_TestVtoV(obj1, bp_id, obj2)) {
					if (x) { I7_ShowRHeader(x); x=0; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=bp_id-->3:obj2++) {
				if (I7_TestVtoV(obj1, bp_id, obj2)) {
					if (x) { I7_ShowRHeader(x); x=0; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=bp_id-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (I7_TestVtoV(obj1, bp_id, obj2)) {
					if (x) { I7_ShowRHeader(x); x=0; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=bp_id-->2:obj1++)
		  for (obj2=1:obj2<=bp_id-->3:obj2++)
			if (I7_TestVtoV(obj1, bp_id, obj2)) {
				if (x) { I7_ShowRHeader(x); x=0; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];
[ I7_ShowOtoO pr sym x obj1 obj2;
	objectloop (obj1 provides pr) {
			obj2 = obj1.pr;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
		if (x) { I7_ShowRHeader(x); x=0; }
		print "  ", (The) obj1;
		if (sym) print "  ==  "; else print "  >=>  ";
		print (the) obj2, "^";
	}
];
[ I7_RShowOtoO pr sym x obj1 obj2;
	objectloop (obj1) {
		objectloop (obj2 provides pr) {
			if (obj2.pr ~= obj1) continue;
			if (x) { I7_ShowRHeader(x); x=0; }
			print "  ", (The) obj1;
			print "  >=>  ";
			print (the) obj2, "^";
		}
	}
];
[ I7_ShowEquiv pr obj1 obj2 v c somegroups;
!	objectloop (obj1 provides pr) print (name) obj1, " ", obj1.pr, "^";
	objectloop (obj1 provides pr) obj1.pr = -(obj1.pr);
	objectloop (obj1 provides pr) {
		if (obj1.pr < 0) {
			v = obj1.pr; c = 0;
			objectloop (obj2 has i7listflag) give obj2 ~i7listflag;
			objectloop (obj2 provides pr) {
				if (obj2.pr == v) {
					give obj2 i7listflag;
					obj2.pr = -v;
					c++;
				}
			}
			if (c>1) {
				somegroups = true;
				print "  { ";
				I7List(0);
				print " }^";
			} else obj1.pr = v;
		}
	}
	objectloop (obj2 has i7listflag) give obj2 ~i7listflag;
	c = 0; objectloop (obj1 provides pr) if (obj1.pr < 0) { c++; give obj1 i7listflag; }
	if (c == 0) return;
	if (somegroups) print "  and "; else print "  ";
	if (c < 4) { I7List(0); print " in"; }
	else print c;
	if (c == 1) print " a";
	print " single-member group";
	if (c > 1) print "s";
	print "^";
	objectloop (obj1 provides pr) if (obj1.pr < 0) obj1.pr = -(obj1.pr);
];

[ I7_ShowRHeader x rel_type;
	rel_type = RelationList-->(x+1);
	print (string) RelationList-->(x+2);
	if (rel_type == Relation_ByRoutine) ".";
	print ":^";
];

[ I7_ShowR rel_num rel_type x;
	x = rel_num*3;
	rel_type = RelationList-->(x+1);
	if (rel_type == Relation_Implicit) return;
	if (rel_type == Relation_ByRoutine) { I7_ShowRHeader(x); return; }
	switch(rel_type) {
		Relation_OtoO: I7_RShowOtoO(RelationList-->x, false, x); break;
		Relation_OtoV: I7_RShowOtoO(RelationList-->x, false, x); break;
		Relation_VtoO: I7_ShowOtoO(RelationList-->x, false, x); break;
		Relation_VtoV: I7_ShowVtoV(RelationList-->x, false, x); break;
		Relation_Sym_OtoO: I7_ShowOtoO(RelationList-->x, true, x); break;
		Relation_Sym_VtoV: I7_ShowVtoV(RelationList-->x, true, x); break;
		Relation_Equiv: I7_ShowRHeader(x); I7_ShowEquiv(RelationList-->x); break;
		Relation_ByRoutine: break;
	}
];

#ifdef TARGET_ZCODE;
Constant I7_ROUTE_HIGH_BIT = $8000;
#ifnot;
! This will fail if any object numbers (addresses) are past the 2 GB boundary.
Constant I7_ROUTE_HIGH_BIT = $80000000;
#endif;
[ I7_RouteTo from to filter use_doors obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj ofclass K1_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj && (obj ofclass K1_room) && ((filter == 0) || (filter(obj))))
			if (obj.vector == 0)
				objectloop (dir in compass)
					if (obj provides (dir.door_dir)) {
						in_direction = obj.(dir.door_dir);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction ofclass K1_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | I7_ROUTE_HIGH_BIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door ofclass K1_room) && (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | I7_ROUTE_HIGH_BIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj ofclass K1_room)
			obj.vector = obj.vector &~ I7_ROUTE_HIGH_BIT;
		if (progressed == false) return from.vector;
	}
];
[ I7_CountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from ofclass K1_room && to ofclass K1_room) {
		obj = I7_RouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<1000)) { i++; obj = I7_RoomFrom(obj,obj.vector); }
		return i;
	}
	return -1;
];
[ I7_RelRouteTo relprop from to obj obj2 in_direction relkind progressed pr pr2;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if (relprop == 0) return nothing;
	relkind = RelationList-->(3*relprop+1);
	if (relkind == Relation_ByRoutine or Relation_Implicit) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	relprop = RelationList-->(3*relprop);
	if (relprop == 0) return nothing;
! print "Rel kind is ", relkind, "^";
	if (relkind == Relation_VtoO) {
		objectloop (obj ofclass Object && obj provides relprop) obj.vector = 0;
		to.vector = 1;
		while (true) {
			progressed = false;
			objectloop (obj ofclass Object && obj provides relprop)
				if (obj.vector == 0) {
					in_direction = obj.relprop;
					if ((in_direction ofclass Object && in_direction provides relprop)
						&& (in_direction.vector > 0)) {
						obj.vector = in_direction | I7_ROUTE_HIGH_BIT;
						progressed = true;
						continue;
					}
				}
			objectloop (obj ofclass Object && obj provides relprop)
				obj.vector = obj.vector &~ I7_ROUTE_HIGH_BIT;
			if (progressed == false) return from.vector;
		}
	}
	if (relkind == Relation_OtoV) {
		while ((to ~= nothing) && (to provides relprop) && (to.relprop)) {
			!print "to = ", (name) to, " --> ", (name) to.relprop, "^";
			(to.relprop).vector = to;
			if (to.relprop == from) return to;
			to = to.relprop;
		}
		return nothing;
	}
	pr = relprop-->0;
	pr2 = relprop-->1;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides pr)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (I7_TestVtoV(obj, relprop, obj2)) {
						obj.vector = obj2 | I7_ROUTE_HIGH_BIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides vector)
			obj.vector = obj.vector &~ I7_ROUTE_HIGH_BIT;
		if (progressed == false) return from.vector;
	}
];
[ I7_CountRelRouteTo relprop from to obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	i = 0; obj = from;
	if (I7_RelRouteTo(relprop,from,to) == nothing) return -1;
	while ((obj ~= to) && (i<1000)) { i++; obj = obj.vector; }
	return i;
];

! End of Relations.i6

! WorldModel.i6 segment


! Replaced from the I6 library:

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;
[ ObjectIsUntouchable item silent_flag flag2 p save_sp;
	untouchable_object = item; untouchable_silence = silent_flag;
	touch_persona = p; if (p == actor) touch_persona = 0;
	if ((actor ~= player) &&
		((item ofclass K4_door) || (item ofclass K7_backdrop))) {
		untouchable_silence = 0;
		rfalse;
	}
	save_sp = say__p; say__p = 0;
	if (ProcessRulebook(ACCESS_RB, 0, 1)) {
		if (say__p) save_sp = true; else say__p = save_sp;
		if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) {
			untouchable_silence = 0;
 			rfalse; ! No barrier
		} else {
			untouchable_silence = 0;
 			rtrue; ! Barrier
		}
	}
	if (say__p) save_sp = true; else say__p = save_sp;
	! No decision is interpreted as no barrier to access:
	untouchable_silence = 0;
	rfalse;
];

[ OIU_Scoped i o;
!  i = ObjectScopedBySomething(untouchable_object);
!  if (i ~= 0) {
!		o = parameter_object;
!		if (ObjectIsUntouchable(i, 0, 0, touch_persona)) rtrue;
!		parameter_object = i;
!		return OIUB_CP();
!  }
	rfalse;
];

[ OIU_Core o;
	while (o && (o provides component_parent) && (o.component_parent))
		o = o.component_parent;
	return o;
];

[ OIU_Parent o;
	return OIU_Core(parent(OIU_Core(o)));
];

[ OIU_Location o;
	while (o) {
		if (o ofclass K1_room) return o;
		o = OIU_Core(parent(OIU_Core(o)));
	}
	return nothing;
];

[ OIU_CommonAncestor o1 o2 i j;
	!  Find the nearest object indirectly containing o1 and o2,
	!  or return 0 if there is no common ancestor.

	o1 = OIU_Core(o1);
	o2 = OIU_Core(o2);
	i = o1;
	while (i ~= 0) {
		j = o2;
		while (j ~= 0) {
			if (j == i) return i;
			j = OIU_Parent(j);
		}
	  i = OIU_Parent(i);
	}
	return 0;
];

[ OIU_Barrier ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = OIU_CommonAncestor(p, untouchable_object);
	if ((ancestor == 0) && (OIU_Location(untouchable_object) == nothing)
		&& ((untouchable_object ofclass K4_door or K7_backdrop) == false)) {
		if (touch_persona == 0) GL__M(##Take,8,untouchable_object);
		RulebookFails();
		rtrue;
	}
!  print "Doing OIU barriers for ", (the) p, " and ", (the) untouchable_object,
!		": common ancestor is ", (the) ancestor, ".^";

	! First, a barrier between the player and the ancestor.

	if (OIU_Core(p) ~= ancestor) {
		i = parent(OIU_Core(p)); j = OIU_Core(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false) && (ProcessRulebook(REACHOUT_RB, i))
			  && (rulechange_stack-->rulechange_sp == RS_FAILS)) rtrue; ! Barrier
			i = parent(OIU_Core(i)); j = OIU_Core(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (OIU_Core(untouchable_object) ~= ancestor) {
		i = parent(OIU_Core(untouchable_object)); j = OIU_Core(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false) && (ProcessRulebook(REACHIN_RB, i))
			  && (rulechange_stack-->rulechange_sp == RS_FAILS)) rtrue; ! Barrier
			i = parent(OIU_Core(i)); j = OIU_Core(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];

[ OIUB_CCI;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ OIUB_CCO;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ OIUB_RI;
! print parameter_object, "=", (the) parameter_object, "^";
	if (parameter_object && parameter_object ofclass K1_room) {
		if (touch_persona == 0) GL__M(##Take,14,parameter_object);
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ OIUB_CP;
	if ((noun provides component_parent) && (noun.component_parent)) {
!	  if (noun.component_parent has transparent)
			return GL__M(##Take,7,noun.component_parent);
	  return GL__M(##Take,8,noun.component_parent);
	}
	rfalse;
];



[ I7_parent o; if (o==0) return 0; return parent(o); ];

[ I7_WhetherIn obj;
	if (obj has enterable) {
		if (I7_IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return I7_In(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];
[ I7_PlayerTo X opt sa;
	sa = actor; actor = player; PlayerTo(X, opt); actor = sa;
];
[ I7_RoomOf p;
	while(p) {
		if (p ofclass K1_room) return p;
		if (parent(p)) { p = parent(p); continue; }
		if (p.component_parent) { p = p.component_parent; continue; }
		return nothing;
	}
	return nothing;
];
[ I7_ReckonLight R S df;
	df = OffersLight(S);
	if (df~=0) { location=S; real_location=S; lightflag=1; }
	else
	{   if (R == thedark)
		{   DarkToDark();
			if (deadflag~=0) rtrue;
		}
		real_location=S;
		location=thedark; lightflag=0;
	}
	rfalse;
];
[ I7_NoticeHeld x;
#IFNDEF MANUAL_PRONOUNS;
	objectloop(x in player) PronounNotice(x);
#ENDIF;
	x = 0; ! To prevent a "not used" error
	rfalse;
];
[ I7_RoomDescriptionForGoing;
	if (say__pc & PARA_COMPLETED == 0) new_line;
	LookSub_P(1);
];
[ I7_SurreptitiousMove F T; ! Used _only_ in one going rule: breaks world model rules
	if (F == player) move F to T; else I7_Move(F, T, 0, 0, 1);
	if (actor == player) location = T;
];
[ I7_Move F T opt ln going_mode was;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (I7_In(I7_RoomOf(player), T)) move F to I7_RoomOf(player); else remove F;
			return; }
		return RunTimeProblem(RTP_BACKDROP, F, T, ln);
	}
	if (T ofclass K9_region) {
		return RunTimeProblem(RTP_NOTBACKDROP, F, T, ln);
	}
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	I7_DetachPart(F, nothing);
!	print "F is ", (the) F, " T is ", (the) T, "^";
	if (F == player) {
		I7_PlayerTo(T, opt);
		return;
	}
	if ((going_mode==false) && (IndirectHolder(F, player)) &&
		(I7_Location(player) ~= I7_Location(T))) {
		was = parent(player);
		move player to real_location;
		move F to T;
		I7_PlayerTo(was, true);
		return;
	}
	move F to T;
];
[ I7_Remove F;
	if (F == false) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	give F ~worn; I7_DetachPart(F, nothing);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];
[ I7_Wear F T opt;
	if (F == false) rfalse;
	if (F notin T) I7_Move(F, T, opt);
	give F worn;
];
[ I7_DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
			P.component_sibling = nothing; return;
		}
		for (O = Daddy.component_child: O: O = O.component_sibling)
			if (O.component_sibling == P) {
				O.component_sibling = P.component_sibling;
				P.component_sibling = nothing; return;
			}
];
[ I7_MakePart P Of First;
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { I7_DetachPart(P, nothing); return; }
	if (P.component_parent) I7_DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];
[ I7_OnStage O x;
	if (O ofclass K1_room) rfalse;
	while (O) {
		if (O ofclass K1_room) rtrue;
		if (metaclass(O) ~= Object) rfalse;
		if (O ofclass K9_region) rfalse;
		if (O ofclass K4_door) rtrue;
		if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
		x = O.component_parent;
		if (x) { O = x; continue; }
		x = parent(O);
		if (x) { O = x; continue; }
		rfalse;
	}
	rfalse;
];
[ I7_InWhat obj p;
	if (obj ofclass K1_room) return obj.I7_Map_Region;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];
[ I7_InWhatR obj e f;
	if (obj ofclass K9_region) {
		objectloop (f ofclass K1_room && f.I7_Map_Region == obj)
			if (f > e) return f;
		return nothing;
	}
	if (obj ofclass K5_container or K1_room) {
		if (e == nothing) return child(obj);
		return sibling(e);
	}
	return nothing;
];
[ I7_OnWhat obj p; p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];
[ I7_CarriedBy obj p; p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];
[ I7_HeldBy obj p; p = parent(obj);
	if (p) return p;
	p = obj.component_parent;
	if (p) return p;
	return nothing;
];
[ I7_WornBy obj p; p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];
[ I7_HadBy obj p; p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];
[ I7_Adjacent R1 R2 d pr;
	objectloop (d in compass) {
		pr = d.door_dir;
		if ((R1 provides pr) && (R2 == R1.pr)) rtrue;
	}
	rfalse;
];
[ I7_In obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (~~(obj ofclass K1_room))
		obj = I7_Location(obj);
	if (obj == nothing) rfalse;
	o = obj.I7_Map_Region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];
[ I7_CanSee A B erf;
	if (location == thedark) rfalse;
	if (I7_suppress_scope_loops) {
		if (erf) print "CanSee(", (the) A, ", ", (the) B, ")^";
		rtrue;
	}
	return TestScope(B, A);
];
[ I7_CanTouch A B;
	if (TestScope(B,A) == false) rfalse;
	if (ObjectIsUntouchable(B, 1, 0, A)) rfalse;
	rtrue;
];
[ I7_Conceals A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		I7_concealed_item = B;
		if (CarryOutActivity(CONCEALMENT_ACT, A)) rtrue;
	}
	rfalse;
];
[ I7_RoomFrom obj dir use_doors in_direction sl through_door;
	use_doors = 2;
	if ((obj ofclass K1_room) && (dir in compass)) {
		if (obj provides (dir.door_dir)) {
			in_direction = obj.(dir.door_dir);
			if (in_direction ofclass K1_room) return in_direction;
			if (use_doors && (in_direction ofclass K4_door) &&
				((use_doors & 2) ||
				 (in_direction has open) ||
				 ((in_direction has openable) && (in_direction hasnt locked)))) {
				sl = location; location = obj;
				through_door = in_direction.door_to();
				location = sl;
				if (through_door ofclass K1_room) return through_door;
			}
		}	
	}
	return nothing;
];
[ I7_RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir in compass)) {
		if (obj provides (dir.door_dir)) {
			in_direction = obj.(dir.door_dir);
			if (in_direction ofclass K1_room) return in_direction;
			if (in_direction ofclass K4_door) return in_direction;
		}	
	}
	return nothing;
];
[ I7_OtherSide dr from sl rv;
	if (dr ofclass K4_door) {
		sl = location; location = I7_RoomOf(from);
		rv = dr.door_to();
		location = sl;
	}
	return rv;
];
[ I7_DirectionFrom dr from sl rv obj;
	if (dr ofclass K4_door) {
		sl = location; location = I7_RoomOf(from);
		rv = dr.door_dir();
		location = sl;
		if (rv) {
			objectloop (obj in compass)
				if (obj.door_dir == rv)
					return obj;
		}
	}
	return nothing;
];
[ I7_ChangeExit r1 dir r2 pr;
	pr = dir.door_dir;
	if (r1 provides pr) {
		if ((r1.pr == 0) || (r1.pr ofclass K1_room)) {
				r1.pr = r2;
				return;
		}
		if (r1.pr ofclass K4_door) {
			RunTimeProblem(RTP_EXITDOOR, r1, dir);
			return;
		}
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];
[ I7_ChangeNExit r1 dir r2 pr;
	pr = dir.door_dir;
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if ((r1 provides pr) && (r1.pr == r2)) r1.pr = 0;
	return;
];
[ IndirectHolder A B;
	while (B) {
	  if (B==A) rtrue;
	  B = I7_Holder(B);
	}
	rfalse;
];
[ I7_Holder X;
	if (parent(X)) return parent(X);
	if (X.component_parent) return X.component_parent;
	rfalse;
];
[ I7_ChangePlayer O;
	! Previously K27_player_character
	if (O ofclass K8_person) return ChangePlayer(O);
	RunTimeProblem(RTP_CANTCHANGE, O);
];
[ I7_FrontSide D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0;
	return parent(D);
];
[ I7_BackSide D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1;
	rfalse;
];
[ I7_Location O;
	if (~~(O ofclass K2_thing)) rfalse;
	if (O ofclass K4_door) return I7_FrontSide(O);
	if (O ofclass K7_backdrop) rfalse;
	while (O && (~~(O ofclass K1_room))) {
		if (parent(O)) O = parent(O);
		else O = O.component_parent;
	}
	return O;
];
[ I7_IndirectlyContains o1 o2;
	!  Does o1 enclose o2?
	if ((o1==o2) || (o1 == 0) || (o2 == 0)) rfalse;
	if (o2 ofclass K4_door) {
		if (o1 == I7_FrontSide(o2)) rtrue;
		if (o1 == I7_BackSide(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	while (o2) {
		if (o1==o2) rtrue;
		if (parent(o2)) o2 = parent(o2);
		else o2 = o2.component_parent;
	}
	rfalse;
];

[ I7_PlaceInScope O opts;
	if (opts) return PlaceInScope(O);
	if (O ofclass K2_thing) PlaceInScope(O);
	ScopeWithin(O);
];
[ I7_ScopeParts from obj saw;
!	print "I7_ScopeParts ", from, "^";
	saw = advance_warning; advance_warning = -1;
	if (from == 0) from = self;
	for (obj = from.component_child: obj: obj = obj.component_sibling)
		if ((from == actor) || (I7_Conceals(from, obj) == false)) {
			ScopeWithin_O(obj,0,scope_reason);
		}
	advance_warning = saw;
];

Global allow_abbreviated_look = 0;

[ LookSub_P allow_abbrev oact p1 frame_id; allow_abbreviated_look = allow_abbrev;
	oact = action; action = ##Look;
	p1 = FindAction(##Look);
	if ((p1) && (ActionData-->(p1+9))) {
		frame_id = ActionData-->(p1+10);
		Mstack_Create_Frame(ActionData-->(p1+9), frame_id);
		ProcessRulebook(SETACTIONVARS_RB);
		(MStack-->MstVO(frame_id, 0)) = oact;
	}
	LookSub();
	if (frame_id) Mstack_Destroy_Frame(ActionData-->(p1+9), frame_id);
	allow_abbreviated_look = 0;
	action = oact;
];
[ I7_Calculate_VC;
	if (actor ~= player) rfalse;
	if (parent(actor)==0) return RunTimeError(10);
	visibility_levels = 0;
	.MovedByInitial;
	if (location == thedark) { visibility_ceiling = thedark; NoteArrival(); }
	else
	{   visibility_levels = FindVisibilityLevels();
		if (visibility_ceiling == location)
		{   NoteArrival();
			if (visibility_ceiling ~= location) jump MovedByInitial;
		}
	} rfalse;
];
[ I7_RoomDescPara vc;
	if (lookmode<3 && vc==location)
	{   if ((allow_abbreviated_look~=1) || (lookmode==2) || (location hasnt visited))
		{   if (location.describe~=NULL) {
			    RunRoutines(location,describe);
			    say__p = 1;
			} else {
			    if (location.description==0) RunTimeError(11,location);
			    else {
					  if (location == thedark)
						  I7_PrintProp(thedark,description);
					  else {
						  if (I7_PrintProp(location,description)) say__p = 1;
						  else say__p = 0;
					  }
			    }
			}
		}
	}
];

! End of WorldModel.i6

! Figures.i6

#IFDEF TARGET_GLULX;
#IFNDEF infglk_h; ! Standard Glulx definitions contributed by John Cater
Constant infglk_h;
!-------------------------------------------------------------------------------
!  infglk.h - an Inform library to allow easy access to glk functions
!    under glulx
!  Dynamically created by glk2inf.pl on 08/31/2006 at 19:20:21.
!  Send comments or suggestions to: katre@ruf.rice.edu
!-------------------------------------------------------------------------------
#Ifdef infglk_h;  ! remove "Constant declared but not used" warnings
#Endif;

Constant GLK_NULL 0;

! Constant definitions from glk.h
Constant gestalt_Version 0;
Constant gestalt_CharInput 1;
Constant gestalt_LineInput 2;
Constant gestalt_CharOutput 3;
Constant gestalt_CharOutput_CannotPrint 0;
Constant gestalt_CharOutput_ApproxPrint 1;
Constant gestalt_CharOutput_ExactPrint 2;
Constant gestalt_MouseInput 4;
Constant gestalt_Timer 5;
Constant gestalt_Graphics 6;
Constant gestalt_DrawImage 7;
Constant gestalt_Sound 8;
Constant gestalt_SoundVolume 9;
Constant gestalt_SoundNotify 10;
Constant gestalt_Hyperlinks 11;
Constant gestalt_HyperlinkInput 12;
Constant gestalt_SoundMusic 13;
Constant gestalt_GraphicsTransparency 14;
Constant gestalt_Unicode 15;
Constant evtype_None 0;
Constant evtype_Timer 1;
Constant evtype_CharInput 2;
Constant evtype_LineInput 3;
Constant evtype_MouseInput 4;
Constant evtype_Arrange 5;
Constant evtype_Redraw 6;
Constant evtype_SoundNotify 7;
Constant evtype_Hyperlink 8;
Constant keycode_Unknown $ffffffff;
Constant keycode_Left $fffffffe;
Constant keycode_Right $fffffffd;
Constant keycode_Up $fffffffc;
Constant keycode_Down $fffffffb;
Constant keycode_Return $fffffffa;
Constant keycode_Delete $fffffff9;
Constant keycode_Escape $fffffff8;
Constant keycode_Tab $fffffff7;
Constant keycode_PageUp $fffffff6;
Constant keycode_PageDown $fffffff5;
Constant keycode_Home $fffffff4;
Constant keycode_End $fffffff3;
Constant keycode_Func1 $ffffffef;
Constant keycode_Func2 $ffffffee;
Constant keycode_Func3 $ffffffed;
Constant keycode_Func4 $ffffffec;
Constant keycode_Func5 $ffffffeb;
Constant keycode_Func6 $ffffffea;
Constant keycode_Func7 $ffffffe9;
Constant keycode_Func8 $ffffffe8;
Constant keycode_Func9 $ffffffe7;
Constant keycode_Func10 $ffffffe6;
Constant keycode_Func11 $ffffffe5;
Constant keycode_Func12 $ffffffe4;
Constant keycode_MAXVAL 28;
Constant style_Normal 0;
Constant style_Emphasized 1;
Constant style_Preformatted 2;
Constant style_Header 3;
Constant style_Subheader 4;
Constant style_Alert 5;
Constant style_Note 6;
Constant style_BlockQuote 7;
Constant style_Input 8;
Constant style_User1 9;
Constant style_User2 10;
Constant style_NUMSTYLES 11;
Constant wintype_AllTypes 0;
Constant wintype_Pair 1;
Constant wintype_Blank 2;
Constant wintype_TextBuffer 3;
Constant wintype_TextGrid 4;
Constant wintype_Graphics 5;
Constant winmethod_Left $00;
Constant winmethod_Right $01;
Constant winmethod_Above $02;
Constant winmethod_Below $03;
Constant winmethod_DirMask $0f;
Constant winmethod_Fixed $10;
Constant winmethod_Proportional $20;
Constant winmethod_DivisionMask $f0;
Constant fileusage_Data $00;
Constant fileusage_SavedGame $01;
Constant fileusage_Transcript $02;
Constant fileusage_InputRecord $03;
Constant fileusage_TypeMask $0f;
Constant fileusage_TextMode $100;
Constant fileusage_BinaryMode $000;
Constant filemode_Write $01;
Constant filemode_Read $02;
Constant filemode_ReadWrite $03;
Constant filemode_WriteAppend $05;
Constant seekmode_Start 0;
Constant seekmode_Current 1;
Constant seekmode_End 2;
Constant stylehint_Indentation 0;
Constant stylehint_ParaIndentation 1;
Constant stylehint_Justification 2;
Constant stylehint_Size 3;
Constant stylehint_Weight 4;
Constant stylehint_Oblique 5;
Constant stylehint_Proportional 6;
Constant stylehint_TextColor 7;
Constant stylehint_BackColor 8;
Constant stylehint_ReverseColor 9;
Constant stylehint_NUMHINTS 10;
Constant stylehint_just_LeftFlush 0;
Constant stylehint_just_LeftRight 1;
Constant stylehint_just_Centered 2;
Constant stylehint_just_RightFlush 3;
Constant imagealign_InlineUp $01;
Constant imagealign_InlineDown $02;
Constant imagealign_InlineCenter $03;
Constant imagealign_MarginLeft $04;
Constant imagealign_MarginRight $05;

! The actual glk functions.
[ glk_exit _vararg_count ret;
! glk_exit ()
  ! And now the @glk call
  @glk 1 _vararg_count ret;
  return ret;
];

[ glk_set_interrupt_handler _vararg_count ret;
! glk_set_interrupt_handler (func)
  ! And now the @glk call
  @glk 2 _vararg_count ret;
  return ret;
];

[ glk_tick _vararg_count ret;
! glk_tick ()
  ! And now the @glk call
  @glk 3 _vararg_count ret;
  return ret;
];

[ glk_gestalt _vararg_count ret;
! glk_gestalt (sel val)
  ! And now the @glk call
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
! glk_gestalt_ext (sel val arr arrlen)
  ! And now the @glk call
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
! glk_char_to_lower (ch)
  ! And now the @glk call
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
! glk_char_to_upper (ch)
  ! And now the @glk call
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
! glk_window_get_root ()
  ! And now the @glk call
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
! glk_window_open (split method size wintype rock)
  ! And now the @glk call
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count ret;
! glk_window_close (win result)
  ! And now the @glk call
  @glk 36 _vararg_count ret;
  return ret;
];

[ glk_window_get_size _vararg_count ret;
! glk_window_get_size (win widthptr heightptr)
  ! And now the @glk call
  @glk 37 _vararg_count ret;
  return ret;
];

[ glk_window_set_arrangement _vararg_count ret;
! glk_window_set_arrangement (win method size keywin)
  ! And now the @glk call
  @glk 38 _vararg_count ret;
  return ret;
];

[ glk_window_get_arrangement _vararg_count ret;
! glk_window_get_arrangement (win methodptr sizeptr keywinptr)
  ! And now the @glk call
  @glk 39 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
! glk_window_iterate (win rockptr)
  ! And now the @glk call
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
! glk_window_get_rock (win)
  ! And now the @glk call
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_type _vararg_count ret;
! glk_window_get_type (win)
  ! And now the @glk call
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
! glk_window_get_parent (win)
  ! And now the @glk call
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_get_sibling _vararg_count ret;
! glk_window_get_sibling (win)
  ! And now the @glk call
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count ret;
! glk_window_clear (win)
  ! And now the @glk call
  @glk 42 _vararg_count ret;
  return ret;
];

[ glk_window_move_cursor _vararg_count ret;
! glk_window_move_cursor (win xpos ypos)
  ! And now the @glk call
  @glk 43 _vararg_count ret;
  return ret;
];

[ glk_window_get_stream _vararg_count ret;
! glk_window_get_stream (win)
  ! And now the @glk call
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count ret;
! glk_window_set_echo_stream (win str)
  ! And now the @glk call
  @glk 45 _vararg_count ret;
  return ret;
];

[ glk_window_get_echo_stream _vararg_count ret;
! glk_window_get_echo_stream (win)
  ! And now the @glk call
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count ret;
! glk_set_window (win)
  ! And now the @glk call
  @glk 47 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
! glk_stream_open_file (fileref fmode rock)
  ! And now the @glk call
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
! glk_stream_open_memory (buf buflen fmode rock)
  ! And now the @glk call
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count ret;
! glk_stream_close (str result)
  ! And now the @glk call
  @glk 68 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
! glk_stream_iterate (str rockptr)
  ! And now the @glk call
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
! glk_stream_get_rock (str)
  ! And now the @glk call
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_set_position _vararg_count ret;
! glk_stream_set_position (str pos seekmode)
  ! And now the @glk call
  @glk 69 _vararg_count ret;
  return ret;
];

[ glk_stream_get_position _vararg_count ret;
! glk_stream_get_position (str)
  ! And now the @glk call
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count ret;
! glk_stream_set_current (str)
  ! And now the @glk call
  @glk 71 _vararg_count ret;
  return ret;
];

[ glk_stream_get_current _vararg_count ret;
! glk_stream_get_current ()
  ! And now the @glk call
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count ret;
! glk_put_char (ch)
  ! And now the @glk call
  @glk 128 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream _vararg_count ret;
! glk_put_char_stream (str ch)
  ! And now the @glk call
  @glk 129 _vararg_count ret;
  return ret;
];

[ glk_put_string _vararg_count ret;
! glk_put_string (s)
  ! And now the @glk call
  @glk 130 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream _vararg_count ret;
! glk_put_string_stream (str s)
  ! And now the @glk call
  @glk 131 _vararg_count ret;
  return ret;
];

[ glk_put_buffer _vararg_count ret;
! glk_put_buffer (buf len)
  ! And now the @glk call
  @glk 132 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream _vararg_count ret;
! glk_put_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 133 _vararg_count ret;
  return ret;
];

[ glk_set_style _vararg_count ret;
! glk_set_style (styl)
  ! And now the @glk call
  @glk 134 _vararg_count ret;
  return ret;
];

[ glk_set_style_stream _vararg_count ret;
! glk_set_style_stream (str styl)
  ! And now the @glk call
  @glk 135 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream _vararg_count ret;
! glk_get_char_stream (str)
  ! And now the @glk call
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
! glk_get_line_stream (str buf len)
  ! And now the @glk call
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
! glk_get_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count ret;
! glk_stylehint_set (wintype styl hint val)
  ! And now the @glk call
  @glk 176 _vararg_count ret;
  return ret;
];

[ glk_stylehint_clear _vararg_count ret;
! glk_stylehint_clear (wintype styl hint)
  ! And now the @glk call
  @glk 177 _vararg_count ret;
  return ret;
];

[ glk_style_distinguish _vararg_count ret;
! glk_style_distinguish (win styl1 styl2)
  ! And now the @glk call
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
! glk_style_measure (win styl hint result)
  ! And now the @glk call
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
! glk_fileref_create_temp (usage rock)
  ! And now the @glk call
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
! glk_fileref_create_by_name (usage name rock)
  ! And now the @glk call
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
! glk_fileref_create_by_prompt (usage fmode rock)
  ! And now the @glk call
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
! glk_fileref_create_from_fileref (usage fref rock)
  ! And now the @glk call
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count ret;
! glk_fileref_destroy (fref)
  ! And now the @glk call
  @glk 99 _vararg_count ret;
  return ret;
];

[ glk_fileref_iterate _vararg_count ret;
! glk_fileref_iterate (fref rockptr)
  ! And now the @glk call
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
! glk_fileref_get_rock (fref)
  ! And now the @glk call
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count ret;
! glk_fileref_delete_file (fref)
  ! And now the @glk call
  @glk 102 _vararg_count ret;
  return ret;
];

[ glk_fileref_does_file_exist _vararg_count ret;
! glk_fileref_does_file_exist (fref)
  ! And now the @glk call
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count ret;
! glk_select (event)
  ! And now the @glk call
  @glk 192 _vararg_count ret;
  return ret;
];

[ glk_select_poll _vararg_count ret;
! glk_select_poll (event)
  ! And now the @glk call
  @glk 193 _vararg_count ret;
  return ret;
];

[ glk_request_timer_events _vararg_count ret;
! glk_request_timer_events (millisecs)
  ! And now the @glk call
  @glk 214 _vararg_count ret;
  return ret;
];

[ glk_request_line_event _vararg_count ret;
! glk_request_line_event (win buf maxlen initlen)
  ! And now the @glk call
  @glk 208 _vararg_count ret;
  return ret;
];

[ glk_request_char_event _vararg_count ret;
! glk_request_char_event (win)
  ! And now the @glk call
  @glk 210 _vararg_count ret;
  return ret;
];

[ glk_request_mouse_event _vararg_count ret;
! glk_request_mouse_event (win)
  ! And now the @glk call
  @glk 212 _vararg_count ret;
  return ret;
];

[ glk_cancel_line_event _vararg_count ret;
! glk_cancel_line_event (win event)
  ! And now the @glk call
  @glk 209 _vararg_count ret;
  return ret;
];

[ glk_cancel_char_event _vararg_count ret;
! glk_cancel_char_event (win)
  ! And now the @glk call
  @glk 211 _vararg_count ret;
  return ret;
];

[ glk_cancel_mouse_event _vararg_count ret;
! glk_cancel_mouse_event (win)
  ! And now the @glk call
  @glk 213 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
! glk_buffer_to_lower_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
! glk_buffer_to_upper_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
! glk_buffer_to_title_case_uni (buf len numchars lowerrest)
  ! And now the @glk call
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count ret;
! glk_put_char_uni (ch)
  ! And now the @glk call
  @glk 296 _vararg_count ret;
  return ret;
];

[ glk_put_string_uni _vararg_count ret;
! glk_put_string_uni (s)
  ! And now the @glk call
  @glk 297 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_uni _vararg_count ret;
! glk_put_buffer_uni (buf len)
  ! And now the @glk call
  @glk 298 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream_uni _vararg_count ret;
! glk_put_char_stream_uni (str ch)
  ! And now the @glk call
  @glk 299 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream_uni _vararg_count ret;
! glk_put_string_stream_uni (str s)
  ! And now the @glk call
  @glk 300 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream_uni _vararg_count ret;
! glk_put_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 301 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream_uni _vararg_count ret;
! glk_get_char_stream_uni (str)
  ! And now the @glk call
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
! glk_get_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
! glk_get_line_stream_uni (str buf len)
  ! And now the @glk call
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
! glk_stream_open_file_uni (fileref fmode rock)
  ! And now the @glk call
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
! glk_stream_open_memory_uni (buf buflen fmode rock)
  ! And now the @glk call
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count ret;
! glk_request_char_event_uni (win)
  ! And now the @glk call
  @glk 320 _vararg_count ret;
  return ret;
];

[ glk_request_line_event_uni _vararg_count ret;
! glk_request_line_event_uni (win buf maxlen initlen)
  ! And now the @glk call
  @glk 321 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
! glk_image_draw (win image val1 val2)
  ! And now the @glk call
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
! glk_image_draw_scaled (win image val1 val2 width height)
  ! And now the @glk call
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_image_get_info _vararg_count ret;
! glk_image_get_info (image width height)
  ! And now the @glk call
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count ret;
! glk_window_flow_break (win)
  ! And now the @glk call
  @glk 232 _vararg_count ret;
  return ret;
];

[ glk_window_erase_rect _vararg_count ret;
! glk_window_erase_rect (win left top width height)
  ! And now the @glk call
  @glk 233 _vararg_count ret;
  return ret;
];

[ glk_window_fill_rect _vararg_count ret;
! glk_window_fill_rect (win color left top width height)
  ! And now the @glk call
  @glk 234 _vararg_count ret;
  return ret;
];

[ glk_window_set_background_color _vararg_count ret;
! glk_window_set_background_color (win color)
  ! And now the @glk call
  @glk 235 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
! glk_schannel_create (rock)
  ! And now the @glk call
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count ret;
! glk_schannel_destroy (chan)
  ! And now the @glk call
  @glk 243 _vararg_count ret;
  return ret;
];

[ glk_schannel_iterate _vararg_count ret;
! glk_schannel_iterate (chan rockptr)
  ! And now the @glk call
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
! glk_schannel_get_rock (chan)
  ! And now the @glk call
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
! glk_schannel_play (chan snd)
  ! And now the @glk call
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
! glk_schannel_play_ext (chan snd repeats notify)
  ! And now the @glk call
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count ret;
! glk_schannel_stop (chan)
  ! And now the @glk call
  @glk 250 _vararg_count ret;
  return ret;
];

[ glk_schannel_set_volume _vararg_count ret;
! glk_schannel_set_volume (chan vol)
  ! And now the @glk call
  @glk 251 _vararg_count ret;
  return ret;
];

[ glk_sound_load_hint _vararg_count ret;
! glk_sound_load_hint (snd flag)
  ! And now the @glk call
  @glk 252 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink _vararg_count ret;
! glk_set_hyperlink (linkval)
  ! And now the @glk call
  @glk 256 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink_stream _vararg_count ret;
! glk_set_hyperlink_stream (str linkval)
  ! And now the @glk call
  @glk 257 _vararg_count ret;
  return ret;
];

[ glk_request_hyperlink_event _vararg_count ret;
! glk_request_hyperlink_event (win)
  ! And now the @glk call
  @glk 258 _vararg_count ret;
  return ret;
];

[ glk_cancel_hyperlink_event _vararg_count ret;
! glk_cancel_hyperlink_event (win)
  ! And now the @glk call
  @glk 259 _vararg_count ret;
  return ret;
];

#ENDIF;
#ENDIF;
! End of infglk.h inclusion

Array I7_ResourceFlags->(1+0+5);

[ I7_DisplayFigure resource_ID one_time sfx;
	if (one_time) {
		if (I7_ResourceFlags->resource_ID) return;
	}
	I7_ResourceFlags->resource_ID = true;
#IFDEF TARGET_ZCODE;
! Do nothing if on the V5 or V8 Z-machine, but still compile and run
#IFTRUE #version_number == 6;
	if (sfx) {
		@draw_picture resource_ID;
	} else {
		@sound_effect resource_ID;
	}
#ENDIF; ! Z-machine version 6
#IFNOT; ! Glulx, then:
	if (sfx) {
		if (glk_gestalt(gestalt_Sound, 0)) {
			glk_schannel_play(gg_foregroundchan, resource_ID);
		} else {
			print "[Sound effect number ", resource_ID, " here.]^";
		}
	} else {
		if (glk_gestalt(gestalt_Graphics, 0)) {
			glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
		} else {
			print "[Picture number ", resource_ID, " here.]^";
		}
	}
#ENDIF; ! TARGET_
];

[ I7_PlaySound resource_ID one_time;
	I7_DisplayFigure(resource_ID, one_time, true);
];

! End of Figures.i6

! FileIO.i6

! The I7 kind of value "auxiliary-file" is an --> array, holding the structure:
Constant AUXF_MAGIC = 0; ! First word holds a safety constant
Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure
Constant AUXF_STATUS = 1; ! One of the following:
Constant AUXF_STATUS_IS_UNUSED = 0; ! Never used
Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed
Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary
Constant AUXF_FREF = 3; ! Glulx file reference number (if file has been used)
Constant AUXF_STREAM = 4; ! Stream for an open file (meaningless otherwise)
Constant AUXF_FILENAME = 5; ! Packed address of constant string
Constant AUXF_IFID_OF_OWNER = 6; ! UUID_ARRAY if owned by this project, or
	! string array of IFID of owner wrapped in //...//, or I6_NULL to leave open

[ I7_FileIO_Error auxf err_text;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) {
		print "^*** Error on unknown file: ", (string) err_text, " ***^";
	} else
		print "^*** Error on file '", (string) auxf-->AUXF_FILENAME, "': ",
			(string) err_text, " ***^";
	return 0;
];

#IFDEF TARGET_GLULX;

! Obtain the file reference for a file (which need not exist):

[ I7_FileIO_Fref auxf fref usage;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (auxf-->AUXF_STATUS == 0) {
		if (auxf-->AUXF_BINARY) usage = fileusage_BinaryMode;
		else usage = fileusage_TextMode;
		auxf-->AUXF_FREF =
			glk_fileref_create_by_name(fileusage_Data + usage,
				ChangeAnyToCString(auxf-->AUXF_FILENAME), 0);
		auxf-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	}
	return auxf-->AUXF_FREF;
];

! Find out if a file exists

[ I7_FileIO_Exists auxf fref;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	fref = I7_FileIO_Fref(auxf);
	return glk_fileref_does_file_exist(fref);
];

[ I7_FileIO_Ready auxf fref str ch;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	fref = I7_FileIO_Fref(auxf);
	if (glk_fileref_does_file_exist(fref) == false) rfalse;
	str = glk_stream_open_file(fref, filemode_Read, 0);
	ch = glk_get_char_stream(str);
	glk_stream_close(str, 0);
	if (ch ~= '*') rfalse;
	rtrue;
];

[ I7_FileIO_MarkReady auxf readiness fref str ch;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to open a non-file");
	fref = I7_FileIO_Fref(auxf);
	if (auxf-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return I7_FileIO_Error(auxf, "only closed files can be marked");
	str = glk_stream_open_file(fref, filemode_ReadWrite, 0);
	glk_stream_set_position(str, 0, 0); ! seek start
	if (readiness) ch = '*'; else ch = '-';
	glk_put_char_stream(str, ch); ! mark as complete
	glk_stream_close(str, 0);
];

! Opening and closing files:

[ I7_FileIO_Open auxf write_flag append_flag
	fref str mode ix ch not_this_ifid owner force_header;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to open a non-file");
	fref = I7_FileIO_Fref(auxf);
	if (auxf-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return I7_FileIO_Error(auxf, "tried to open a file already open");
	if (write_flag) {
		if (append_flag) {
			mode = filemode_WriteAppend;
			if (glk_fileref_does_file_exist(fref) == false)
				force_header = true;
		}
		else mode = filemode_Write;
	} else {
		mode = filemode_Read;
		if (glk_fileref_does_file_exist(fref) == false)
			return I7_FileIO_Error(auxf, "tried to open a file which does not exist");
	}
	str = glk_stream_open_file(fref, mode, 0);
	if (str == 0)
		return I7_FileIO_Error(auxf, "tried to open a file but failed");
	auxf-->AUXF_STREAM = str;
	if (write_flag) {
		if (append_flag)
			auxf-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;
		else
			auxf-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;
		glk_stream_set_current(str);
		if ((append_flag == FALSE) || (force_header)) {
			print "- ";
			for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
			print " ", (string) auxf-->AUXF_FILENAME, "^";
		}
	} else {
		auxf-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;
		ch = I7_FileIO_GetC(auxf);
		if (ch ~= '-' or '*') { jump BadFile; }
		if (ch == '-')
			return I7_FileIO_Error(auxf, "tried to open a file which was incomplete");
		ch = I7_FileIO_GetC(auxf);
		if (ch ~= ' ') { jump BadFile; }
		ch = I7_FileIO_GetC(auxf);
		if (ch ~= '/') { jump BadFile; }
		ch = I7_FileIO_GetC(auxf);
		if (ch ~= '/') { jump BadFile; }
		owner = auxf-->AUXF_IFID_OF_OWNER;
		ix = 3;
		if (owner == UUID_ARRAY) ix = 8;
		if (owner ~= I6_NULL) {
			for (: ix <= owner->0: ix++) {
				ch = I7_FileIO_GetC(auxf);
				if (ch == -1) { jump BadFile; }
				if (ch ~= owner->ix) not_this_ifid = true;
				if (ch == ' ') break;
			}
			if (not_this_ifid == false) {
				ch = I7_FileIO_GetC(auxf);
				if (ch ~= ' ') { jump BadFile; }
			}
		}
		while (ch ~= -1) {
			ch = I7_FileIO_GetC(auxf);
			if (ch == 10 or 13) break;
		}
		if (not_this_ifid) {
			auxf-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
			glk_stream_close(str, 0);
			return I7_FileIO_Error(auxf,
				"tried to open a file owned by another project");
		}
	}
	return auxf-->AUXF_STREAM;
	.BadFile;
	auxf-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	glk_stream_close(str, 0);
	return I7_FileIO_Error(auxf, "tried to open a file which seems to be malformed");
];

[ I7_FileIO_Close auxf;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to close a non-file");
	if (auxf-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_READ or
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return I7_FileIO_Error(auxf, "tried to close a file which is not open");
	if ((auxf-->AUXF_BINARY == false) &&
		(auxf-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
		glk_set_window(gg_mainwin);
	}
	if (auxf-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND) {
		glk_stream_set_position(auxf-->AUXF_STREAM, 0, 0); ! seek start
		glk_put_char_stream(auxf-->AUXF_STREAM, '*'); ! mark as complete
	}
	glk_stream_close(auxf-->AUXF_STREAM, 0);
	auxf-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
];

! Getting and putting characters

[ I7_FileIO_GetC auxf;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) return -1;
	if (auxf-->AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;
	return glk_get_char_stream(auxf-->AUXF_STREAM);
];

[ I7_FileIO_PutC auxf char;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to write to a non-file");
	if (auxf-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return I7_FileIO_Error(auxf,
			"tried to write to a file which is not open for writing");
	return glk_put_char_stream(auxf-->AUXF_STREAM, char);
];

[ I7_FileIO_PrintLine auxf ch;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to write to a non-file");
	for (::) {
		ch = I7_FileIO_GetC(auxf);
		if (ch == -1) rfalse;
		if (ch == 10 or 13) { print "^"; rtrue; }
		print (char) ch;
	}
];

[ I7_FileIO_PutContents auxf text append_flag
	str ch save_say__p save_say__pc save_say__c;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to access a non-file");
	if (auxf-->AUXF_BINARY)
		return I7_FileIO_Error(auxf, "writing text will not work with binary files");
	str = I7_FileIO_Open(auxf, true, append_flag);
	if (str == 0) rfalse;
	save_say__p = say__p; say__p = 0;
	save_say__pc = say__pc; say__pc = 0;
	save_say__c = say__c; say__c = 0;
	switch (metaclass(text)) {
		String: print (string) text;
		Routine: (text)();
	}
	I7_FileIO_Close(auxf);
	say__p = save_say__p;
	say__pc = save_say__pc;
	say__c = save_say__c;
	rfalse;
];

[ I7_FileIO_PrintContents auxf tab;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to access a non-file");
	if (auxf-->AUXF_BINARY)
		return I7_FileIO_Error(auxf, "printing text will not work with binary files");
	if (I7_FileIO_Open(auxf, false) == 0) rfalse;
	while (I7_FileIO_PrintLine(auxf)) ;
	I7_FileIO_Close(auxf);
	rtrue;
];

[ I7_FileIO_PutTable auxf tab rv;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to write table to a non-file");
	if (auxf-->AUXF_BINARY)
		return I7_FileIO_Error(auxf, "writing a table will not work with binary files");
	if (I7_FileIO_Open(auxf, true) == 0) rfalse;
	rv = TablePrint(tab);
	I7_FileIO_Close(auxf);
	if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	rtrue;
];

[ I7_FileIO_GetTable auxf tab;
	if ((auxf == 0) || (auxf-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE))
		return I7_FileIO_Error(auxf, "tried to read table from a non-file");
	if (auxf-->AUXF_BINARY)
		return I7_FileIO_Error(auxf, "reading a table will not work with binary files");
	if (I7_FileIO_Open(auxf, false) == 0) rfalse;
	TableRead(tab, auxf);
	I7_FileIO_Close(auxf);
	rtrue;
];

#IFNOT; ! TARGET_GLULX
[ I7_FileIO_Exists auxf; rfalse; ];
[ I7_FileIO_Ready auxf; rfalse; ];
[ I7_FileIO_GetC auxf; return -1; ];
[ I7_FileIO_PutTable auxf tab;
	return I7_FileIO_Error(auxf, "external files can only be used under Glulx");
];
[ I7_FileIO_MarkReady auxf status; I7_FileIO_PutTable(auxf); ];
[ I7_FileIO_GetTable auxf tab; I7_FileIO_PutTable(auxf); ];
[ I7_FileIO_PrintContents auxf; I7_FileIO_PutTable(auxf); ];
[ I7_FileIO_PutContents auxf; I7_FileIO_PutTable(auxf); ];
#ENDIF; ! TARGET_GLULX

! End of FileIO.i6




[ I7_char_to_digit c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];

[ I7_Match test snippet w1 wlen i j;
	if (metaclass(test) == Routine) {
		w1 = snippet/100; wlen = snippet%100;
		for (i=w1, j=wlen: j>0: i++, j--) {
			if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
		}
	}
	rfalse;
];

[ I7_ParseToken x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

[ I7_SeedRNG n; ! Seed the random number generator
	#ifdef TARGET_ZCODE;
	if (n > 0) n = -n;
	@random n -> n;
	#ifnot; ! TARGET_GLULX
	@setrandom n;
	#endif; ! TARGET_
];
[ I7_RNG n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];

[ I7_SceneChange chs sc ch;
  if (scene_status-->0 == 1) {
      if (((  (deadflag~=0)  ))) { ch++;
          if (debug_scenes) print "[Scene 'Entire Game' ends]^";
          scene_status-->0 = 2; ProcessRulebook(34);
          scene_ended-->0 = the_time;
          scene_endings-->0 = (scene_endings-->0)|2;
          scene_latest_ending-->0 = 1;
      jump CScene; }
  }
  if (scene_status-->0 == 0) {
      if (((  (deadflag==0)  ))) { ch++;
          if (debug_scenes) print "[Scene 'Entire Game' begins]^";
          scene_status-->0 = 1; ProcessRulebook(33);
          scene_started-->0 = the_time;
          scene_endings-->0 = (scene_endings-->0)|1;
          scene_latest_ending-->0 = 0;
      jump CScene; }
  }
  .CScene;
  if (chs>10) ">--> The scene change machinery is stuck.";

  if (ch>0) I7_SceneChange(++chs);

];


#IFDEF DEBUG;
[ I7_SceneStatus chs sc ch;
  if (scene_status-->0 == 1) {
      print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
  } else {
      if (scene_latest_ending-->0 > 0) {
          print "Scene 'Entire Game' ended ";
          print "^";
      }
  }
];


#ENDIF;
Constant BR_0 = R_14;
Constant BR_1 = R_23;
Constant BR_2 = R_24;
Constant BR_3 = R_25;
Constant BR_4 = R_26;
Constant BR_5 = R_27;
Constant BR_6 = R_28;
Constant BR_7 = R_29;
Constant BR_8 = R_30;
Constant BR_9 = R_31;
Constant BR_10 = R_32;
Constant BR_11 = R_33;
Constant BR_12 = R_34;
Constant BR_13 = R_35;
Constant BR_14 = R_36;
Constant BR_15 = R_37;
Constant BR_16 = R_38;
Constant BR_17 = R_39;
Constant BR_18 = R_40;
Constant BR_19 = R_41;
Constant BR_20 = R_42;
Constant BR_21 = R_43;
Constant BR_22 = R_44;
Constant BR_23 = R_45;
Constant BR_24 = R_46;
Constant BR_25 = R_47;
Constant BR_26 = R_48;
Constant BR_27 = R_49;
Constant BR_28 = R_50;
Constant BR_29 = R_51;
Constant BR_30 = R_52;
Constant BR_31 = R_53;
Constant BR_32 = R_54;
Constant BR_33 = R_55;
Constant BR_34 = R_56;
Constant BR_35 = R_57;
Constant BR_36 = R_58;
Constant BR_37 = R_59;
Constant BR_38 = R_60;
Constant BR_39 = R_61;
Constant BR_40 = R_62;
Constant BR_41 = R_63;
Constant BR_42 = R_64;
Constant BR_43 = R_65;
Constant BR_44 = R_66;
Constant BR_45 = R_67;
Constant BR_46 = R_68;
Constant BR_47 = R_69;
Constant BR_48 = R_70;
Constant BR_49 = R_71;
Constant BR_50 = R_72;
Constant BR_51 = R_73;
Constant BR_52 = R_74;
Constant BR_53 = R_75;
Constant BR_54 = R_76;
Constant BR_55 = R_77;
Constant BR_56 = R_78;
Constant BR_57 = R_79;
Constant BR_58 = R_80;
Constant BR_59 = R_81;
Constant BR_60 = R_82;
Constant BR_61 = R_83;
Constant BR_62 = R_84;
Constant BR_63 = R_85;
Constant BR_64 = R_86;
Constant BR_65 = R_87;
Constant BR_66 = R_88;
Constant BR_67 = R_89;
Constant BR_68 = R_90;
Constant BR_69 = R_91;
Constant BR_70 = R_92;
Constant BR_71 = R_93;
Constant BR_72 = R_94;
Constant BR_73 = R_95;
Constant BR_74 = R_96;
Constant BR_75 = R_97;
Constant BR_76 = R_98;
Constant BR_77 = R_99;
Constant BR_78 = R_100;
Constant BR_79 = R_102;
Constant BR_80 = R_103;
Constant BR_81 = R_104;
Constant BR_82 = R_105;
Constant BR_83 = R_106;
Constant BR_84 = R_107;
Constant BR_85 = R_108;
Constant BR_86 = R_109;
Constant BR_87 = R_110;
Constant BR_88 = R_111;
Constant BR_89 = R_112;
Constant BR_90 = R_113;
Constant BR_91 = R_114;
Constant BR_92 = R_115;
Constant BR_93 = R_116;
Constant BR_94 = R_117;
Constant BR_95 = R_118;
Constant BR_96 = R_119;
Constant BR_97 = R_120;
Constant BR_98 = R_121;
Constant BR_99 = R_122;
Constant BR_100 = R_123;
Constant BR_101 = R_124;
Constant BR_102 = R_125;
Constant BR_103 = R_126;
Constant BR_104 = R_127;
Constant BR_105 = R_128;
Constant BR_106 = R_129;
Constant BR_107 = R_130;
Constant BR_108 = R_131;
Constant BR_109 = R_132;
Constant BR_110 = R_133;
Constant BR_111 = R_134;
Constant BR_112 = R_135;
Constant BR_113 = R_136;
Constant BR_114 = R_137;
Constant BR_115 = R_138;
Constant BR_116 = R_139;
Constant BR_117 = R_140;
Constant BR_118 = R_141;
Constant BR_119 = R_142;
Constant BR_120 = R_143;
Constant BR_121 = R_144;
Constant BR_122 = R_145;
Constant BR_123 = R_146;
Constant BR_124 = R_147;
Constant BR_125 = R_148;
Constant BR_126 = R_149;
Constant BR_127 = R_150;
Constant BR_128 = R_151;
Constant BR_129 = R_152;
Constant BR_130 = R_153;
Constant BR_131 = R_154;
Constant BR_132 = R_155;
Constant BR_133 = R_156;
Constant BR_134 = R_157;
Constant BR_135 = R_158;
Constant BR_136 = R_159;
Constant BR_137 = R_160;
Constant BR_138 = R_161;
Constant BR_139 = R_162;
Constant BR_140 = R_163;
Constant BR_141 = R_164;
Constant BR_142 = R_165;
Constant BR_143 = R_166;
Constant BR_144 = R_167;
Constant BR_145 = R_168;
Constant BR_146 = R_169;
Constant BR_147 = R_170;
Constant BR_148 = R_171;
Constant BR_149 = R_172;
Constant BR_150 = R_173;
Constant BR_151 = R_174;
Constant BR_152 = R_175;
Constant BR_153 = R_176;
Constant BR_154 = R_177;
Constant BR_155 = R_178;
Constant BR_156 = R_179;
Constant BR_157 = R_180;
Constant BR_158 = R_181;
Constant BR_159 = R_182;
Constant BR_160 = R_183;
Constant BR_161 = R_184;
Constant BR_162 = R_185;
Constant BR_163 = R_186;
Constant BR_164 = R_187;
Constant BR_165 = R_188;
Constant BR_166 = R_189;
Constant BR_167 = R_190;
Constant BR_168 = R_191;
Constant BR_169 = R_192;
Constant BR_170 = R_193;
Constant BR_171 = R_194;
Constant BR_172 = R_195;
Constant BR_173 = R_196;
Constant BR_174 = R_197;
Constant BR_175 = R_198;
Constant BR_176 = R_199;
Constant BR_177 = R_200;
Constant BR_178 = R_201;
Constant BR_179 = R_202;
Constant BR_180 = R_203;
Constant BR_181 = R_204;
Constant BR_182 = R_205;
Constant BR_183 = R_206;
Constant BR_184 = R_207;
Constant BR_185 = R_208;
Constant BR_186 = R_209;
Constant BR_187 = R_210;
Constant BR_188 = R_211;
Constant BR_189 = R_212;
Constant BR_190 = R_213;
Constant BR_191 = R_214;
Constant BR_192 = R_215;
Constant BR_193 = R_216;
Constant BR_194 = R_217;
Constant BR_195 = R_218;
Constant BR_196 = R_219;
Constant BR_197 = R_220;
Constant BR_198 = R_221;
Constant BR_199 = R_222;
Constant BR_200 = R_223;
Constant BR_201 = R_224;
Constant BR_202 = R_225;
Constant BR_203 = R_226;
Constant BR_204 = R_227;
Constant BR_205 = R_228;
Constant BR_206 = R_229;
Constant BR_207 = R_230;
Constant BR_208 = R_231;
Constant BR_209 = R_232;
Constant BR_210 = R_233;
Constant BR_211 = R_234;
Constant BR_212 = R_235;
Constant BR_213 = R_236;
Constant BR_214 = R_237;
Constant BR_215 = R_238;
Constant BR_216 = R_239;
Constant BR_636 = R_34;


! Tables.i6 segment

! A table T is represented by a "table" array: T-->0 holds the
! number of columns (which is at most 99) and T-->i is the address
! of column number i.
! Columns are therefore numbered from 1 to T-->0, but they are also
! identified by an ID number of 100 or more, with each different
! column name having its own ID number.
! Each column C is also a "table" array, with C-->1 holding the unique
! ID number for the column's name, C-->2 holding the blank entry flags
! offset and C-->3 up to C-->(C-->0) holding the entries.
! C-->1 also contains four upper bit flags. These are also defined in
! Tables.w in the NI source, and the values must agree.

Constant I7_COLUMN_SIGNED $4000;
Constant I7_COLUMN_TOPIC $2000;
Constant I7_COLUMN_DONTSORTME $1000;
Constant I7_COLUMN_NOBLANKBITS $0800;
Constant I7_COLUMN_CANEXCHANGE $0400;
Constant I7_COLUMN_ALLOCATED $0200;
Constant I7_COLUMN_NUMBER $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)

Array T_empty_table --> 0 0;

[ TableFindCol tab col f i j n;
	j = tab-->0;
	for (i=1:i<=j:i++)
		if (col == ((tab-->i)-->1) & I7_COLUMN_NUMBER) return i;
	if (f) return RunTimeProblem(RTP_TABLE_NOCOL, tab);
	return 0;
];

! The columns in a table can be assumed all to have the same
! height (i.e., number of rows): thus the number of rows in T
! can be calculated by looking at column 1, thus...

[ TableRows tab; return ((tab-->1)-->0) - COL_HSIZE; ];

! The following dummy value is invalid for most types and unlikely in the
! others, so is used to suggest an empty cell. We cannot be certain that a
! cell is empty unless it both contains this value and also has the
! corresponding bit set in the blanks bitmap for the column (unless the
! column is one with the I7_COLUMN_NOBLANKBITS flag set, in which case
! its data type is such that I7 can prove that the dummy value is certain
! to mean that the cell is blank).

#ifdef TARGET_ZCODE;
Constant I7_TABLE_NOVALUE $7fe3;
#ifnot; ! TARGET_GLULX
Constant I7_TABLE_NOVALUE $deadce11;
#endif; ! TARGET_

! The following should be used only where the entry has been found to be
! I7_TABLE_NOVALUE, so that it is probably a blank. For some columns we
! can immediately deduce from the value that this is indeed true, but
! for others we have to consult the "blank bits".

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= I7_TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value: ", tab, " ", col, " ", row, "^";
	}
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	!print "Check nonblank at = ", at, "^";
	!print "Started = ", I7_T_Blanks->at, "^";
	if ((I7_T_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	!print "Force so: ", col, " ", row, " ", flags, " ", oldv, "^";
	if ((flags & I7_COLUMN_ALLOCATED) &&
		(oldv ~= 0 or I7_TABLE_NOVALUE)) {
		I7_Blk_Free(oldv);
	}
	(tab-->col)-->(row+COL_HSIZE) = I7_TABLE_NOVALUE;
	if (flags & I7_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(I7_T_Blanks->at) 
		= (I7_T_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov j;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	!print "Force not: ", col, " ", row, " ", flags, " ", oldv, "^";
	if ((flags & I7_COLUMN_ALLOCATED) &&
		(oldv == 0 or I7_TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & I7_COLUMN_NUMBER;
		for (j=0: I7_TC_KOV-->j: j=j+2)
			if (I7_TC_KOV-->j == tc)
				kov = I7_TC_KOV-->(j+1);
		if (kov ~= UNKNOWN_TY)
			(tab-->col)-->(row+COL_HSIZE) = I7_Blk_Create(kov);
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	!print "Force nonblank at = ", at, "^";
	!print "Started = ", I7_T_Blanks->at, "^";
	(I7_T_Blanks->at) 
		= (I7_T_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
	!print "Finished = ", I7_T_Blanks->at, "^";
];

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((I7_T_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((I7_T_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(I7_T_Blanks->at1)
			= (I7_T_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(I7_T_Blanks->at2)
			= (I7_T_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(I7_T_Blanks->at1)
			= (I7_T_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(I7_T_Blanks->at2)
			= (I7_T_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((I7_T_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((I7_T_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(I7_T_Blanks->at)
				= (I7_T_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(I7_T_Blanks->at)
				= (I7_T_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(I7_T_Blanks->at)
			= (I7_T_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(I7_T_Blanks->at)
			= (I7_T_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

! TableRowCorr(T, C, V) returns the first row on which value V
! appears in column C of table T, or prints an error if it doesn't.

[ TableRowCorr tab col lookup_value lookup_col i j;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	for (i=1:i<=j:i++)
		if (lookup_col-->(i+COL_HSIZE) == lookup_value) {
			if ((lookup_value == I7_TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			return i;
		}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

! ExistsTableRowCorr(T, C, V) returns the first row on which V
! appears in column C of table T, or 0 if V does not occur at all.

[ ExistsTableRowCorr tab col entry i k v f a b;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f = ((tab-->col)-->1) & I7_COLUMN_TOPIC;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		! print "Checking row ", i, "^";
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		if (f) {
			if ((entry >= 256) && (entry == consult_from + 256*consult_words)) {
				a = consult_from; b = consult_words;
			} else {
				a = entry/100; b = entry%100;
			}
			! print "a,b = ", a, ",", b, "^";
		    if ((v)(a, b) ~= GPR_FAIL) return i;
		} else {
		    if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];

! TableLookUpCorr(T, C1, C2, V) finds the first row on which value
! V appears in column C2, and returns the corresponding value in C1,
! or prints an error if the value V cannot be found or has no
! corresponding value in C1.

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	for (i=1+COL_HSIZE:i<=j:i++)
		if (cola2-->i == lookup_value) {
		    if (write_flag) {
		    	ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
		    	cola1-->i = write_value;
		    	rfalse;
		    }
			v = cola1-->i;
			if ((v == I7_TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
			return v;
		}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

! ExistsTableLookUpCorr(T, C1, C2, V) returns true if the operation
! TableLookUpCorr(T, C1, C2, V) can be done, false otherwise.

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	for (i=1+COL_HSIZE:i<=j:i++)
		if (cola2-->i == lookup_value) {
			if ((cola1-->i == I7_TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
			rtrue;
		}
	rfalse;
];

! TableLookUpEntry(T, C, R) returns the value at column C, row R,
! printing an error if that doesn't exist.

[ TableLookUpEntry tab col index write_flag write_value v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab)))
		return RunTimeProblem(RTP_TABLE_NOROW, tab, index);
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		return RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, 0, index);
	return v;
];

! ExistsTableLookUpEntry(T, C, R) returns true if a value exists
! at column C, row R, false otherwise.

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];

! TableRowIsBlank(T, R) returns true if row R of table T is blank.
! (R must be a legal row number.)

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= I7_TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

! TableBlankOutRow(T, R) fills row R of table T with blanks.
! (R must be a legal row number.)

[ TableBlankOutRow tab j k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, j);
];

! TableBlankRows(T) returns the number of blank rows in T.

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

! TableFilledRows(T) returns the number of non-blank rows in T.

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

! TableBlankRow(T) finds the first blank row in T.

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];

! TableRandomRow(T) chooses a random non-blank row in T.

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];

! TableSwapRows(T, R1, R2) exchanges rows R1 and R2.

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == I7_TABLE_NOVALUE) || (v2 == I7_TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == I7_TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == I7_TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];

! TableShuffle(T) sorts T into random row order.

[ TableShuffle tab i j k;
	k = TableRows(tab);
	for (i=2:i<=k:i++) TableSwapRows(tab, i, random(i));
];

! TableNextRow(T, C, R, D) is used when scanning through a
! table in order of the values in column C: ascending order
! if D = 1, descending if D = -1. The current position is row R
! of column C, or R=0 if we have not yet found the first row.
! The return value is the row number for the next value, or 0
! if we are already at the final value. Note that if there
! are several equal values in the column, they will be run
! through in turn, in order of their physical row numbers -
! ascending if D = 1, descending if D = -1, so that using
! the routine with D = -1 always produces the exact reverse
! ordering from using it with D = 1 and the same parameters.
! Rows with blank entries in C are skipped.
!
! for (R=TableNextRow(T,C,0,D): R : R=TableNextRow(T,C,R,D)) ...
! will perform a loop of valid row numbers in order of column C.

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	signed_arithmetic = ((tab-->col)-->1) & I7_COLUMN_SIGNED;
	#ifdef TARGET_ZCODE;
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! TARGET_GLULX
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif; ! TARGET_
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i>row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i<row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];

! TableCompareRows(T, C, R1, R2, D) returns:
! +1 if the entry at row R1 of column C is > the entry at row R2,
! 0 if they are equal, and
! -1 if entry at R1 < entry at R2.
! When D = +1, a blank value is > all other values, so that in
! an ascending sort the blanks come last; when D = -1, a blank
! value is < all others, so that once again blanks are last.
! Finally, a wholly blank row is always placed after a row in
! which the entry in C is blank but where other entries are not.

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == I7_TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == I7_TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= I7_TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return -1*dir;
	if (bl2) return dir;
	if (((tab-->col)-->1) & I7_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow<fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow:i<=torow:i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	!print "First blank is ", fbl, "^";
	!print "Last nonblank is ", lnbl, "^";
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl+1, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];

[ TableColumnDebug tab col k i v;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	print "Table col ", col, ": ";
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "BLANK ";
		else print v, " ";
	}
	print "*^";
];

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & I7_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	!print "Initial state:^"; TableColumnDebug(tab, col);

	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	I7_Sort(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & I7_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & I7_COLUMN_NUMBER;
			kov = NUMBER_TY;
			for (i=0: I7_TC_KOV-->i: i=i+2)
				if (I7_TC_KOV-->i == tc)
					kov = I7_TC_KOV-->(i+1);
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (I7_Blk_Write_File_Form(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & I7_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = I7_FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = I7_FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = I7_FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & I7_COLUMN_NUMBER;
			kov = NUMBER_TY;
			for (j=0: I7_TC_KOV-->j: j=j+2)
				if (I7_TC_KOV-->j == tc)
					kov = I7_TC_KOV-->(j+1);
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = I7_FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = I7_FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & I7_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = I7_Blk_Read_File_Form(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & I7_COLUMN_ALLOCATED)
					v = I7_Blk_Read_File_Form(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = I7_Blk_Read_File_Form(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = I7_FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & I7_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = I7_FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = I7_FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = I7_FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX

#ifdef I7_RANKING_TABLE;
[ PrintRank i j v;
	print ", earning you the rank of ";
	j = TableRows(I7_RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(I7_RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(I7_RANKING_TABLE, 2, i);
		    if (v ofclass String) print (string) v;
		    else v();
		    ".";
		}
	".";
];
#endif;

! Sorting algorithms.
! We are required to use a stable sorting algorithm with very low, ideally
! zero, auxiliary storage requirement. Exchanges are generally slower than
! comparisons.

Global I7S_Tab;
Global I7S_Col;
Global I7S_Dir;
Global I7S_Swap;
Global I7S_Comp;
#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT;
Global I7S_CCOUNT2;
Global I7S_XCOUNT;
#endif;

[ I7_Sort tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	I7S_Swap = TableSwapRows;
	I7S_Comp = TableCompareRows;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	I7_Sort_Range(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];

[ I7_Sort_Range x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		I7_InPlaceMergeSort(x, y);
	}
];

[ I7_Sort_Compare x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ I7_Sort_Exchange x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	return I7S_Swap(I7S_Tab, x+1, y+1);
];

! Sorting algorithm used in builds up to and including 4W37: note that this is
! not quite bubble sort, and that it is unstable. It is now no longer used.

[ I7_4W37Sort x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (I7_Sort_Compare(i, j) > 0) {
					I7_Sort_Exchange(i, j); f = true; break;
				}
	}
];

! Insertion sort: stable and O(n^2) running time, but better performance on
! nearly sorted tables, and with very low overhead.

[ I7_InsertionSort from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (I7_Sort_Compare(j, j-1) < 0) 
					I7_Sort_Exchange(j, j-1);
				else break;
			}
		}
	}
];

! In place mergesort: stable and O(n log n) running time, at some stack cost,
! and generally good for nearly sorted tables, but complex and with overhead.
! The code here mostly follows Thomas Baudel's implementation, which in turn
! follows the C++ STL library.

[ I7_InPlaceMergeSort from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		I7_InsertionSort(from, to);
		return;
	}
	middle = (from + to)/2; 
	I7_InPlaceMergeSort(from, middle); 
	I7_InPlaceMergeSort(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (I7_Sort_Compare(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (I7_Sort_Compare(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		I7_Sort_Exchange(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (I7_Sort_Compare(pivot, from) < 0) 
		I7_Sort_Exchange(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];

! End of Tables.i6


[ Adj_0 t_0 ct_0 ct_1; ! meaning of "adjacent"
  if (((t_0 ofclass K1_room))) return (((I7_Adjacent(real_location,t_0))));
  rfalse; ];

[ Adj_1 t_0 ct_0 ct_1; ! meaning of "visible"
  if (((t_0 ofclass K2_thing))) return (((I7_CanSee(player,t_0))));
  rfalse; ];

[ Adj_2 t_0 ct_0 ct_1; ! meaning of "touchable"
  if (((t_0 ofclass K2_thing))) return (((I7_CanTouch(player,t_0))));
  rfalse; ];

[ Adj_3 t_0 ct_0 ct_1; ! meaning of "invisible"
  if (((t_0 ofclass K2_thing))) return ((~~((I7_CanSee(player,t_0)))));
  rfalse; ];

[ Adj_4 t_0 ct_0 ct_1; ! meaning of "untouchable"
  if (((t_0 ofclass K2_thing))) return ((~~((I7_CanTouch(player,t_0)))));
  rfalse; ];

[ Adj_5 t_0 ct_0 ct_1; ! meaning of "concealed"
  if (((t_0 ofclass K2_thing))) return (((I7_Conceals(  (I7_Holder(t_0))  ,t_0))));
  rfalse; ];

[ Adj_6 t_0 ct_0 ct_1; ! meaning of "unconcealed"
  if (((t_0 ofclass K2_thing))) return ((~~((I7_Conceals(  (I7_Holder(t_0))  ,t_0)))));
  rfalse; ];

[ Adj_7 t_0 ct_0 ct_1; ! meaning of "on-stage"
  if (((t_0 ofclass K2_thing))) return (((  (I7_OnStage(t_0))  )));
  rfalse; ];

[ Adj_8 t_0 ct_0 ct_1; ! meaning of "off-stage"
  if (((t_0 ofclass K2_thing))) return (((  (I7_OnStage(t_0)==false)  )));
  rfalse; ];



[ MistakeActionSub;
  switch(I7_mistake_code) {
    default: "I didn't understand that sentence.";
  }
];










Constant ActionCount = 80;
Array ActionData table
  ##Inv                               $$00000000  61 61 "taking inventory" I6_NULL I6_NULL I6_NULL I6_NULL  0 20000
  ##Take                              $$00001001  61 61 "taking" DA_Name I6_NULL I6_NULL I6_NULL  ANSTVC_1 20001
  ##Remove                            $$00011011  61 61 "removing" DA_Name "from" DA_Name I6_NULL  0 20002
  ##Drop                              $$00001001  61 61 "dropping" DA_Name I6_NULL I6_NULL I6_NULL  0 20003
  ##PutOn                             $$00011011  61 61 "putting" DA_Name "on" DA_Name I6_NULL  0 20004
  ##Insert                            $$00011011  61 61 "inserting" DA_Name "into" DA_Name I6_NULL  0 20005
  ##Eat                               $$01001001  61 61 "eating" DA_Name I6_NULL I6_NULL I6_NULL  0 20006
  ##Go                                $$00001000  61 61 "going" DA_Name I6_NULL I6_NULL I6_NULL  ANSTVC_7 20007
  ##Enter                             $$00001001  61 61 "entering" DA_Name I6_NULL I6_NULL I6_NULL  0 20008
  ##Exit                              $$00000000  61 61 "exiting" I6_NULL I6_NULL I6_NULL I6_NULL  ANSTVC_9 20009
  ##GetOff                            $$00001001  61 61 "getting off" DA_Name I6_NULL I6_NULL I6_NULL  0 20010
  ##Look                              $$00000000  61 61 "looking" I6_NULL I6_NULL I6_NULL I6_NULL  ANSTVC_11 20011
  ##Examine                           $$00001100  61 61 "examining" DA_Name I6_NULL I6_NULL I6_NULL  0 20012
  ##LookUnder                         $$00001100  61 61 "looking under" DA_Name I6_NULL I6_NULL I6_NULL  0 20013
  ##Search                            $$00001101  61 61 "searching" DA_Name I6_NULL I6_NULL I6_NULL  0 20014
  ##Consult                           $$00011001  61 74 "consulting" DA_Name "about" DA_Topic I6_NULL  0 20015
  ##Lock                              $$10011011  61 61 "locking" DA_Name "with" DA_Name I6_NULL  0 20016
  ##Unlock                            $$10011011  61 61 "unlocking" DA_Name "with" DA_Name I6_NULL  0 20017
  ##SwitchOn                          $$00001001  61 61 "switching on" DA_Name I6_NULL I6_NULL I6_NULL  0 20018
  ##SwitchOff                         $$00001001  61 61 "switching off" DA_Name I6_NULL I6_NULL I6_NULL  0 20019
  ##Open                              $$00001001  61 61 "opening" DA_Name I6_NULL I6_NULL I6_NULL  0 20020
  ##Close                             $$00001001  61 61 "closing" DA_Name I6_NULL I6_NULL I6_NULL  0 20021
  ##Wear                              $$01001001  61 61 "wearing" DA_Name I6_NULL I6_NULL I6_NULL  0 20022
  ##Disrobe                           $$01001001  61 61 "taking off" DA_Name I6_NULL I6_NULL I6_NULL  0 20023
  ##Give                              $$01011011  61 61 "giving" DA_Name "to" DA_Name I6_NULL  0 20024
  ##Show                              $$01011001  61 61 "showing" DA_Name "to" DA_Name I6_NULL  0 20025
  ##WakeOther                         $$00001001  61 61 "waking" DA_Name I6_NULL I6_NULL I6_NULL  0 20026
  ##ThrowAt                           $$01011001  61 61 "throwing" DA_Name "at" DA_Name I6_NULL  0 20027
  ##Attack                            $$00001001  61 61 "attacking" DA_Name I6_NULL I6_NULL I6_NULL  0 20028
  ##Kiss                              $$00001001  61 61 "kissing" DA_Name I6_NULL I6_NULL I6_NULL  0 20029
  ##Answer                            $$00011001  61 74 "answering" DA_Name "that" DA_Topic I6_NULL  0 20030
  ##Tell                              $$00011001  61 74 "telling" DA_Name "about" DA_Topic I6_NULL  0 20031
  ##Ask                               $$00011001  61 74 "asking" DA_Name "about" DA_Topic I6_NULL  0 20032
  ##AskFor                            $$00011011  61 61 "asking" DA_Name "for" DA_Name I6_NULL  0 20033
  ##Wait                              $$00000000  61 61 "waiting" I6_NULL I6_NULL I6_NULL I6_NULL  0 20034
  ##Touch                             $$00001001  61 61 "touching" DA_Name I6_NULL I6_NULL I6_NULL  0 20035
  ##Wave                              $$00001001  61 61 "waving" DA_Name I6_NULL I6_NULL I6_NULL  0 20036
  ##Pull                              $$00001001  61 61 "pulling" DA_Name I6_NULL I6_NULL I6_NULL  0 20037
  ##Push                              $$00001001  61 61 "pushing" DA_Name I6_NULL I6_NULL I6_NULL  0 20038
  ##Turn                              $$00001001  61 61 "turning" DA_Name I6_NULL I6_NULL I6_NULL  0 20039
  ##PushDir                           $$00011011  61 61 "pushing" DA_Name "to" DA_Name I6_NULL  0 20040
  ##Squeeze                           $$00001001  61 61 "squeezing" DA_Name I6_NULL I6_NULL I6_NULL  0 20041
  ##Yes                               $$00000000  61 61 "saying yes" I6_NULL I6_NULL I6_NULL I6_NULL  0 20042
  ##No                                $$00000000  61 61 "saying no" I6_NULL I6_NULL I6_NULL I6_NULL  0 20043
  ##Burn                              $$00001001  61 61 "burning" DA_Name I6_NULL I6_NULL I6_NULL  0 20044
  ##Wake                              $$00000000  61 61 "waking up" I6_NULL I6_NULL I6_NULL I6_NULL  0 20045
  ##Think                             $$00000000  61 61 "thinking" I6_NULL I6_NULL I6_NULL I6_NULL  0 20046
  ##Smell                             $$00001001  61 61 "smelling" DA_Name I6_NULL I6_NULL I6_NULL  0 20047
  ##Listen                            $$00001001  61 61 "listening to" DA_Name I6_NULL I6_NULL I6_NULL  0 20048
  ##Taste                             $$00001001  61 61 "tasting" DA_Name I6_NULL I6_NULL I6_NULL  0 20049
  ##Cut                               $$00001001  61 61 "cutting" DA_Name I6_NULL I6_NULL I6_NULL  0 20050
  ##Jump                              $$00000000  61 61 "jumping" I6_NULL I6_NULL I6_NULL I6_NULL  0 20051
  ##Tie                               $$00011011  61 61 "tying" DA_Name "to" DA_Name I6_NULL  0 20052
  ##Drink                             $$00001001  61 61 "drinking" DA_Name I6_NULL I6_NULL I6_NULL  0 20053
  ##Sorry                             $$00000000  61 61 "saying sorry" I6_NULL I6_NULL I6_NULL I6_NULL  0 20054
  ##Strong                            $$00000000  61 61 "swearing obscenely" I6_NULL I6_NULL I6_NULL I6_NULL  0 20055
  ##Mild                              $$00000000  61 61 "swearing mildly" I6_NULL I6_NULL I6_NULL I6_NULL  0 20056
  ##Swing                             $$00001001  61 61 "swinging" DA_Name I6_NULL I6_NULL I6_NULL  0 20057
  ##Rub                               $$00001001  61 61 "rubbing" DA_Name I6_NULL I6_NULL I6_NULL  0 20058
  ##SetTo                             $$00011001  61 74 "setting" DA_Name "to" DA_Topic I6_NULL  0 20059
  ##WaveHands                         $$00000000  61 61 "waving hands" I6_NULL I6_NULL I6_NULL I6_NULL  0 20060
  ##Buy                               $$00001001  61 61 "buying" DA_Name I6_NULL I6_NULL I6_NULL  0 20061
  ##Sing                              $$00000000  61 61 "singing" I6_NULL I6_NULL I6_NULL I6_NULL  0 20062
  ##Climb                             $$00001001  61 61 "climbing" DA_Name I6_NULL I6_NULL I6_NULL  0 20063
  ##Sleep                             $$00000000  61 61 "sleeping" I6_NULL I6_NULL I6_NULL I6_NULL  0 20064
  ##Score                             $$00100000  61 61 "requesting the score" I6_NULL I6_NULL I6_NULL I6_NULL  0 20065
  ##Quit                              $$00100000  61 61 "quitting the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20066
  ##Save                              $$00100000  61 61 "saving the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20067
  ##Restore                           $$00100000  61 61 "restoring the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20068
  ##Restart                           $$00100000  61 61 "restarting the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20069
  ##Verify                            $$00100000  61 61 "verifying the story file" I6_NULL I6_NULL I6_NULL I6_NULL  0 20070
  ##Version                           $$00100000  61 61 "requesting the story file version" I6_NULL I6_NULL I6_NULL I6_NULL  0 20071
  ##ScriptOn                          $$00100000  61 61 "switching the story transcript on" I6_NULL I6_NULL I6_NULL I6_NULL  0 20072
  ##ScriptOff                         $$00100000  61 61 "switching the story transcript off" I6_NULL I6_NULL I6_NULL I6_NULL  0 20073
  ##LMode3                            $$00100000  61 61 "preferring abbreviated room descriptions" I6_NULL I6_NULL I6_NULL I6_NULL  0 20074
  ##LMode2                            $$00100000  61 61 "preferring unabbreviated room descriptions" I6_NULL I6_NULL I6_NULL I6_NULL  0 20075
  ##LMode1                            $$00100000  61 61 "preferring sometimes abbreviated room descriptions" I6_NULL I6_NULL I6_NULL I6_NULL  0 20076
  ##Pronouns                          $$00100000  61 61 "requesting the pronoun meanings" I6_NULL I6_NULL I6_NULL I6_NULL  0 20077
  ##NotifyOn                          $$00100000  61 61 "switching score notification on" I6_NULL I6_NULL I6_NULL I6_NULL  0 20078
  ##NotifyOff                         $$00100000  61 61 "switching score notification off" I6_NULL I6_NULL I6_NULL I6_NULL  0 20079
;
[ ANSTVC_1 pos state;
  if (state == 1) {
    MStack-->pos = nothing
; pos++;
  } else {
    pos++;
  }
  return 1;
];
[ ANSTVC_7 pos state;
  if (state == 1) {
    MStack-->pos = O98_shrine; pos++;
    MStack-->pos = nothing
; pos++;
    MStack-->pos = nothing
; pos++;
    MStack-->pos = nothing
; pos++;
    MStack-->pos = nothing
; pos++;
  } else {
    pos++;
    pos++;
    pos++;
    pos++;
    pos++;
  }
  return 5;
];
[ ANSTVC_9 pos state;
  if (state == 1) {
    MStack-->pos = nothing
; pos++;
  } else {
    pos++;
  }
  return 1;
];
[ ANSTVC_11 pos state;
  if (state == 1) {
    MStack-->pos = ##Wait
; pos++;
    MStack-->pos = 0
; pos++;
    MStack-->pos = nothing
; pos++;
  } else {
    pos++;
    pos++;
    pos++;
  }
  return 3;
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Burn ##Wake ##Think ##Smell
    ##Listen ##Taste ##Cut ##Jump ##Tie ##Drink ##Sorry ##Strong
    ##Mild ##Swing ##Rub ##SetTo ##WaveHands ##Buy ##Sing ##Climb
    ##Sleep ##Score ##Quit ##Save ##Restore ##Restart ##Verify ##Version
    ##ScriptOn ##ScriptOff ##LMode3 ##LMode2 ##LMode1 ##Pronouns ##NotifyOn ##NotifyOff;


Array ActionHappened --> 0 0 0 0 0 0;


[ InvSub; return GenericVerbSub(113,114,115,1); ];
[ TakeSub; return GenericVerbSub(116,117,118,1); ];
[ RemoveSub; return GenericVerbSub(119,120,121,1); ];
[ DropSub; return GenericVerbSub(122,123,124,1); ];
[ PutOnSub; return GenericVerbSub(125,126,127,1); ];
[ InsertSub; return GenericVerbSub(128,129,130,1); ];
[ EatSub; return GenericVerbSub(131,132,133,1); ];
[ GoSub; return GenericVerbSub(134,135,136,1); ];
[ EnterSub; return GenericVerbSub(137,138,139,1); ];
[ ExitSub; return GenericVerbSub(140,141,142,1); ];
[ GetOffSub; return GenericVerbSub(143,144,145,1); ];
[ LookSub; return GenericVerbSub(146,147,148,1); ];
[ ExamineSub; return GenericVerbSub(149,150,151,1); ];
[ LookUnderSub; return GenericVerbSub(152,153,154,1); ];
[ SearchSub; return GenericVerbSub(155,156,157,1); ];
[ ConsultSub; return GenericVerbSub(158,159,160,1); ];
[ LockSub; return GenericVerbSub(161,162,163,1); ];
[ UnlockSub; return GenericVerbSub(164,165,166,1); ];
[ SwitchOnSub; return GenericVerbSub(167,168,169,1); ];
[ SwitchOffSub; return GenericVerbSub(170,171,172,1); ];
[ OpenSub; return GenericVerbSub(173,174,175,1); ];
[ CloseSub; return GenericVerbSub(176,177,178,1); ];
[ WearSub; return GenericVerbSub(179,180,181,1); ];
[ DisrobeSub; return GenericVerbSub(182,183,184,1); ];
[ GiveSub; return GenericVerbSub(185,186,187,1); ];
[ ShowSub; return GenericVerbSub(188,189,190,1); ];
[ WakeOtherSub; return GenericVerbSub(191,192,193,1); ];
[ ThrowAtSub; return GenericVerbSub(194,195,196,1); ];
[ AttackSub; return GenericVerbSub(197,198,199,1); ];
[ KissSub; return GenericVerbSub(200,201,202,1); ];
[ AnswerSub; return GenericVerbSub(203,204,205,1); ];
[ TellSub; return GenericVerbSub(206,207,208,1); ];
[ AskSub; return GenericVerbSub(209,210,211,1); ];
[ AskForSub; return GenericVerbSub(212,213,214,1); ];
[ WaitSub; return GenericVerbSub(215,216,217,1); ];
[ TouchSub; return GenericVerbSub(218,219,220,1); ];
[ WaveSub; return GenericVerbSub(221,222,223,1); ];
[ PullSub; return GenericVerbSub(224,225,226,1); ];
[ PushSub; return GenericVerbSub(227,228,229,1); ];
[ TurnSub; return GenericVerbSub(230,231,232,1); ];
[ PushDirSub; return GenericVerbSub(233,234,235,1); ];
[ SqueezeSub; return GenericVerbSub(236,237,238,1); ];
[ YesSub; return GenericVerbSub(239,240,241,1); ];
[ NoSub; return GenericVerbSub(242,243,244,1); ];
[ BurnSub; return GenericVerbSub(245,246,247,1); ];
[ WakeSub; return GenericVerbSub(248,249,250,1); ];
[ ThinkSub; return GenericVerbSub(251,252,253,1); ];
[ SmellSub; return GenericVerbSub(254,255,256,1); ];
[ ListenSub; return GenericVerbSub(257,258,259,1); ];
[ TasteSub; return GenericVerbSub(260,261,262,1); ];
[ CutSub; return GenericVerbSub(263,264,265,1); ];
[ JumpSub; return GenericVerbSub(266,267,268,1); ];
[ TieSub; return GenericVerbSub(269,270,271,1); ];
[ DrinkSub; return GenericVerbSub(272,273,274,1); ];
[ SorrySub; return GenericVerbSub(275,276,277,1); ];
[ StrongSub; return GenericVerbSub(278,279,280,1); ];
[ MildSub; return GenericVerbSub(281,282,283,1); ];
[ SwingSub; return GenericVerbSub(284,285,286,1); ];
[ RubSub; return GenericVerbSub(287,288,289,1); ];
[ SetToSub; return GenericVerbSub(290,291,292,1); ];
[ WaveHandsSub; return GenericVerbSub(293,294,295,1); ];
[ BuySub; return GenericVerbSub(296,297,298,1); ];
[ SingSub; return GenericVerbSub(299,300,301,1); ];
[ ClimbSub; return GenericVerbSub(302,303,304,1); ];
[ SleepSub; return GenericVerbSub(305,306,307,1); ];
[ ScoreSub; return GenericVerbSub(308,309,310,1); ];
[ QuitSub; return GenericVerbSub(311,312,313,1); ];
[ SaveSub; return GenericVerbSub(314,315,316,1); ];
[ RestoreSub; return GenericVerbSub(317,318,319,1); ];
[ RestartSub; return GenericVerbSub(320,321,322,1); ];
[ VerifySub; return GenericVerbSub(323,324,325,1); ];
[ VersionSub; return GenericVerbSub(326,327,328,1); ];
[ ScriptOnSub; return GenericVerbSub(329,330,331,1); ];
[ ScriptOffSub; return GenericVerbSub(332,333,334,1); ];
[ LMode3Sub; return GenericVerbSub(335,336,337,1); ];
[ LMode2Sub; return GenericVerbSub(338,339,340,1); ];
[ LMode1Sub; return GenericVerbSub(341,342,343,1); ];
[ PronounsSub; return GenericVerbSub(344,345,346,1); ];
[ NotifyOnSub; return GenericVerbSub(347,348,349,1); ];
[ NotifyOffSub; return GenericVerbSub(350,351,352,1); ];


! Verbs.i6 segment

[ AllowPushDir i oldrm newrm infl;
	if ((noun ofclass K2_thing) && (noun hasnt pushable))
		return L__M(##PushDir,1,noun);
	if (parent(second)~=compass) return L__M(##PushDir,2,noun);
	if (second==u_obj or d_obj)  return L__M(##PushDir,3,noun);
	AfterRoutines(); i=noun;
	if (actor notin noun) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = I7_RoomOf(noun);
	<Go second>;
	newrm = I7_RoomOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectHolder(i, player)) I7_TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
];

Global GVS_converted = -1;
[ GVS_Convert ac n s;
	GVS_converted = InformLibrary.begin_action(ac, n, s);
	rtrue;
];
[ GenericVerbSub ch co re any vis rv;
	@push GVS_converted;
	GVS_converted = -1;
	if (actor ~= player) {
		if (act_requester) {
			act_requester = nothing;
			if (ActionPrimitive() == false) {
				if (ProcessRulebook(UNABLE_RB) == false) {
					print (The) actor, " ", (IsOrAre) actor, " unable to do that.^^";
				}
		  }
			jump HappyEnding;
		}
		vis = I7_CanSee(player, actor);
		if ((noun ofclass K2_thing) && (~~(noun ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, noun));
		if ((second ofclass K2_thing) && (~~(second ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, second));
		if (rv=ProcessRulebook(GENERIC_CHECK_RB)) jump FailsUnlessConverted;
		if (any && (rv=ProcessRulebook(ch))) jump FailsUnlessConverted;
		if (deadflag) jump FailsUnlessConverted;
		if (ProcessRulebook(GENERIC_CARRYOUT_RB) == 0)
			if (any) ProcessRulebook(co);
		if (deadflag) jump FailsUnlessConverted;
		if (rv=ProcessRulebook(AFTER_RB)) jump HappyEnding;
		if (deadflag) jump FailsUnlessConverted;
		vis = vis || (I7_CanSee(player, actor));
		if ((noun ofclass K2_thing) && (~~(noun ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, noun));
		if ((second ofclass K2_thing) && (~~(second ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, second));
		if (keep_silent || (vis==false)) jump HappyEnding;
		if (rv=ProcessRulebook(GENERIC_REPORT_RB)) jump HappyEnding;
		if (deadflag) jump FailsUnlessConverted;
		if (any) rv=ProcessRulebook(re);
		jump HappyEnding;
	}
	if ((rv=ProcessRulebook(GENERIC_CHECK_RB)) || (rv=ProcessRulebook(ch)))
		jump FailsUnlessConverted;
	if (deadflag) jump FailsUnlessConverted;
	if (ProcessRulebook(GENERIC_CARRYOUT_RB) == 0) ProcessRulebook(co);
	if (deadflag) jump FailsUnlessConverted;
	if (meta) say__p = 0;
	else {
		if (rv=ProcessRulebook(AFTER_RB)) jump HappyEnding;
		if (deadflag) jump FailsUnlessConverted;
	}
	if (keep_silent) jump HappyEnding;
	if (rv=ProcessRulebook(GENERIC_REPORT_RB)) jump HappyEnding;
	rv=ProcessRulebook(re);
	.HappyEnding;
	ActRulebookSucceeds(rv);
	@pull GVS_converted;
	rtrue;
	.FailsUnlessConverted;
	if (GVS_converted == 1) jump HappyEnding;
	ActRulebookFails(rv);
	@pull GVS_converted;
	rtrue;
];

[ GL__M a b c; if ((actor ~= player) || (untouchable_silence)) rtrue;
	return L__M(a,b,c); ];
[ HisHerTheir o; if (o has pluralname) { print "their"; return; }
	if (o has female) { print "her"; return; }
	print "his"; ];

! Object movements

Global ac_common_ancestor;
Global take_after_recipient;
[ TakeSub_C1;
	if (onotheld_mode==1 && noun in actor) {
		RulebookSucceeds(); rtrue; } rfalse; ];
[ TakeSub_C2;
	if (noun == actor) return GL__M(##Take,2); rfalse; ];
[ TakeSub_C3;
	if (noun has animate) return GL__M(##Take,3,noun); rfalse; ];
[ TakeSub_C4 i;
!  if (noun provides component_parent)
!		return GL__M(##Take,7,noun.component_parent);
	ac_common_ancestor = OIU_CommonAncestor(actor, noun);
	if (ac_common_ancestor == 0) {
		i = ObjectScopedBySomething(noun);
		if (i ~= 0) ac_common_ancestor = CommonAncestor(actor, i);
	} rfalse; ];

[ OIUB_AP i;
	if (noun ~= ac_common_ancestor) {
		i = OIU_Parent(noun);
		while (i~=ac_common_ancestor && i) {
			if (i has animate) return GL__M(##Take,6,i);
			i = OIU_Parent(i);
		}
	}
	rfalse;
];

![ TakeSub_C5;
!  if (ac_common_ancestor == 0) return GL__M(##Take,8,noun); rfalse; ];
[ TakeSub_C6;
	if (ac_common_ancestor == noun) return GL__M(##Take,4,noun); rfalse; ];
[ TakeSub_C7;
	if (noun in actor) return GL__M(##Take,5,noun); rfalse; ];
[ TakeSub_C8 i k;
	i=parent(noun); take_after_recipient = 0;
	if (i && (i ~= ac_common_ancestor) && (i has container || i has supporter))
	{   take_after_recipient=i;
		k=action; action=##LetGo;
		if (RunRoutines(i,before)~=0) { action=k; rtrue; }
		action=k;
	} rfalse; ];
[ TakeSub_C9;
	if (noun has scenery) return GL__M(##Take,10,noun); rfalse; ];
[ TakeSub_C10;
	if (noun has static)  return GL__M(##Take,11,noun); rfalse; ];
[ TakeSub_C11 j k ks;
	if (SACK_OBJECT == nothing || SACK_OBJECT notin actor) rfalse;
	k=0; objectloop (j in actor) if (j hasnt worn) k++;
	if (k >= ValueOrRun(actor,capacity)) {
		j=0;
		objectloop (k in actor) 
			if (k~=SACK_OBJECT && k hasnt worn && k hasnt light) j=k;
		if (j~=0) {
			GL__M(##Take,13,j);
			ks = keep_silent;
			keep_silent = 1; <Insert j SACK_OBJECT>; keep_silent = ks;
			if (j notin SACK_OBJECT) rtrue;
			rfalse;
		}
	} rfalse; ];
[ TakeSub_C12 j k;
	k=0; objectloop (j in actor) if (j hasnt worn) k++;
	if (k >= ValueOrRun(actor,capacity)) return GL__M(##Take,12);
	rfalse; ];
[ TakeSub_O1 rest i;
!  if ((noun provides component_parent) && (rest = (noun.component_parent))) {
!		noun.component_parent = nothing;
!		if (rest provides add_to_scope) {
!			for (i=0: i<(rest.#add_to_scope)/2: i++) {
!			    if ((rest.&add_to_scope)-->i == noun)
!					  (rest.&add_to_scope)-->i = nothing;
!			}
!		}
!  }
!  move noun to actor;
	I7_Move(noun, actor);
	rfalse; ];
[ TakeSub_O2 k;
	if (take_after_recipient) {
		k=action; action=##LetGo;
		if (RunRoutines(take_after_recipient,after)~=0) { action=k; rtrue; }
		action=k;
	} rfalse; ];
[ TakeSub_R1;
	if (actor == player) {
		notheld_mode=onotheld_mode;
		if (notheld_mode==1) { RulebookSucceeds(); rtrue; }
	}
	rfalse; ];
[ TakeSub_R2;
	if (player == actor) return GL__M(##Take, 1);
	print (The) actor, " picks up ", (the) noun, ".^^";
];

[ RemoveSub_C1 i;
	i=parent(noun);
	if (i has container && i hasnt open) return GL__M(##Remove,1,noun);
	rfalse; ];
[ RemoveSub_C2 i;
	i=parent(noun); if (i~=second) return GL__M(##Remove,2,noun);
	rfalse; ];
[ RemoveSub_C3 i;
	i=parent(noun); if (i has animate) return GL__M(##Take,6,i);
	rfalse; ];
[ RemoveSub_C4;
	return GVS_Convert(##Take, noun, 0);
];

[ DropSub_C1;
	if (noun == actor) return GL__M(##PutOn, 4); rfalse; ];
[ DropSub_C2;
	if (noun in parent(actor)) return GL__M(##Drop,1,noun); rfalse; ];
[ DropSub_C3;
	if (noun notin actor) return GL__M(##Drop,2,noun); rfalse; ];
[ DropSub_C4 k;
	if (noun has worn) { GL__M(##Drop,3,noun); say__p=0;
		k = keep_silent; keep_silent = 1; <Disrobe noun>;
		keep_silent = k;
		if (noun has worn && noun in actor) rtrue;
	} rfalse; ];
[ DropSub_C5 p;
	p = parent(actor);
	if (p ofclass K1_room) rfalse;
	if (children(p) < ValueOrRun(p,capacity)) rfalse;
	if (actor ~= player) rtrue;
	print "There is no more room ";
	if (p has supporter) print "on "; else print "in ";
	print (the) p, ".^^"; rtrue; ];

[ DropSub_O1; I7_Move(noun, parent(actor)); give noun ~worn; rfalse; ];
[ DropSub_R1;
	if (player == actor) return GL__M(##Drop,4,noun);
	print (The) actor, " puts down ", (the) noun, ".^^";
];

[ PutOnSub_C1;
	if (second == d_obj || actor in second) return GVS_Convert(##Drop, noun, 0);
	rfalse; ];
[ PutOnSub_C2;
	if (parent(noun)~=actor) return GL__M(##PutOn,1,noun); rfalse; ];
[ PutOnSub_C3;
	if (OIU_Core(noun) == OIU_Core(second)) return GL__M(##PutOn,2,noun);
	ac_common_ancestor = OIU_CommonAncestor(noun, second);
	if (ac_common_ancestor == noun) return GL__M(##PutOn,2,noun); rfalse; ];
[ PutOnSub_C4;
	if (second ~= ac_common_ancestor)
	{   action=##Receive; receive_action=##PutOn;
		if (RunRoutines(second,before)~=0) { action=##PutOn; return; }
		action=##PutOn;
	} rfalse; ];
[ PutOnSub_C5;
	if (second hasnt supporter) return GL__M(##PutOn,3,second); rfalse; ];
[ PutOnSub_C6;
	if (ac_common_ancestor == actor) return GL__M(##PutOn,4); rfalse; ];
[ PutOnSub_C7 k;
	if (noun has worn) { GL__M(##PutOn,5,noun); say__p=0;
		k = keep_silent; keep_silent = 1; <Disrobe noun>; keep_silent = k;
		if (noun has worn) rtrue; } rfalse; ];
[ PutOnSub_C8;
	if (children(second)>=ValueOrRun(second,capacity))
		return GL__M(##PutOn,6,second); rfalse; ];
[ PutOnSub_O1; move noun to second; give noun ~worn; rfalse; ];
[ PutOnSub_O2;
	if (second ~= ac_common_ancestor)
	{   action=##Receive;
		if (RunRoutines(second,after)~=0) { action=##PutOn; return; }
		action=##PutOn;
	} rfalse; ];
[ PutOnSub_R1;
	if (player == actor) {
		if (multiflag==1) return GL__M(##PutOn,7);
		return GL__M(##PutOn,8,noun);
	} else {
		print (The) actor, " puts ", (the) noun, " on ", (the) second, ".^^";
		rtrue;
	}
];

[ InsertSub_C1;
	if (second==d_obj || actor in second) return GVS_Convert(##Drop, noun, 0);; rfalse; ];
[ InsertSub_C2;
	if (parent(noun)~=actor) return GL__M(##Insert,1,noun); rfalse; ];
[ InsertSub_C3;
	if (OIU_Core(noun) == OIU_Core(second)) return GL__M(##Insert, 5, noun);
	ac_common_ancestor = OIU_CommonAncestor(noun, second);
	if (ac_common_ancestor == noun) return GL__M(##Insert, 5, noun); rfalse; ];
[ InsertSub_C4;
	if (second ~= ac_common_ancestor) {
		action=##Receive; receive_action = ##Insert;
		if (RunRoutines(second,before)~=0) { action=##Insert; rtrue; }
		action=##Insert;
	} rfalse; ];
[ InsertSub_C5;
	if (second ~= ac_common_ancestor) {
		if (second has container && second hasnt open)
			return GL__M(##Insert,3,second);
	} rfalse; ];
[ InsertSub_C6;
	if (second hasnt container) return GL__M(##Insert,2,second); rfalse; ];
[ InsertSub_C7 k;
	if (noun has worn) {
		GL__M(##Insert,6,noun);
		say__p=0; k = keep_silent; keep_silent = 1; <Disrobe noun>;
		keep_silent = k; if (noun has worn) rtrue;
	} rfalse; ];
[ InsertSub_C8;
	if (children(second) >= ValueOrRun(second,capacity))
		return GL__M(##Insert,7,second); rfalse; ];
[ InsertSub_O1; move noun to second; give noun ~worn; rfalse; ];
[ InsertSub_O2;
	if (second ~= ac_common_ancestor) {
		action=##Receive;
		if (RunRoutines(second,after)~=0) { action=##Insert; rtrue; }
		action=##Insert;
	} rfalse; ];
[ InsertSub_R1;
	if (actor == player) {
		if (multiflag==1) return GL__M(##Insert,8,noun);
		GL__M(##Insert,9,noun);
	} else {
		print (The) actor, " puts ", (the) noun, " into ", (the) second, ".^^";
	}
	rtrue; ];


[ ScoreSub_O1;
	if (actor ~= player) rfalse;
	#ifdef I7_NOSCORE; "[There is no numerical score.]";
	#ifnot; GL__M(##Score); PrintRank();
	#endif;
];
[ FullScoreSub_O1 i;
	if (actor ~= player) rfalse;
	ScoreSub_O1();
	#ifndef I7_NOSCORE;
	if (score==0 || TASKS_PROVIDED==1) rfalse;
	new_line;
	GL__M(##FullScore,1);

	for (i=0:i<NUMBER_TASKS:i++)
		if (task_done->i==1)
		{   PANum(task_scores->i);
			PrintTaskName(i);
		}
	
	if (things_score~=0)
	{   PANum(things_score); GL__M(##FullScore,2); }
	if (places_score~=0)
	{   PANum(places_score); GL__M(##FullScore,3); }
	new_line; PANum(score); GL__M(##FullScore,4);
	#endif;
];

#ifdef TARGET_ZCODE;

[ QuitSub_O1; if (actor ~= player) rfalse;
	GL__M(##Quit,2); if (YesOrNo()~=0) quit; ];

[ RestartSub_O1;
	if (actor ~= player) rfalse;
	GL__M(##Restart,1);
	if (YesOrNo()~=0) { @restart; GL__M(##Restart,2); }
];

[ RestoreSub_O1;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	return GL__M(##Restore,1);
	.RMaybe; GL__M(##Restore,2);
];

[ SaveSub_O1 flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: GL__M(##Save,1);
		1: GL__M(##Save,2);
		2: GL__M(##Restore,2);
	}
	#IFNOT;
	save Smaybe;
	return GL__M(##Save,1);
	.SMaybe; GL__M(##Save,2);
	#ENDIF;
];

[ VerifySub_O1;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; return GL__M(##Verify,1);
	.Vwrong;
	GL__M(##Verify,2);
];

[ ScriptOnSub_O1;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) return GL__M(##ScriptOn,1);
	@output_stream 2;
	if (((0-->8) & 1) == 0) return GL__M(##ScriptOn,3);
	GL__M(##ScriptOn,2); VersionSub();
	transcript_mode = true;
];

[ ScriptOffSub_O1;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff,2);
	@output_stream -2;
	if ((0-->8) & 1) return GL__M(##ScriptOff,3);
	transcript_mode = false;
];

#ifnot; ! TARGET_GLULX

[ QuitSub_O1;
	if (actor ~= player) rfalse;
	GL__M(##Quit, 2); if (YesOrNo()~=0) quit; ];

[ RestartSub_O1;
	if (actor ~= player) rfalse;
	GL__M(##Restart, 1);
	  if (YesOrNo() ~= 0) {
		  @restart;
		  GL__M(##Restart, 2);
	  }
];

[ RestoreSub_O1 res fref;
	if (actor ~= player) rfalse;
	fref = glk($0062, $01, $02, 0); ! fileref_create_by_prompt
	  if (fref == 0) jump RFailed;
	  gg_savestr = glk($0042, fref, $02, GG_SAVESTR_ROCK); ! stream_open_file
	  glk($0063, fref); ! fileref_destroy
	  if (gg_savestr == 0) jump RFailed;
	  @restore gg_savestr res;
	  glk($0044, gg_savestr, 0); ! stream_close
	  gg_savestr = 0;
	.RFailed;
	  GL__M(##Restore, 1);
];

[ SaveSub_O1 res fref;
	if (actor ~= player) rfalse;
	fref = glk($0062, $01, $01, 0); ! fileref_create_by_prompt
	  if (fref == 0) jump SFailed;
	  gg_savestr = glk($0042, fref, $01, GG_SAVESTR_ROCK); ! stream_open_file
	  glk($0063, fref); ! fileref_destroy
	  if (gg_savestr == 0) jump SFailed;
	  @save gg_savestr res;
	  if (res == -1) {
		  ! The player actually just typed "restore". We're going to print
		  !  GL__M(##Restore,2); the Z-Code Inform library does this correctly
		  ! now. But first, we have to recover all the Glk objects; the values
		  ! in our global variables are all wrong.
		  GGRecoverObjects();
		  glk($0044, gg_savestr, 0); ! stream_close
		  gg_savestr = 0;
		  return GL__M(##Restore, 2);
	  }
	  glk($0044, gg_savestr, 0); ! stream_close
	  gg_savestr = 0;
	  if (res == 0) return GL__M(##Save, 2);
	.SFailed;
	  GL__M(##Save, 1);
];

[ VerifySub_O1 res;
	if (actor ~= player) rfalse;
	@verify res;
	  if (res == 0) return GL__M(##Verify, 1);
	  GL__M(##Verify, 2);
];

[ ScriptOnSub_O1;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) return GL__M(##ScriptOn, 1);
	  if (gg_scriptfref == 0) {
		  ! fileref_create_by_prompt
		  gg_scriptfref = glk($0062, $102, $05, GG_SCRIPTFREF_ROCK);
		  if (gg_scriptfref == 0) jump S1Failed;
	  }
	  ! stream_open_file
	  gg_scriptstr = glk($0042, gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	  if (gg_scriptstr == 0) jump S1Failed;
	  glk($002D, gg_mainwin, gg_scriptstr); ! window_set_echo_stream
	  GL__M(##ScriptOn, 2);
	  VersionSub();
	  return;
	.S1Failed;
	  GL__M(##ScriptOn, 3);
];

[ ScriptOffSub_O1;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) return GL__M(##ScriptOff,1);
	  GL__M(##ScriptOff, 2);
	  glk($0044, gg_scriptstr, 0); ! stream_close
	  gg_scriptstr = 0;
];

#endif; ! TARGET_

[ VersionSub_O1 ix;
	if (actor ~= player) rfalse;
	Banner();
	  #ifdef NI_BUILD_COUNT;
	  print "Identification number: ";
	  for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	  print "^";
	  #endif; ! NI_BUILD_COUNT
	  #Ifdef TARGET_ZCODE;
	  ix = 0; ! shut up compiler warning
	  if (standard_interpreter > 0) {
		  print "Standard interpreter ", standard_interpreter/256, ".", standard_interpreter%256,
			  " (", HDR_TERPNUMBER->0;
		  #Iftrue (#version_number == 6);
		  print (char) '.', HDR_TERPVERSION->0;
		  #Ifnot;
		  print (char) HDR_TERPVERSION->0;
		  #Endif;
		  print ") / ";
		  }
	  else {
		  print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		  #Iftrue (#version_number == 6);
		  print HDR_TERPVERSION->0;
		  #Ifnot;
		  print (char) HDR_TERPVERSION->0;
		  #Endif;
		  print " / ";
	  }

	  #Ifnot; ! TARGET_GLULX;
	  @gestalt 1 0 ix;
	  print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	  ".", ix & $FF, " / ";
	  @gestalt 0 0 ix;
	  print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	  #Endif; ! TARGET_;
	  print "Library serial number ", (string) LibSerial, "^";
	  #Ifdef LanguageVersion;
	  print (string) LanguageVersion, "^";
	  #Endif; ! LanguageVersion
	  #ifdef I7ExtensionVersions;
	  I7ExtensionVersions();
	  #endif;
];

[ NotifyOnSub_O1;
	if (actor ~= player) rfalse;
	#ifdef I7_NOSCORE; ScoreSub_O1(); #ifnot;
	notify_mode=1; GL__M(##NotifyOn); #endif; ];
[ NotifyOffSub_O1;
	if (actor ~= player) rfalse;
	#ifdef I7_NOSCORE; ScoreSub_O1(); #ifnot;
	notify_mode=0; GL__M(##NotifyOff); #endif; ];
[ LMode1Sub_O1;
	if (actor ~= player) rfalse;
	lookmode=1; print (string) Story; GL__M(##LMode1); ];  ! Brief

[ LMode2Sub_O1;
	if (actor ~= player) rfalse;
	lookmode=2; print (string) Story; GL__M(##LMode2); ];  ! Verbose

[ LMode3Sub_O1;
	if (actor ~= player) rfalse;
	lookmode=3; print (string) Story; GL__M(##LMode3); ];  ! Superbrief
[ PronounsSub_O1 x y c d;
	if (actor ~= player) rfalse;
	GL__M(##Pronouns, 1);

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) return GL__M(##Pronouns, 4);

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3)
	{   print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) GL__M(##Pronouns, 3);
		else { GL__M(##Pronouns, 2); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) print (string) AND__TX;
	}
	if (player ~= selfobj)
	{   print "~", (address) ME1__WD, "~ "; GL__M(##Pronouns, 2);
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];

! End of Verbs.i6

	
! --- List together routines ---


[ Initialise pp;
	CreatePropertyOffsets();
	I7_Blk_Initialise(); I7_Initial_Heap_Allocation(); I7_Create_Blk_Consts();
  if ((pp=selfobj) ~= selfobj) {
  if (parent(pp) == nothing) {
  move pp to O98_shrine;
  }
  ChangePlayer(pp);
} else {
  location = O98_shrine;
}
  the_time = 540
;

	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	InformLibrary.end_turn_sequence = TurnEndPrimitive;
	TimePasses(); TS6_R();
	print "^^";
	! ensure that visibility, etc., is correct for when play begins rules
	move player to location;
	real_location = location;
	I7_uninitialised = true;
	FollowRulebook(GAME_BEGINS_RB);
	pp = parent(player);
	if (pp ofclass K1_room) location = pp;
	else if (pp ofclass K2_thing) location = pp;
	if (pp) remove player; ! let the I6 library reposition the player
	I7_uninitialised = false;
];

[ DeathMessage;
	if (deadflag ofclass Routine) (deadflag)();
	if (deadflag ofclass String) print (string) deadflag;
];

[ AfterLife;
	FollowRulebook(GAME_ENDS_RB);
];

[ TimePasses;
	ChronologyTurnEnd();
];

[ ParserError error_type;
	if (error_type ofclass String) print_ret (string) error_type;
	if (error_type ofclass Routine) { error_type.call(); new_line; rtrue; }
	rfalse;
];

! ChooseObjects.i6 segment

!Constant COBJ_DEBUG;

Constant MATCH_LIST_WORDS = (MATCH_LIST_SIZE/2);
Constant COBJ_BITS_SIZE = (MATCH_LIST_WORDS*MATCH_LIST_WORDS/8);

! the highest value returned by I7_CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 4;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i--) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];

[ ChooseObjects obj code  l i swn spcount;
	if (code<2) rfalse;

	if (cobj_flag == 1) {
		.CodeOne;
		if (parameters > 0) {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (second)]^";
			#endif;
			return ScoreDabCombo(inputobjs-->2, obj);
		} else {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (first) in ",
				alt_match_list-->0, " combinations]^";
			#endif;
			l = 0;
			for (i=1: i<=alt_match_list-->0: i++) {
				spcount = ScoreDabCombo(obj, alt_match_list-->i);
				if (spcount == HIGHEST_DPMR_SCORE) {
					#ifdef COBJ_DEBUG;
					print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			return l;
		}
	}
	if (cobj_flag == 2) {
		.CodeTwo;
		#ifdef COBJ_DEBUG;
		print "[scoring ", (the) obj, " (simple)]^";
		#endif;
		if (parameters==0)
			return ScoreDabCombo(obj, 0);
		else
			return ScoreDabCombo(inputobjs-->2, obj);
	}

	#ifdef COBJ_DEBUG;
	print "[choosing a cobj strategy: ";
	#endif;
	swn = wn;
	if (line_ttype-->pcount == PREPOSITION_TT) {
		spcount = pcount;
		while (line_ttype-->pcount == PREPOSITION_TT) pcount++;
		if ((line_ttype-->pcount == ELEMENTARY_TT) && (line_tdata-->pcount == NOUN_TOKEN)) {
			! Advance past the last preposition
			while (wn < num_words) {
				l = NextWord();
				if ( l && (l->#dict_par1) &8 ) {	! if preposition
					if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) continue;
					SafeSkipDescriptors();
					! save the current match state
					@push match_length; @push match_from; @push placed_in_flag;
					alt_match_list-->0 = number_matched;
					COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);
					! now get all the matches for the second noun
					match_length = 0; number_matched = 0; match_from = wn; placed_in_flag = 0;
					SearchScope(actor, actors_location, line_tdata-->pcount);
					#ifdef COBJ_DEBUG;
					print number_matched, " possible second nouns]^";
					#endif;
					wn = swn;
					cobj_flag = 1;
					! restore match variables
					COBJ__SwapMatches();
					@pull placed_in_flag; @pull match_from; @pull match_length;
					pcount = spcount;
					jump CodeOne;
				}
			}
		}
		pcount = spcount;
	}
	wn = swn;	
	
	#ifdef COBJ_DEBUG;
	print "nothing interesting]^";
	#endif;
	cobj_flag = 2;
	jump CodeTwo;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];

[ ScoreDabCombo a b  result;
	@push action; @push noun; @push second;
	action = action_to_be;
	if (action_reversed) {
		noun = b; second = a;
	} else {
		noun = a; second = b;
	}
	result = I7_CheckDPMR();
	@pull second; @pull noun; @pull action;
	#ifdef COBJ_DEBUG;
	print "[", (the) a, " / ", (the) b, " => ", result, "]^";
	#endif;
	return result;
];

! End of ChooseObjects.i6 segment


[ I7ReadUseOption UO;
  if (UO == 0) rtrue;
  rfalse;
];




! Chronology.i6 segment


[ TrackActions adjust ct_0 ct_1;

];

[ ChronologyTurnEnd pt; ! Called from TimePasses()
	for (pt=0:pt<NO_PAST_TENSES:pt++) ChronologyRecord(0, pt, true);
	ChronologyPoint();
];

[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSES:pt++) past_tense-->pt = present_tense-->pt;
];

[ ChronologyRecord tense pt turn_end wanted old new trips consecutives ct_0 ct_1;
	if (tense == 1) {
		new = (past_tense-->pt) & 1;
		trips = ((past_tense-->pt) & $$11111110)/2;
		consecutives = ((past_tense-->pt) & $$111111100000000)/256;
	} else {
		! print "PT-->pt = ", (present_tense-->pt), "^";
		old = (present_tense-->pt) & 1;
		trips = ((present_tense-->pt) & $$11111110)/2;
		consecutives = ((present_tense-->pt) & $$111111100000000)/256;
		switch(pt) {

		}
		! print pt,":o=",old," n=",new," t=",trips," c=",consecutives,"^";
		if ((old == 0) && (new == 1)) {
			trips++;
			if (trips > 127) trips = 127;
		}
		if (new == 0) consecutives=0;
		if ((new == 1) && (turn_end)) {
			consecutives++;
			if (consecutives > 127) consecutives = 127;
		}
		present_tense-->pt = new + 2*trips + 256*consecutives;
	}
	if ((wanted < 8) && (new == 0)) return 0;
	switch(wanted%8) { 0: return new;
		1: return trips;
		2: return consecutives;
	}
];

Constant NO_PAST_TENSES 0;
Constant NO_PAST_ACTIONS 0;


Array TimesActionHasHappened-->(NO_PAST_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_ACTIONS+1);

Array past_tense-->(NO_PAST_TENSES+1);
Array present_tense-->(NO_PAST_TENSES+1);

! End of Chronology.i6 segment





Constant SUPPRESS_ACTION_GRAMMAR;

#IFTRUE (0 == 1);
[ UnknownVerb;
	verb_wordnum = 0; return 'no.verb';
];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#ENDIF;

Include "Grammar";





[ I7_NUMBER_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
	wnc = wn; original_wn = wn; group_wn = wn;

	wn = wnc;
	r = I7_ParseToken(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10:
#IFDEF TARGET_ZCODE;
				if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
#IFNOT; ! TARGET_GLULX
				if (digit_count == 11) return GPR_FAIL;
				if (digit_count == 10) {
					if (n > 214748364) return GPR_FAIL;
					if (n == 214748364) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
#ENDIF; 
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];
! Time.i6 segment

[ RoundOffTime t1 t2; return ((t1+t2/2)/t2)*t2; ];

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= 60*12) { aop = "pm"; t=t-60*12; } else aop = "am";
	h = t/60; if (h==0) h=12;
	print h, ":";
	if (t%60<10) print "0"; print t%60, " ", (string) aop;
];

[ PrintTimeOfDayEnglish t h m dir aop;
	h = (t/60) % 12; m = t%60; if (h==0) h=12;
	if (m==0) { print (number) h, " o'clock"; return; }
	dir = "past";
	if (m > 30) { m = 60-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
	switch(m) {
		15: print "quarter"; 30: print "half";
		default: print (number) m;
		    if (m%5 ~= 0) {
					if (m == 1) print " minute"; else print " minutes";
		    }
	}
	print " ", (string) dir, " ", (number) h;
];

Constant I7_TWELVE_HOURS = 720;

[ I7_HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= 60) return -1;
	x = hour*60 + minute; if (hour >= 13) return x;
	x = x%I7_TWELVE_HOURS; if (word == 'pm') x = x + I7_TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + I7_TWELVE_HOURS;
	return x;
];

[ I7_ExtendedTryNumber wordnum i j;
	i = wn; wn = wordnum; j = NextWordStopped(); wn = i;
	switch (j) {
		'twenty-one': return 21;
		'twenty-two': return 22;
		'twenty-three': return 23;
		'twenty-four': return 24;
		'twenty-five': return 25;
		'twenty-six': return 26;
		'twenty-seven': return 27;
		'twenty-eight': return 28;
		'twenty-nine': return 29;
		'thirty': return 30;
		default: return TryNumber(wordnum);
	}
];

[ I7_TIME_TOKEN first_word second_word at length flag
	illegal_char offhour hr mn i original_wn;
	original_wn = wn;

	wn = original_wn;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = I7_TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = I7_HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = 30;
	if (first_word == 'quarter') offhour = 15;
	if (offhour < 0) offhour = I7_ExtendedTryNumber(wn-1);
	if (offhour < 0 || offhour >= 60) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = I7_ExtendedTryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = 60-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = I7_ExtendedTryNumber(--wn);
			if (mn < 0 || mn >= 60) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = I7_HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ SetI7Timer R t f i b;
	for (i=1: i<=(I7TimerTable-->0): i++) {
		if (R == I7TimerTable-->i) { b=i; jump SlotFound; }
		if ((b==0) && (I7TimerTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	.SlotFound;
	I7TimerTable-->b = R;
	if (f == 0) I7TimerTableTimes-->b = -t;
	else I7TimerTableTimes-->b = t;
];

[ ProcessI7Timers i t f r;
	for (i=1: i<=(I7TimerTable-->0): i++)
		if ((r=I7TimerTable-->i) ~= 0) {
			t = I7TimerTableTimes-->i; f = 0;
			if (t<0) {
					(I7TimerTableTimes-->i)++;
					if (I7TimerTableTimes-->i == 0) f=1;
			} else {
					if ((the_time >= t) && (the_time < t+30)) f=1;
			}
			if (f) {
					I7TimerTable-->i = 0;
					ProcessRulebook(r);
			}
		}
	rfalse;
];

! --- Turn sequence rules ---
[ TS1_R; AdvanceWorldClock(); rfalse; ];
[ TS2_R; RunTimersAndDaemons(); rfalse; ];
[ TS3_R; RunEachTurnProperties(); rfalse; ];
[ TS4_R; TimePasses(); rfalse; ];
[ TS5_R; AdjustLight(); rfalse; ];
[ TS6_R obj;
	NoteObjectAcquisitions();
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	objectloop (obj ofclass RUCKSACK_CLASS && obj provides component_parent
		&& obj.component_parent == player)
		SACK_OBJECT = obj;
	rfalse;
];

! End of Time.i6 segment





[ Noun_Filter_0 x; x=noun;
  return ((noun ofclass K3_direction)); ];
[ Noun_Filter_1 x; x=noun;
  return ((noun ofclass K3_direction)); ];
[ Noun_Filter_2 x; x=noun;
  return ((noun ofclass K3_direction)); ];



Verb 'take//' 'carry//' 'hold//'
   * 'inventory//'  -> Inv
   * multi  -> Take
   * 'off//' noun  -> Disrobe
   * multiinside 'off//' noun  -> Remove
   * multiinside 'from//' noun  -> Remove
;
Verb 'get//'
   * 'out//' / 'off//' / 'up//'  -> Exit
   * multi  -> Take
   * 'off//' noun  -> GetOff
   * 'in//' / 'into//' / 'on//' / 'onto//' noun  -> Enter
   * multiinside 'from//' noun  -> Remove
;
Verb 'pick//'
   * multi 'up//'  -> Take
   * 'up//' multi  -> Take
;
Verb 'stand//'
   *  -> Exit
   * 'up//'  -> Exit
   * 'on//' noun  -> Enter
;
Verb 'remove//'
   * held  -> Disrobe
   * multiinside 'from//' noun  -> Remove
;
Verb 'shed//' 'doff//' 'disrobe//'
   * held  -> Disrobe
;
Verb 'wear//' 'don//'
   * held  -> Wear
;
Verb 'put//'
   * 'on//' held  -> Wear
   * multiheld 'down//'  -> Drop
   * 'down//' multiheld  -> Drop
   * multiexcept 'on//' / 'onto//' noun  -> PutOn
   * multiexcept 'in//' / 'inside//' / 'into//' noun  -> Insert
;
Verb 'insert//'
   * multiexcept 'in//' / 'into//' noun  -> Insert
;
Verb 'drop//' 'throw//' 'discard//'
   * multiheld  -> Drop
   * held 'at//' / 'against//' / 'on//' / 'onto//' noun  -> ThrowAt
   * multiexcept 'on//' / 'onto//' noun  -> PutOn
   * multiexcept 'in//' / 'into//' / 'down//' noun  -> Insert
;
Verb 'give//' 'pay//' 'offer//' 'feed//'
   * creature held  -> Give reverse
   * held 'to//' creature  -> Give
;
Verb 'show//' 'present//' 'display//'
   * creature held  -> Show reverse
   * held 'to//' creature  -> Show
;
Verb 'go//' 'walk//' 'leave//' 'run//'
   *  -> Go
   * noun=Noun_Filter_0  -> Go
   * noun  -> Enter
   * 'into//' / 'in//' / 'inside//' / 'through//' noun  -> Enter
;
Verb 'inventory//' 'i//' 'inv//'
   *  -> Inv
;
Verb 'look//' 'l//'
   *  -> Look
   * 'under//' noun  -> LookUnder
   * 'inside//' / 'in//' / 'into//' / 'through//' noun  -> Search
   * 'at//' noun  -> Examine
   * 'up//' topic 'in//' noun  -> Consult reverse
;
Verb 'consult//'
   * noun 'on//' / 'about//' topic  -> Consult
;
Verb 'open//' 'unwrap//' 'uncover//'
   * noun  -> Open
   * noun 'with//' held  -> Unlock
;
Verb 'close//' 'shut//' 'cover//'
   * noun  -> Close
   * 'off//' noun  -> SwitchOff
   * 'up//' noun  -> Close
;
Verb 'enter//' 'cross//'
   * noun  -> Enter
;
Verb 'sit//'
   * 'on//' / 'in//' / 'inside//' noun  -> Enter
   * 'on//' 'top//' 'of//' noun  -> Enter
;
Verb 'exit//' 'out//'
   *  -> Exit
;
Verb 'examine//' 'x//' 'watch//' 'describe//' 'check//'
   * noun  -> Examine
;
Verb 'read//'
   * noun  -> Examine
   * 'about//' topic 'in//' noun  -> Consult reverse
   * topic 'in//' noun  -> Consult reverse
;
Verb 'yes//' 'y//'
   *  -> Yes
;
Verb 'no//'
   *  -> No
;
Verb 'sorry//'
   *  -> Sorry
;
Verb 'shit//' 'fuck//' 'damn//'
   *  -> Strong
;
Verb 'bother//' 'curses//' 'drat//' 'darn//'
   *  -> Mild
;
Verb 'search//'
   * noun  -> Search
;
Verb 'wave//'
   *  -> WaveHands
   * noun  -> Wave
;
Verb 'set//' 'adjust//'
   * noun 'to//' topic  -> SetTo
;
Verb 'pull//' 'drag//'
   * noun  -> Pull
;
Verb 'push//' 'move//' 'shift//' 'clear//' 'press//'
   * noun  -> Push
   * noun noun=Noun_Filter_1  -> PushDir
   * noun 'to//' noun=Noun_Filter_2  -> PushDir
;
Verb 'turn//' 'rotate//' 'twist//' 'unscrew//' 'screw//'
   * noun  -> Turn
   * 'off//' noun  -> SwitchOff
   * noun 'off//'  -> SwitchOff
   * 'on//' noun  -> SwitchOn
   * noun 'on//'  -> SwitchOn
;
Verb 'switch//'
   * noun  -> SwitchOn
   * 'off//' noun  -> SwitchOff
   * noun 'off//'  -> SwitchOff
   * noun 'on//'  -> SwitchOn
   * 'on//' noun  -> SwitchOn
;
Verb 'lock//'
   * noun 'with//' held  -> Lock
;
Verb 'unlock//'
   * noun 'with//' held  -> Unlock
;
Verb 'attack//' 'break//' 'smash//' 'hit//' 'fight//' 'torture//' 'wreck//' 'crack//' 'destroy//' 'murder//' 'kill//' 'punch//' 'thump//'
   * noun  -> Attack
;
Verb 'wait//' 'z//'
   *  -> Wait
;
Verb 'answer//' 'say//' 'shout//' 'speak//'
   * topic 'to//' creature  -> Answer reverse
;
Verb 'tell//'
   * creature 'about//' topic  -> Tell
;
Verb 'ask//'
   * creature 'for//' noun  -> AskFor
   * creature 'about//' topic  -> Ask
;
Verb 'eat//'
   * held  -> Eat
;
Verb 'sleep//' 'nap//'
   *  -> Sleep
;
Verb 'sing//'
   *  -> Sing
;
Verb 'climb//' 'scale//'
   * noun  -> Climb
   * 'up//' / 'over//' noun  -> Climb
;
Verb 'buy//' 'purchase//'
   * noun  -> Buy
;
Verb 'squeeze//' 'squash//'
   * noun  -> Squeeze
;
Verb 'swing//'
   * noun  -> Swing
   * 'on//' noun  -> Swing
;
Verb 'wake//' 'awake//' 'awaken//'
   *  -> Wake
   * 'up//'  -> Wake
   * creature  -> WakeOther
   * 'up//' creature  -> WakeOther
   * creature 'up//'  -> WakeOther
;
Verb 'kiss//' 'embrace//' 'hug//'
   * creature  -> Kiss
;
Verb 'think//'
   *  -> Think
;
Verb 'smell//' 'sniff//'
   *  -> Smell
   * noun  -> Smell
;
Verb 'listen//'
   *  -> Listen
   * 'to//' noun  -> Listen
;
Verb 'hear//'
   * noun  -> Listen
;
Verb 'taste//'
   * noun  -> Taste
;
Verb 'touch//' 'feel//'
   * noun  -> Touch
;
Verb 'rub//' 'shine//' 'polish//' 'sweep//' 'clean//' 'dust//' 'wipe//' 'scrub//'
   * noun  -> Rub
;
Verb 'tie//' 'attach//' 'fix//' 'fasten//'
   * noun 'to//' noun  -> Tie
;
Verb 'burn//' 'light//'
   * noun  -> Burn
;
Verb 'drink//' 'swallow//' 'sip//'
   * noun  -> Drink
;
Verb 'cut//' 'slice//' 'prune//' 'chop//'
   * noun  -> Cut
;
Verb 'jump//' 'skip//' 'hop//'
   *  -> Jump
;
Verb 'score//'
   *  -> Score
;
Verb 'quit//'
   *  -> Quit
;
Verb 'q//'
   *  -> Quit
;
Verb 'save//'
   *  -> Save
;
Verb 'restart//'
   *  -> Restart
;
Verb 'restore//'
   *  -> Restore
;
Verb 'verify//'
   *  -> Verify
;
Verb 'version//'
   *  -> Version
;
Verb 'script//'
   *  -> ScriptOn
   * 'on//'  -> ScriptOn
   * 'off//'  -> ScriptOff
;
Verb 'transcript//'
   *  -> ScriptOn
   * 'on//'  -> ScriptOn
   * 'off//'  -> ScriptOff
;
Verb 'superbrief//'
   *  -> LMode3
;
Verb 'short//'
   *  -> LMode3
;
Verb 'verbose//'
   *  -> LMode2
;
Verb 'long//'
   *  -> LMode2
;
Verb 'brief//'
   *  -> LMode1
;
Verb 'normal//'
   *  -> LMode1
;
Verb 'nouns//'
   *  -> Pronouns
;
Verb 'pronouns//'
   *  -> Pronouns
;
Verb 'notify//'
   *  -> NotifyOn
   * 'on//'  -> NotifyOn
   * 'off//'  -> NotifyOff
;


#IFDEF DEBUG;

! Tests.i6 segment
! Should only be included if DEBUG is defined.

Verb meta "test"
	* -> TestScript
	* special -> TestScript;

#IFDEF TEST_SCENARIOS_EXIST;

[ TestScriptSub;
	switch(special_word) {

	default:
		print ">--> The following tests are available:^";

	}
];
#ifdef TARGET_ZCODE;
Constant I7_TEST_STACK_SIZE = 20;
#ifnot;
Constant I7_TEST_STACK_SIZE = 40;
#endif;

Array test_stack --> I7_TEST_STACK_SIZE;
Global test_sp = 0;
[ TestStart T R l k;
	if (test_sp >= I7_TEST_STACK_SIZE) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 0;
	test_stack-->(test_sp+3) = l;
	test_sp = test_sp + 4;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^";
];
[ KeyboardPrimitive a_buffer a_table p i j l spaced;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return KeyboardPrimitive__(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-4);
	    i = test_stack-->(test_sp-3);
	    l = test_stack-->(test_sp-1);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = test_stack-->2 + 1;
	    style bold;
	    while ((i < l) && (p->i ~= '/')) {
	        if (spaced || (p->i ~= ' ')) {
	            a_buffer->(j+WORDSIZE) = p->i;
	            print (char) p->i;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    Tokenise__(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i >= l) {
	        test_sp = test_sp - 4;
	    } else test_stack-->(test_sp-3) = i;
	}
];

#IFNOT; ! TEST_SCENARIOS_EXIST

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF; ! TEST_SCENARIOS_EXIST

! End of Tests.i6 segment

! Debugging.i6 segment
! Should only be included if DEBUG is defined.

! Not all of these commands are documented; this is intentional. They may
! be changed in name or function. But this is all of the grammar defined
! in the segments except for the TEST command, which is in Tests.i6.

Constant NO_DEBUGGABLES = 30;
Array debuggable_states -> NO_DEBUGGABLES;
[ DebugRbOffSub state i c;
	if ((noun >= 0) && (noun < NO_DEBUGGABLES)) {
		debuggable_states->noun = state;
		print "Now tracing rulebooks: ";
		for (i=0:i<NO_DEBUGGABLES:i++)
			if (debuggable_states->i) { c++; print i, " "; }
		if (c==0) "none";
		new_line; return;
	}
	"Rulebook number out of range.";
];
[ DebugRbSub; DebugRbOffSub(true); ];
[ AdjustDbr s;
	if ((s>=0) && (s<NO_DEBUGGABLES)) debugging_rules = debuggable_states->s;
];

[ RulesOnSub;
	debug_rules = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];

[ ScenesOnSub;
	debug_scenes = 1;
	I7_SceneStatus();
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];
[ ShowMeSub view na;
	view = noun;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (view ofclass K2_thing) {
 		print "location:";
 		ShowRLocation(noun, true);
		print "^";
 	}
 	  if (view ofclass K1_room) { na = 0;
      if (view  has light) { if (na++ > 0) print "; "; print "lighted"; }
      if (view  hasnt light) { if (na++ > 0) print "; "; print "dark"; }
      if (view  has visited) { if (na++ > 0) print "; "; print "visited"; }
      if (view  hasnt visited) { if (na++ > 0) print "; "; print "unvisited"; }
  if (na>0) print "^";
      if (view provides I7_Map_Region) print "map region: ", (PrintShortName) AccessProp(view, I7_Map_Region), "^";
      if (view provides description) print "description: ", (I7_PrintText) AccessProp(view, description), "^";
      if (view provides short_name) print "printed name: ", (I7_PrintText) AccessProp(view, short_name), "^";
  }
  if (view ofclass K2_thing) { na = 0;
      if (view  has enterable) { if (na++ > 0) print "; "; print "enterable"; }
      if (view  has light) { if (na++ > 0) print "; "; print "lit"; }
      if (view  hasnt light) { if (na++ > 0) print "; "; print "unlit"; }
      if (view  has edible) { if (na++ > 0) print "; "; print "edible"; }
      if (view  hasnt edible) { if (na++ > 0) print "; "; print "inedible"; }
      if (view  hasnt transparent) { if (na++ > 0) print "; "; print "opaque"; }
      if (view  has transparent) { if (na++ > 0) print "; "; print "transparent"; }
      if (view  has static) { if (na++ > 0) print "; "; print "fixed in place"; }
      if (view  hasnt static) { if (na++ > 0) print "; "; print "portable"; }
      if (view  has scenery) { if (na++ > 0) print "; "; print "scenery"; }
      if (view  has clothing) { if (na++ > 0) print "; "; print "wearable"; }
      if (view  has moved) { if (na++ > 0) print "; "; print "handled"; }
      if (view  has pushable) { if (na++ > 0) print "; "; print "pushable between rooms"; }
      if (view  has initially_carried) { if (na++ > 0) print "; "; print "initially carried"; }
      if (view  has pluralname) { if (na++ > 0) print "; "; print "plural-named"; }
      if (view  hasnt pluralname) { if (na++ > 0) print "; "; print "singular-named"; }
      if (view  has proper) { if (na++ > 0) print "; "; print "proper-named"; }
      if (view  hasnt proper) { if (na++ > 0) print "; "; print "improper-named"; }
  if (na>0) print "^";
      if (view provides description) print "description: ", (I7_PrintText) AccessProp(view, description), "^";
      if (view provides short_name) print "printed name: ", (I7_PrintText) AccessProp(view, short_name), "^";
      if (view provides initial) print "initial appearance: ", (I7_PrintText) AccessProp(view, initial), "^";
      if (view provides plural) print "printed plural name: ", (I7_PrintText) AccessProp(view, plural), "^";
      if (view provides invent) print "inventory listing: ", (I7_PrintText) AccessProp(view, invent), "^";
      if (view provides article) print "indefinite article: ", (I7_PrintText) AccessProp(view, article), "^";
      if (view provides with_key) print "matching key: ", (PrintShortName) AccessProp(view, with_key), "^";
  }
  if (view ofclass K3_direction) { na = 0;
  if (na>0) print "^";
      if (view provides p10_opposite) print "opposite: ", (PrintShortName) AccessProp(view, p10_opposite), "^";
  }
  if (view ofclass K4_door) { na = 0;
      if (view  has open) { if (na++ > 0) print "; "; print "open"; }
      if (view  hasnt open) { if (na++ > 0) print "; "; print "closed"; }
      if (view  has openable) { if (na++ > 0) print "; "; print "openable"; }
      if (view  hasnt openable) { if (na++ > 0) print "; "; print "unopenable"; }
      if (view  has lockable) { if (na++ > 0) print "; "; print "lockable"; }
      if (view  has locked) { if (na++ > 0) print "; "; print "locked"; }
      if (view  hasnt locked) { if (na++ > 0) print "; "; print "unlocked"; }
  if (na>0) print "^";
      if (view provides door_to) print "other side: ", (PrintShortName) AccessProp(view, door_to), "^";
  }
  if (view ofclass K5_container) { na = 0;
      if (view  has open) { if (na++ > 0) print "; "; print "open"; }
      if (view  hasnt open) { if (na++ > 0) print "; "; print "closed"; }
      if (view  has openable) { if (na++ > 0) print "; "; print "openable"; }
      if (view  hasnt openable) { if (na++ > 0) print "; "; print "unopenable"; }
      if (view  has lockable) { if (na++ > 0) print "; "; print "lockable"; }
      if (view  has locked) { if (na++ > 0) print "; "; print "locked"; }
      if (view  hasnt locked) { if (na++ > 0) print "; "; print "unlocked"; }
  if (na>0) print "^";
      if (view provides capacity) print "carrying capacity: ", (I7_DefaultPrinter) AccessProp(view, capacity), "^";
  }
  if (view ofclass K6_supporter) { na = 0;
  if (na>0) print "^";
      if (view provides capacity) print "carrying capacity: ", (I7_DefaultPrinter) AccessProp(view, capacity), "^";
  }
  if (view ofclass K8_person) { na = 0;
      if (view  has neuter) { if (na++ > 0) print "; "; print "neuter"; }
  if (na>0) print "^";
      if (view provides capacity) print "carrying capacity: ", (I7_DefaultPrinter) AccessProp(view, capacity), "^";
  }
  if (view ofclass K11_device) { na = 0;
      if (view  has on) { if (na++ > 0) print "; "; print "switched on"; }
      if (view  hasnt on) { if (na++ > 0) print "; "; print "switched off"; }
  if (na>0) print "^";
  }

];
[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides i7_kind) {
		k = obj.&i7_kind-->0;
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

Constant RELATIONS_CREATED;

#IFDEF RELATIONS_CREATED;
[ ShowRelationsSub rc;
	for (rc=0:rc<98:rc++)
		I7_ShowR(rc);
];
#IFNOT; ! RELATIONS_CREATED
[ ShowRelationsSub;
	"No new relations have been created.";
];
#ENDIF; ! RELATIONS_CREATED

Verb meta "dbrb"
	* number -> DebugRb
	* number "off" -> DebugRbOff;
Verb meta "rules"
	* -> RulesOn
	* "all" -> RulesAll
	* "off" -> RulesOff;
Verb meta "scenes"
	* -> ScenesOn
	* "off" -> ScenesOff;
Verb meta "showme"
	* -> ShowMe
	* multi -> ShowMe;
Verb meta "relations"
	* -> ShowRelations;
Verb meta "showheap"
	* -> ShowHeap;

! End of Debugging.i6

#ENDIF; ! DEBUG



 
[ I7_CheckDPMR result sinp1 sinp2 rv;
	sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
	rv = FollowRulebook( 30 );
	inp1 = sinp1; inp2 = sinp2;
	if ((rv) && RulebookSucceeded()) {
		result = ResultOfRule();
		if (result == RBNO_6 ) return 4;
		if (result == RBNO_7 ) return 3;
		if (result == RBNO_8 ) return 2;
		if (result == RBNO_9 ) return 1;
		if (result == RBNO_10 ) return 0;
	}
	return 2;
];
 
 
[ I7_SOO_PAR oldval count; if (count <= 1) return count; return random(count); ];
[ I7_SOO_RAN oldval count v; if (count <= 1) return count; v = oldval; while (v == oldval) v = random(count); return v; ];
[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];
[ I7_SOO_CYC oldval count; oldval++; if (oldval > count) oldval = 1; return oldval; ];
[ I7_SOO_STOP oldval count; oldval++; if (oldval > count) oldval = count; return oldval; ];
[ I7_SOO_TAP oldval count tn rn c; if (count <= 1) return count; tn = count*(count+1)/2;
	rn = random(tn); for (c=1:c<=count:c++) { rn = rn - c; if (rn<=0) return (count-c+1); } ];
Array I7_SOO_SHUF->32;
[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
	base = count+1;
	v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;
	if (count > 32) return I7_SOO_PAR(oldval, count);
	if (count <= 1) v = count;
	else {
!print "^In v=", v, " ct=", ct, " sd=", sd, "^";
		cc = base*base;
		scope = 32767/cc - cc - base;
		if (scope%2==0) scope--;
!print "Scope = ", scope, "^";
		if (sd == 0) { sd = random(scope); ct=0; }
		for (i=0:i<count:i++) I7_SOO_SHUF->i = i;
		ssd = sd;
		for (i=0:i<count-1:i++) {
			j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd<0) sd=-sd;
			s = I7_SOO_SHUF->j; I7_SOO_SHUF->j = I7_SOO_SHUF->i; I7_SOO_SHUF->i = s;
		}
!for (i=0:i<count:i++) print I7_SOO_SHUF->i, " "; print "^";
		v = (I7_SOO_SHUF->ct)+1;
		ct++; if (ct >= count) { ct = 0; ssd = 0; }
	}
!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";
	return v + ct*base + ssd*base*base; ];
 




! The falsity proposition represents the empty set
[ Prop_Falsity reason obj; return 0; ];

! True or false?
! [ cardinality(== 0)x: K1'room'(x) => is(const_0,x) ]
[ Prop_0  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K1_First: x: x=x.K1_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K2'thing'(x) => is(const_0,x) ]
[ Prop_1  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K2_First: x: x=x.K2_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_CarriedBy(x)) ]
[ Prop_2  const_0 x counter;
  objectloop (x in const_0) if (I7_CarriedBy(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ exists x: called(x)='sack' ^ K10'player's holdall'(x) ^ is(const_0,I7_HeldBy(x)) ]
[ Prop_3  const_0 x ;
  for (x=nothing: x: )
    if ((const_0 == I7_HeldBy(x)))
      {I7_CS-->0 = x; if (true) rtrue; }
  rfalse;
];

! Find next x in a loop over all x such that:
! [ K2'thing'(x) ^ is(const_0,I7_CarriedBy(x)) ]
[ Prop_4  const_0 x ;
  if (x) jump NextOuterLoop_0;
  objectloop (x in const_0) if (I7_CarriedBy(x)==parent(x)) {
    if ((x ofclass K2_thing))
      return x;  
    .NextOuterLoop_0;
  }
  return nothing;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_CarriedBy(x)) ]
[ Prop_5  const_0 x counter;
  objectloop (x in const_0) if (I7_CarriedBy(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_OnWhat(x)) ]
[ Prop_6  const_0 x counter;
  objectloop (x in const_0) if (I7_OnWhat(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_InWhat(x)) ]
[ Prop_7  const_0 x counter;
  for (x=I7_InWhatR(const_0):x:x=I7_InWhatR(const_0,x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ cardinality(== 0)x: K6'supporter'(x) => is(const_0,x) ]
[ Prop_8  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K6_First: x: x=x.K6_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_OnWhat(x)) ]
[ Prop_9  const_0 x counter;
  objectloop (x in const_0) if (I7_OnWhat(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ cardinality(== 0)x: K5'container'(x) => is(const_0,x) ]
[ Prop_10  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=nothing: x: ) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_InWhat(x)) ]
[ Prop_11  const_0 x counter;
  for (x=I7_InWhatR(const_0):x:x=I7_InWhatR(const_0,x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ cardinality(== 0)x: K2'thing'(x) => is(const_0,x) ]
[ Prop_12  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K2_First: x: x=x.K2_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K5'container'(x) => is(const_0,x) ]
[ Prop_13  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=nothing: x: ) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K6'supporter'(x) => is(const_0,x) ]
[ Prop_14  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K6_First: x: x=x.K6_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ exists x: K2'thing'(x) ^ p24_described(x) ^  NOT  [ scenery(x) ]  ^ is(const_0,I7_InWhat(x)) ]
[ Prop_15  const_0 x ;
  for (x=I7_InWhatR(const_0):x:x=I7_InWhatR(const_0,x))
    if ((x ofclass K2_thing) && (I7GetEitherOr(x,concealed)==false))
      if (~~((I7GetEitherOr(x,scenery))))
        rtrue;  
  rfalse;
];

! True or false?
! [ exists x: K2'thing'(x) ^ p24_described(x) ^  NOT  [ scenery(x) ]  ^ is(const_0,I7_OnWhat(x)) ]
[ Prop_16  const_0 x ;
  objectloop (x in const_0) if (I7_OnWhat(x)==parent(x))
    if ((x ofclass K2_thing) && (I7GetEitherOr(x,concealed)==false))
      if (~~((I7GetEitherOr(x,scenery))))
        rtrue;  
  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K2'thing'(x) => is(const_0,x) ]
[ Prop_17  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K2_First: x: x=x.K2_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K8'person'(x) => is(const_0,x) ]
[ Prop_18  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K8_First: x: x=x.K8_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K8'person'(x) => is(const_0,x) ]
[ Prop_19  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K8_First: x: x=x.K8_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];


[ Resolver_0 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return   I7_RoomOrDoorFrom(t_1,t_0)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_1 t_0 t_1 filename line;
if ((((t_0 ofclass K4_door))) && (((t_1 ofclass K1_room)))) { return   I7_OtherSide(t_0,t_1)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_2 t_0 filename line;
if ((((t_0 ofclass K8_person)))) {   HisHerTheir(t_0);   rtrue; }
  rfalse; ];
[ Resolver_3 t_0 t_1 filename line;
if ((((t_0 ofclass K1_room))) && (((t_1 ofclass K1_room)))) {   return I7_ReckonLight(t_0, t_1);   rtrue; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_4 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return   I7_RoomFrom(t_1,t_0,2)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_5 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return   I7_RoomOrDoorFrom(t_1,t_0)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];


Constant SC_40 = " ";
Constant SC_29 = " arrives from ";
Constant SC_20 = " arrives";
Constant SC_27 = " at ";
Constant SC_34 = " away";
Constant SC_56 = " closes ";
Constant SC_57 = " closes.";
Constant SC_18 = " eats ";
Constant SC_21 = " from ";
Constant SC_37 = " gets ";
Constant SC_42 = " gets off ";
Constant SC_41 = " gets out of ";
Constant SC_62 = " gives ";
Constant SC_19 = " goes ";
Constant SC_28 = " goes through	";
Constant SC_30 = " in ";
Constant SC_33 = " in front";
Constant SC_32 = " in front, and you along too";
Constant SC_35 = " in";
Constant SC_17 = " into ";
Constant SC_49 = " locks ";
Constant SC_43 = " looks around.";
Constant SC_48 = " looks at ";
Constant SC_45 = " looks closely at ";
Constant SC_8 = " looks through ";
Constant SC_46 = " looks under ";
Constant SC_53 = " off.";
Constant SC_16 = " on ";
Constant SC_52 = " on.";
Constant SC_54 = " opens ";
Constant SC_55 = " opens.";
Constant SC_10 = " picks up ";
Constant SC_9 = " possessions.";
Constant SC_70 = " pulls ";
Constant SC_71 = " pushes ";
Constant SC_15 = " puts ";
Constant SC_14 = " puts down ";
Constant SC_58 = " puts on ";
Constant SC_47 = " searches ";
Constant SC_73 = " squeezes ";
Constant SC_51 = " switches ";
Constant SC_59 = " takes off ";
Constant SC_61 = " to ";
Constant SC_65 = " touches	";
Constant SC_68 = " touches ";
Constant SC_72 = " turns ";
Constant SC_50 = " unlocks ";
Constant SC_64 = " waits.";
Constant SC_69 = " waves ";
Constant SC_31 = ", pushing ";
Constant SC_36 = ", taking you along.";
Constant SC_11 = ".";
Constant SC_7 = ":";
Constant SC_3 = "After rescuing that jungle princess, decoding the treasure map you found, and fighting off those rabid jaguars as you made your way through the rainforest, your well-deserved reward is at hand.";
Constant SC_2 = "As good-looking as ever.";
Constant SC_4 = "It resembles a bald, nude man with hands crossed over his chest, pointing a sword at his feet.";
Constant SC_0 = "Montana Parks and the Trivial Example";
Constant SC_1 = "Taradino Cassatt";
Constant SC_5 = "The pedestal clicks almost imperceptibly. You remember the princess's warning, quickly drop to one knee, and just barely avoid the poison dart aimed for your head. Heaving a sigh of relief, you stick the idol in your knapsack and head back to the museum.";
Constant SC_13 = "There is no more room in ";
Constant SC_12 = "There is no more room on ";
Constant SC_60 = "You give ";
Constant SC_44 = "You see nothing unexpected in that direction.";
Constant SC_6 = "You'll have to say
which compass direction to go in.";
Constant SC_22 = "above";
Constant SC_23 = "below";
Constant SC_26 = "down";
Constant SC_66 = "herself";
Constant SC_67 = "himself";
Constant SC_38 = "into";
Constant SC_39 = "onto";
Constant SC_24 = "the ";
Constant SC_25 = "up";
Constant SC_63 = "you";

#ifndef I7_Map_Region; Constant I7_Map_Region = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef invent; Constant invent = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef p10_opposite; Constant p10_opposite = 0; #endif;
#ifndef p11_inform_property; Constant p11_inform_property = 0; #endif;
#ifndef p12_inform_object; Constant p12_inform_object = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef door; Constant door = 0; #endif;
#ifndef container; Constant container = 0; #endif;
#ifndef supporter; Constant supporter = 0; #endif;
#ifndef switchable; Constant switchable = 0; #endif;
#ifndef animate; Constant animate = 0; #endif;
#ifndef male; Constant male = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef I7_mentioned; Constant I7_mentioned = 0; #endif;
#ifndef initially_carried; Constant initially_carried = 0; #endif;
#ifndef pluralname; Constant pluralname = 0; #endif;
#ifndef proper; Constant proper = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef p59_specification; Constant p59_specification = 0; #endif;
#ifndef score; Constant score = 0; #endif;
#ifndef score; Constant score = 0; #endif;
#ifndef worn; Constant worn = 0; #endif;
Constant I7_FBNA = 10000;

#IFNDEF I7_cap_short_name;
Constant I7_cap_short_name = short_name;
#ENDIF;



Constant I7_BOXES = 1;

[ I7_Initial_Heap_Allocation obj pv;
];


! Flex.i6

! Heap: 2^n sized "blocks" of bytes, n >= 3 (Z) or >= 4 (G)
! 
! ->0 = n
! ->1 = data type + multiple type
! 
! Top bit of byte 1 set = this is a multiple-block type, in which case:
! -->1 = next or I6_NULL
! -->2 = previous or I6_NULL

! Data type 0, with multiple type bit set, indicates free space.
! The initial 16-byte block is inviolable and provides the head of the
! free space object. The following are maintained:
! (a) In the free space object, B-->BLK_NEXT is always an address after B;
! (b) For any contiguous run of free space blocks excluding the head,
! block sizes are such that the last in the run is the largest power of 2
! size which will fit into the memory occupied by the run.
! (Note that if property (b) holds for run R then it holds for any subrun
! of R, so that allocating any intermediate block to form two disjoint
! runs does not violate (b) for either of the residual runs. Maintaining
! (b) is therefore a matter of being careful to fragment blocks only from
! the front when smaller blocks are needed, and to rejoin from the back
! when blocks are freed and added to the free space object.)
! The free space object therefore always contains the minimum number of
! blocks possible to represent the gaps between allocated blocks: though
! of course the ability to move those around would change everything.

#IFDEF I7_HEAP_SIZE;

! Constant SHOW_ALLOCATIONS = 1;

#IFDEF TARGET_ZCODE;
Constant BLK_DATA_OFFSET 4;
Constant BLK_DATA_MULTI_OFFSET 8;
Constant BLK_HEADER_KOV = 1;
Constant BLK_NEXT 2;
Constant BLK_PREV 3;
#IFNOT;
Constant BLK_DATA_OFFSET 8;
Constant BLK_DATA_MULTI_OFFSET 16;
Constant BLK_HEADER_KOV = 1;
Constant BLK_NEXT 2;
Constant BLK_PREV 3;
#ENDIF;

Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_N_VALUE = 0;

Constant BLK_FLAG_MULTIPLE = 1;
Constant BLK_FLAG_16_BIT = 2;
Constant BLK_FLAG_WORD = 4;

Array I7_Blk_Heap -> I7_HEAP_SIZE + 16;
Array I7BASTACK --> 256;

[ I7_Blk_Initialise n bsize blk2;
	blk2 = I7_Blk_Heap + 16;
	I7_Blk_Heap->BLK_HEADER_N = n;
	I7_Blk_Heap-->BLK_HEADER_KOV = 0;
	I7_Blk_Heap->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	I7_Blk_Heap-->BLK_NEXT = blk2;
	I7_Blk_Heap-->BLK_PREV = I6_NULL;
	for (bsize=1: bsize < I7_HEAP_SIZE: bsize=bsize*2) n++;
	blk2->BLK_HEADER_N = n;
	blk2-->BLK_HEADER_KOV = 0;
	blk2->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	blk2-->BLK_NEXT = I6_NULL;
	blk2-->BLK_PREV = I7_Blk_Heap;
];

[ I7_Blk_Type txb;
	return txb-->BLK_HEADER_KOV;
];

[ I7_Blk_Size txb bsize n;
	if (txb == 0) return 0;
	for (bsize=1: n<txb->BLK_HEADER_N: bsize=bsize*2) n++;
	return bsize;
];

[ I7_Blk_Total_Size txb tsize;
	if (txb == 0) return 0;
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE == 0)
		return I7_Blk_Size(txb);
	for (:txb~=I6_NULL:txb=txb-->BLK_NEXT) {
		tsize = tsize + I7_Blk_Size(txb);
	}
	return tsize;
];

[ I7_Blk_Absolute_Free_Space multiple txb asize;
	for (txb=I7_Blk_Heap-->BLK_NEXT: txb~=I6_NULL: txb=txb-->BLK_NEXT) {
		asize = asize + I7_Blk_Size(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
	}
	return asize;
];

[ I7_Blk_Debug txb n k i bsize tot dtot kov;
	if (txb == 0) "Block never created.";
	kov = txb-->BLK_HEADER_KOV;
	print "Block ", txb, " (kov ", kov, "): ";
	for (:txb~=I6_NULL:txb = txb-->BLK_NEXT) {
		if (k++ == 100) " ... and so on.";
		if (txb-->BLK_HEADER_KOV ~= kov) print "*Wrong kov=", txb-->BLK_HEADER_KOV, "* ";
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_OFFSET;
		dtot = dtot+i;
		tot = tot+bsize;
		print txb, "(", bsize, ") > ";
	}
	print dtot, " data in ", tot, " bytes^";
];

[ I7_Blk_Debug_Chunkiness from to txb pf;
	if (to==0) to = I6_NULL;
	for (txb=from:(txb~=to) && (txb~=I6_NULL):txb=txb-->BLK_NEXT) {
		if (pf) print "+";
		print I7_Blk_Size(txb);
		pf = true;
	}
	print "^";
];

[ I7_Blk_Allocate size kov flags
	bsize n m free min_m max_m min_free secondhalf i hsize head tail;
	.RetryWithLargerHeap;
	if (I7_Blk_Absolute_Free_Space(flags & BLK_FLAG_MULTIPLE) < size) {
!		print "*** Memory absolutely ran out ***^";
!		rfalse;
		#ifndef TARGET_ZCODE;
			@gestalt 7 0 i;
			if (i ~= 0) {
				!print "gestalt allows^";
				free = 1; for (n=0: (n<12) || (free<size): n++) free=free*2;
				while (free < size) free=free*2;
				@malloc free i;
				if (i ~= 0) {
					i->BLK_HEADER_N = n;
					i-->BLK_HEADER_KOV = 0;
					i->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
					i-->BLK_NEXT = I6_NULL;
					i-->BLK_PREV = I6_NULL;
					for (free = I7_Blk_Heap-->BLK_NEXT:free ~= I6_NULL:free = free-->BLK_NEXT)
						if (free-->BLK_NEXT == I6_NULL) {
							free-->BLK_NEXT = i;
							i-->BLK_PREV = free;
							break;
						}
					!print "Increasing heap by malloc: now ";
					!I7_Blk_Debug_Chunkiness(I7_Blk_Heap, 0);
					!return 0;
					jump RetryWithLargerHeap;
				}
			}
		#endif;
		print "*** Memory absolutely ran out ***^";
		rfalse;
	}
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	n=0;
	for (bsize=1: bsize < hsize+size: bsize=bsize*2) n++;
!print "Looking for free 2 to the ", n, " block for kov ", kov, "^";
!print "Free space: "; I7_Blk_Debug_Chunkiness(I7_Blk_Heap, 0);
	min_m = 10000; max_m = 0;

	for (free = I7_Blk_Heap-->BLK_NEXT:free ~= I6_NULL:free = free-->BLK_NEXT) {
!print "Trying free block at ", free, "^";
		m = free->BLK_HEADER_N;
!print "With size 2 to the ", m, "^";
		! Current block the ideal size
		if (m == n) jump CorrectSizeFound;
		! Current block too large: find the smallest which is larger than needed
		if (m > n) {
			if (min_m > m) {
				min_m = m;
				min_free = free;
			}
		}
		! Current block too small: find the largest which is smaller than needed
		if (m < n) {
			if (max_m < m) {
				max_m = m;
			}
		}
	}
	if (min_m == 10000) {
		if (flags & BLK_FLAG_MULTIPLE == 0) {
			print "*** Memory too fragmented ***^";
			return 0;
		}
		for (bsize=1: max_m > 0: bsize=bsize*2) max_m--;
		!print "Forced to split as ", bsize-hsize, " + ", size-(bsize-hsize), "^";
		head = I7_Blk_Allocate(bsize-hsize, kov, flags);
		if (head == 0) {
			print "*** Memory failed: headless ***^";
			return 0;
		}
		!print "Head looks like "; I7_Blk_Debug_Chunkiness(head);
		tail = I7_Blk_Allocate(size-(bsize-hsize), kov, flags);
		!print "Tail looks like "; I7_Blk_Debug_Chunkiness(head);
		if (tail == 0) {
			print "*** Memory failed: tailless ***^";
			return 0;
		}
		head-->BLK_NEXT = tail;
		tail-->BLK_PREV = head;
		!print "Joined looks like "; I7_Blk_Debug_Chunkiness(head);
		return head;
	}
!print "Smallest free block has size 2 to the ", min_m, "^";
	for (bsize=1,m=1: m<=min_m: bsize=bsize*2) m++;
!print "Which is ", bsize, " bytes^";
	free = min_free;
	while (min_m > n) {
		! Halve free
		bsize = bsize/2;
!print "Halving free block to ", bsize, " + ", bsize, "^";
		secondhalf = free + bsize;
		secondhalf-->BLK_NEXT = free-->BLK_NEXT;
		if (secondhalf-->BLK_NEXT ~= I6_NULL)
			(secondhalf-->BLK_NEXT)-->BLK_PREV = secondhalf;
		secondhalf-->BLK_PREV = free;
		free-->BLK_NEXT = secondhalf;
		free->BLK_HEADER_N = (free->BLK_HEADER_N) - 1;
		secondhalf->BLK_HEADER_N = free->BLK_HEADER_N;
		secondhalf-->BLK_HEADER_KOV = free-->BLK_HEADER_KOV;
		secondhalf->BLK_HEADER_FLAGS = free->BLK_HEADER_FLAGS;
		min_m--;
	}
.CorrectSizeFound;
	if (free-->BLK_NEXT == I6_NULL) {
		! We remove final block, so previous is now final
		(free-->BLK_PREV)-->BLK_NEXT = I6_NULL;
	} else {
		! We remove a middle block, so join previous to next
		(free-->BLK_PREV)-->BLK_NEXT = free-->BLK_NEXT;
		(free-->BLK_NEXT)-->BLK_PREV = free-->BLK_PREV;
	}
	free-->BLK_HEADER_KOV = kov;
	free->BLK_HEADER_FLAGS = flags;
	if (flags & BLK_FLAG_MULTIPLE) {
		free-->BLK_NEXT = I6_NULL;
		free-->BLK_PREV = I6_NULL;
	}
	for (i=hsize:i<bsize:i++) free->i=0;
!print "CSF with hsize ", hsize;
	return free;
];

[ I7_Blk_Merge txb first last pv nx;
	first = txb; last = txb;
	while (last-->BLK_NEXT == last+I7_Blk_Size(last))
		last = last-->BLK_NEXT;
	while ((first-->BLK_PREV + I7_Blk_Size(first-->BLK_PREV) == first) &&
		(first-->BLK_PREV ~= I7_Blk_Heap))
		first = first-->BLK_PREV;
	pv = first-->BLK_PREV;
	nx = last-->BLK_NEXT;
!	print "Block recutting at ", first, ": ";
!	I7_Blk_Debug_Chunkiness(pv-->BLK_NEXT, nx);
if (I7_Blk_Recut(first, last)) {
!		print "Block recut: "; I7_Blk_Debug_Chunkiness(pv-->BLK_NEXT, nx);
!		print "Free space now: "; I7_Blk_Debug_Chunkiness(I7_Blk_Heap);
	}
];

[ I7_Blk_Recut first last tsize backsize mfrom mto bnext backend n bsize fine_so_far;
	if (first == last) rfalse;
	mfrom = first; mto = last + I7_Blk_Size(last);
	bnext = last-->BLK_NEXT;
	fine_so_far = true;
	for (:mto>mfrom: mto = mto - backsize) {
		for (n=0, backsize=1: backsize*2 <= mto-mfrom: n++) backsize=backsize*2;
!print "Ideal back chunk size ", backsize, "^";
		if ((fine_so_far) && (backsize == I7_Blk_Size(last))) {
			bnext = last; last = last-->BLK_PREV;
			bnext-->BLK_PREV = last;
			last-->BLK_NEXT = bnext;
!print "Fine^";
			continue;
		}
		fine_so_far = false; ! From this point, "last" is meaningless
!print "Cutting by hand^";
		backend = mto - backsize;
		backend->BLK_HEADER_N = n;
		backend-->BLK_HEADER_KOV = 0;
		backend->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		backend-->BLK_NEXT = bnext;
		if (bnext ~= I6_NULL) {
			bnext-->BLK_PREV = backend;
			bnext = backend;
		}
	}
	if (fine_so_far) rfalse;
	rtrue;
];

Global i7btal = 0;

[ i7btaldn k;
	switch (k) {
		INDEXED_TEXT_TY: print "INDEXED_TEXT_TY";
		STORED_ACTION_TY: print "STORED_ACTION_TY";
		LIST_OF_TY: print "LIST_OF_TY";
		default: print "???";
	}
];

[ I7_Blk_Free_Block txb free nx;
!	print "Block ", txb, " (kov ", I7_Blk_Type(txb), ") freed^";
	txb-->BLK_HEADER_KOV = 0;
	txb->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	for (free = I7_Blk_Heap:free ~= I6_NULL:free = free-->BLK_NEXT) {
		nx = free-->BLK_NEXT;
		if (nx == I6_NULL) {
			free-->BLK_NEXT = txb;
			txb-->BLK_PREV = free;
			txb-->BLK_NEXT = I6_NULL;
			I7_Blk_Merge(txb);
			return;
		}
		if (UnsignedCompare(nx, txb) == 1) {
			free-->BLK_NEXT = txb;
			txb-->BLK_PREV = free;
			txb-->BLK_NEXT = nx;
			nx-->BLK_PREV = txb;
			I7_Blk_Merge(txb);
			return;
		}
	}
];

[ I7_Blk_Free txb fromtxb ptxb;
	if (txb == 0) return;
#ifdef SHOW_ALLOCATIONS;
	print "[freed ", (i7btaldn) txb-->BLK_HEADER_KOV, " at ", txb, ": ", --i7btal, "]^";
#endif;
	I7_Blk_Deallocate(txb);
!	print "Block ", txb, " doing ff^";
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
!print "A^", I6_NULL;
!		print "Prev: ", txb-->BLK_PREV, "^";
!		print "Next: ", txb-->BLK_NEXT, "^";
		if (txb-->BLK_PREV ~= I6_NULL)
			(txb-->BLK_PREV)-->BLK_NEXT = I6_NULL;
!print "b^";
		fromtxb = txb;
		for (:(txb-->BLK_NEXT)~=I6_NULL:txb = txb-->BLK_NEXT) ;
!print "c^";
		while (txb ~= fromtxb) {
			ptxb = txb-->BLK_PREV; I7_Blk_Free_Block(txb); txb = ptxb;
		}
!print "d^";
	}
!print "e^";
	I7_Blk_Free_Block(txb);
];

[ I7_Blk_Resize txb req newsize bsize newblk kov n i otxb flags;
	if (txb == 0) { print "Cannot resize null block^"; return; }
	kov = txb-->BLK_HEADER_KOV;
	flags = txb->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0) { 
		print "Cannot resize inextensible block^"; return;
	}
	otxb = txb;
!print "Resizing to ", req, ": "; I7_Blk_Debug(otxb);
	newsize = req;
	for (::txb = txb-->BLK_NEXT) {
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_MULTI_OFFSET;
		newsize = newsize - i;
		if (newsize > 0) {
			if (txb-->BLK_NEXT ~= I6_NULL) continue;
!print "Resizing block ", txb, " to ", req, " requires ", newsize, " extra^";
			newblk = I7_Blk_Allocate(newsize, kov, flags);
			if (newblk == 0) rfalse;
			txb-->BLK_NEXT = newblk;
			newblk-->BLK_PREV = txb;
!print "After extending: "; I7_Blk_Debug(otxb);
			rtrue;
		}
		if (txb-->BLK_NEXT ~= I6_NULL) {
			I7_Blk_Free(txb-->BLK_NEXT);
			txb-->BLK_NEXT = I6_NULL;
!print "After freeing: "; I7_Blk_Debug(otxb);
		}
		rtrue;
	}
];

[ I7_Blk_Get_Extent txb tsize flags;
	if (txb == 0) return 0;
	flags = txb->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0)
		tsize = I7_Blk_Size(txb) - BLK_DATA_OFFSET;
	else
		for (:txb~=I6_NULL:txb=txb-->BLK_NEXT)
			tsize = tsize + I7_Blk_Size(txb) - BLK_DATA_MULTI_OFFSET;
	#ifdef TARGET_ZCODE;
	if (flags & BLK_FLAG_WORD) return tsize/2;
	#ifnot;
	if (flags & BLK_FLAG_WORD) return tsize/4;
	#endif;
	if (flags & BLK_FLAG_16_BIT) return tsize/2;
	return tsize;
];

[ I7_Blk_Change_Extent txb tsize mark flags wsize;
	if (txb == 0) return 0;
	flags = txb->BLK_HEADER_FLAGS; wsize = 1;
	#ifdef TARGET_ZCODE;
	if (flags & BLK_FLAG_WORD) wsize = 2;
	#ifnot;
	if (flags & BLK_FLAG_WORD) wsize = 4;
	#endif;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	return I7_Blk_Resize(txb, (tsize)*wsize);
];

[ I7_Blk_Get txb pos dsize hsize flags wsize ot op;
	if (txb==0) rfalse;
	flags = txb->BLK_HEADER_FLAGS; wsize = 1;
	#ifdef TARGET_ZCODE;
	if (flags & BLK_FLAG_WORD) wsize = 2;
	#ifnot;
	if (flags & BLK_FLAG_WORD) wsize = 4;
	#endif;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = txb; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE)
		hsize = BLK_DATA_MULTI_OFFSET;
	else
		hsize = BLK_DATA_OFFSET;
	for (:txb~=I6_NULL:txb=txb-->BLK_NEXT) {
		dsize = I7_Blk_Size(txb) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			txb = txb + hsize + pos;
			switch(wsize) {
				1: return txb->0;
				2:	#ifdef TARGET_ZCODE; return txb-->0;
					#ifnot; return (txb->0)*256 + (txb->1);
					#endif;
				4: return txb-->0;
			}
		}
		pos = pos - dsize;
	}
	"*** I7_Blk_Get: reading from index out of range: ", op, " in ", ot, " ***";
];

[ I7_Blk_Put txb pos val dsize hsize flags wsize ot op;
	if (txb==0) rfalse;
	!print "Writing ", val, " to pos ", pos, "^";
	flags = txb->BLK_HEADER_FLAGS; wsize = 1;
	#ifdef TARGET_ZCODE;
	if (flags & BLK_FLAG_WORD) wsize = 2;
	#ifnot;
	if (flags & BLK_FLAG_WORD) wsize = 4;
	#endif;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = txb; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE)
		hsize = BLK_DATA_MULTI_OFFSET;
	else
		hsize = BLK_DATA_OFFSET;
	for (:txb~=I6_NULL:txb=txb-->BLK_NEXT) {
		dsize = I7_Blk_Size(txb) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			txb = txb + hsize + pos;
			switch(wsize) {
				1: txb->0 = val;
				2:	#ifdef TARGET_ZCODE; txb-->0 = val;
					#ifnot;
						txb->0 = (val/256)%256; txb->1 = val%256;
					#endif;
				4: txb-->0 = val;
			}
			return;
		}
		pos = pos - dsize;
	}
	"*** I7_Blk_Put: writing to index out of range: ", op, " in ", ot, " ***";
];

[ I7_Blk_Deep_Copy txbto txbfrom dsize i;
	if (txbto == 0)  {
		print "*** Deep copy failed because destination empty ***^";
		rfalse;
	}
	if (txbfrom == 0)  {
		print "*** Deep copy failed because source empty ***^";
		rfalse;
	}
	if (txbfrom->BLK_N_VALUE == 0) {
		!txbto->BLK_N_VALUE = 4;
		!txbto-->BLK_HEADER_KOV = LIST_OF_TY;
		!txbto->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE + BLK_FLAG_WORD;
		!txbto-->BLK_NEXT = I6_NULL;
		!txbto-->BLK_PREV = I6_NULL;
		I7_LIST_OF_TY_CopyRawArray(txbto, txbfrom);
		return txbto;
	}
	if (txbfrom-->BLK_HEADER_KOV ~= txbto-->BLK_HEADER_KOV) {
		print "*** Deep copy failed because types mismatch ***^";
		for (i=0: i<10: i++) print txbfrom-->i, "^";
		print txbfrom, " ", txbfrom-->BLK_HEADER_KOV, " --> ",
			txbto, " ", txbto-->BLK_HEADER_KOV, "^";
		rfalse;
	}
	I7_Blk_Deallocate(txbto);
	dsize = I7_Blk_Get_Extent(txbfrom);
!	print "Data size of blocks to be deep copied = ", dsize, "^";
	if ((txbfrom->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
		if (I7_Blk_Change_Extent(txbto, dsize, -1) == false) {
			print "*** Deep copy failed because resizing failed ***^";
			rfalse;
		}
	}
	for (i=0:i<dsize:i++) {
		!print "Copying char ", i, "^";
		I7_Blk_Put(txbto, i, I7_Blk_Get(txbfrom, i));
	}
	switch (txbfrom-->BLK_HEADER_KOV) {
		INDEXED_TEXT_TY: I7_INDEXED_TEXT_TY_Deep_Copy(txbto, txbfrom);
		STORED_ACTION_TY: I7_STORED_ACTION_TY_Deep_Copy(txbto, txbfrom);
		LIST_OF_TY: I7_LIST_OF_TY_Deep_Copy(txbto, txbfrom);
		default: print "*** Impossible runtime deallocation ***^"; rfalse;
	}
	return txbto;
];

[ I7_Blk_Initial_Copy txbto txbfrom dsize i;
	if (txbto == 0)  {
		print "*** Initial copy failed because destination empty ***^";
		rfalse;
	}
	if (txbfrom == 0)  {
		print "*** Initial copy failed because source empty ***^";
		rfalse;
	}
	dsize = 1; for (i=1: i<=txbfrom->BLK_N_VALUE: i++) dsize=dsize*2;
	for (i=0:i<dsize:i++) txbto->i = txbfrom->i;
	return txbto;
];

[ I7_Blk_Deep_Comparison txbleft txbright kov;
	if ((txbleft == 0) && (txbright == 0)) return 0;
	if (txbleft == 0) return 1;
	if (txbright == 0) return -1;
	if (txbleft-->BLK_HEADER_KOV ~= txbright-->BLK_HEADER_KOV)
		return txbleft-->BLK_HEADER_KOV - txbright-->BLK_HEADER_KOV;
	kov = txbleft-->BLK_HEADER_KOV;
	switch(kov) {
		INDEXED_TEXT_TY: return I7_INDEXED_TEXT_TY_Compare(txbleft, txbright);
		STORED_ACTION_TY: return I7_STORED_ACTION_TY_Compare(txbleft, txbright);
		LIST_OF_TY: return I7_LIST_OF_TY_Compare(txbleft, txbright);
		default: print "*** Impossible runtime comparison ***^"; rfalse;
	}
];

[ I7_Blk_Read_File_Form txb auxf ch kov;
	switch (kov) {
		INDEXED_TEXT_TY: if (ch == -1) rtrue; return I7_INDEXED_TEXT_TY_RFF(txb, auxf, ch);
		default: rfalse;
	}
];

[ I7_Blk_Write_File_Form txb kov;
	switch (kov) {
		INDEXED_TEXT_TY: I7_INDEXED_TEXT_TY_WFF(txb); rtrue;
		default: rfalse;
	}
];

[ I7_Blk_Cast txb tokov fromkov val;
	switch (tokov) {
		INDEXED_TEXT_TY: return I7_INDEXED_TEXT_TY_Cast(val, fromkov, txb);
		default: print "*** Impossible runtime cast ***^"; rfalse;
	}
];

[ I7_Blk_Create kov opcast skov v;
	switch (kov) {
		INDEXED_TEXT_TY: v = I7_INDEXED_TEXT_TY_Create(opcast);
		STORED_ACTION_TY: v = I7_STORED_ACTION_TY_Create(opcast);
		LIST_OF_TY: v = I7_LIST_OF_TY_Create(skov);
			if (opcast) I7_LIST_OF_TY_CopyRawArray(v, opcast);
		default: print "*** Impossible runtime creation ***^"; rfalse;
	}
#ifdef SHOW_ALLOCATIONS;
	print "[created ", (i7btaldn) kov, " at ", v, ": ", i7btal++, "]^";
#endif;
	return v;
];

[ I7_Blk_Deallocate blk k rv;
	if (blk == 0) return;
	k = blk-->BLK_HEADER_KOV;
	switch (k) {
		INDEXED_TEXT_TY: rv = I7_INDEXED_TEXT_TY_Free(blk);
		STORED_ACTION_TY: rv = I7_STORED_ACTION_TY_Free(blk);
		LIST_OF_TY: rv = I7_LIST_OF_TY_Free(blk);
		default: print "*** Impossible runtime deallocation ***^"; rfalse;
	}
];

[ ShowHeapSub;
	print "Managing a heap of initially ", I7_HEAP_SIZE+16, " bytes.^";
	print I7_Blk_Absolute_Free_Space(false), " bytes currently free.^";
	print "Free space decomposition: "; I7_Blk_Debug_Chunkiness(I7_Blk_Heap);
	print "Free space map: "; I7_Blk_Debug(I7_Blk_Heap);
];

#IFNOT; ! IFDEF I7_HEAP_SIZE

[ I7_Blk_Initialise; ];
[ I7_Blk_Read_File_Form; ];
[ I7_Blk_Write_File_Form; ];
[ I7_Blk_Free; ];
[ I7_Blk_Create; ];
[ I7_Blk_Deep_Comparison x y; ];

[ ShowHeapSub;
	">--> This story file does not use a heap of managed memory.";
];

#ENDIF; ! IFDEF I7_HEAP_SIZE

! End of Flex.i6

! IndexedText.i6

#IFDEF I7_HEAP_SIZE; ! Will exist if any use is made of indexed texts

Constant I7_IT_Storage_Glulx_Unicode;

#IFDEF TARGET_ZCODE;
Constant I7_IT_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant I7_ZSCII_Tables;
#IFNOT;
#IFDEF I7_IT_Storage_Glulx_Unicode;
Constant I7_IT_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant I7_Large_Unicode_Tables;
#IFNOT;
Constant I7_IT_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant I7_Small_Unicode_Tables;
#ENDIF;
#ENDIF;

! UnicodeData.i6
! Mechanically generated from UnicodeData-4.0.0: do not edit

Constant I7_U_NCT = 10000; ! Safe as highest case-change delta is 8383

! Case 0 = lower case, case 1 = upper case: we ignore title case
! Format: start of range, size of range, offset to change case
!     size is negated to indicate only every alternate code is valid
!     offset of I7_U_NCT means no case change is possible

#IFDEF I7_ZSCII_Tables;
Array I7_Char_Casing_Chart_0 -->
    $0061 (  26) (     -32)   $009b (   3) (       3)   $00a1 (   1) (I7_U_NCT)
    $00a4 (   2) (       3)   $00a6 (   1) (I7_U_NCT)   $00a9 (   6) (       6)
    $00b5 (   5) (       5)   $00bf (   5) (       5)   $00c9 (  -3) (       1)
    $00cd (   3) (       3)   $00d3 (  -3) (       1)   $00d7 (   2) (       2)
    $00dc (   1) (       1)   $0000
  ;

Array I7_Char_Casing_Chart_1 -->
    $0041 (  26) (      32)   $009e (   3) (      -3)   $00a7 (   2) (      -3)
    $00af (   6) (      -6)   $00ba (   5) (      -5)   $00c4 (   5) (      -5)
    $00ca (  -3) (      -1)   $00d0 (   3) (      -3)   $00d4 (  -3) (      -1)
    $00d9 (   2) (      -2)   $00dd (   1) (      -1)   $0000
  ;
#ENDIF; ! I7_ZSCII_Tables

#IFDEF I7_Small_Unicode_Tables;
Array I7_Char_Casing_Chart_0 -->
    $0061 (  26) (     -32)   $00aa (   1) (I7_U_NCT)   $00b5 (   1) (I7_U_NCT)   $00ba (   1) (I7_U_NCT)
    $00df (   1) (I7_U_NCT)   $00e0 (  23) (     -32)   $00f8 (   7) (     -32)   $00ff (   1) (I7_U_NCT)
    $0000
;

Array I7_Char_Casing_Chart_1 -->
    $0041 (  26) (      32)   $00c0 (  23) (      32)   $00d8 (   7) (      32)   $0000
;

#ENDIF; ! I7_Small_Unicode_Tables

#IFDEF I7_Large_Unicode_Tables;
Array I7_Char_Casing_Chart_0 -->
    $0061 (  26) (     -32)   $00aa (   1) (I7_U_NCT)   $00b5 (   1) (     743)   $00ba (   1) (I7_U_NCT)
    $00df (   1) (I7_U_NCT)   $00e0 (  23) (     -32)   $00f8 (   7) (     -32)   $00ff (   1) (     121)
    $0101 ( -47) (      -1)   $0131 (   1) (    -232)   $0133 (  -5) (      -1)   $0138 (   1) (I7_U_NCT)
    $013a ( -15) (      -1)   $0149 (   1) (I7_U_NCT)   $014b ( -45) (      -1)   $017a (  -5) (      -1)
    $017f (   1) (    -300)   $0180 (   1) (I7_U_NCT)   $0183 (  -3) (      -1)   $0188 (   1) (      -1)
    $018c (   1) (      -1)   $018d (   1) (I7_U_NCT)   $0192 (   1) (      -1)   $0195 (   1) (      97)
    $0199 (   1) (      -1)   $019a (   2) (I7_U_NCT)   $019e (   1) (     130)   $01a1 (  -5) (      -1)
    $01a8 (   1) (      -1)   $01aa (   2) (I7_U_NCT)   $01ad (   1) (      -1)   $01b0 (   1) (      -1)
    $01b4 (  -3) (      -1)   $01b9 (   1) (      -1)   $01ba (   1) (I7_U_NCT)   $01bd (   1) (      -1)
    $01be (   1) (I7_U_NCT)   $01bf (   1) (      56)   $01c6 (   1) (      -2)   $01c9 (   1) (      -2)
    $01cc (   1) (      -2)   $01ce ( -15) (      -1)   $01dd (   1) (     -79)   $01df ( -17) (      -1)
    $01f0 (   1) (I7_U_NCT)   $01f3 (   1) (      -2)   $01f5 (   1) (      -1)   $01f9 ( -39) (      -1)
    $0221 (   1) (I7_U_NCT)   $0223 ( -17) (      -1)   $0234 (   3) (I7_U_NCT)   $0250 (   3) (I7_U_NCT)
    $0253 (   1) (    -210)   $0254 (   1) (    -206)   $0255 (   1) (I7_U_NCT)   $0256 (   2) (    -205)
    $0258 (   1) (I7_U_NCT)   $0259 (   1) (    -202)   $025a (   1) (I7_U_NCT)   $025b (   1) (    -203)
    $025c (   4) (I7_U_NCT)   $0260 (   1) (    -205)   $0261 (   2) (I7_U_NCT)   $0263 (   1) (    -207)
    $0264 (   4) (I7_U_NCT)   $0268 (   1) (    -209)   $0269 (   1) (    -211)   $026a (   5) (I7_U_NCT)
    $026f (   1) (    -211)   $0270 (   2) (I7_U_NCT)   $0272 (   1) (    -213)   $0273 (   2) (I7_U_NCT)
    $0275 (   1) (    -214)   $0276 (  10) (I7_U_NCT)   $0280 (   1) (    -218)   $0281 (   2) (I7_U_NCT)
    $0283 (   1) (    -218)   $0284 (   4) (I7_U_NCT)   $0288 (   1) (    -218)   $0289 (   1) (I7_U_NCT)
    $028a (   2) (    -217)   $028c (   6) (I7_U_NCT)   $0292 (   1) (    -219)   $0293 (  29) (I7_U_NCT)
    $0390 (   1) (I7_U_NCT)   $03ac (   1) (     -38)   $03ad (   3) (     -37)   $03b0 (   1) (I7_U_NCT)
    $03b1 (  17) (     -32)   $03c2 (   1) (     -31)   $03c3 (   9) (     -32)   $03cc (   1) (     -64)
    $03cd (   2) (     -63)   $03d0 (   1) (     -62)   $03d1 (   1) (     -57)   $03d5 (   1) (     -47)
    $03d6 (   1) (     -54)   $03d7 (   1) (I7_U_NCT)   $03d9 ( -23) (      -1)   $03f0 (   1) (     -86)
    $03f1 (   1) (     -80)   $03f2 (   1) (       7)   $03f3 (   1) (I7_U_NCT)   $03f5 (   1) (     -96)
    $03f8 (   1) (      -1)   $03fb (   1) (      -1)   $0430 (  32) (     -32)   $0450 (  16) (     -80)
    $0461 ( -33) (      -1)   $048b ( -53) (      -1)   $04c2 ( -13) (      -1)   $04d1 ( -37) (      -1)
    $04f9 (   1) (      -1)   $0501 ( -15) (      -1)   $0561 (  38) (     -48)   $0587 (   1) (I7_U_NCT)
    $1d00 (  44) (I7_U_NCT)   $1d62 (  10) (I7_U_NCT)   $1e01 (-149) (      -1)   $1e96 (   5) (I7_U_NCT)
    $1e9b (   1) (     -59)   $1ea1 ( -89) (      -1)   $1f00 (   8) (       8)   $1f10 (   6) (       8)
    $1f20 (   8) (       8)   $1f30 (   8) (       8)   $1f40 (   6) (       8)   $1f50 (   1) (I7_U_NCT)
    $1f51 (   1) (       8)   $1f52 (   1) (I7_U_NCT)   $1f53 (   1) (       8)   $1f54 (   1) (I7_U_NCT)
    $1f55 (   1) (       8)   $1f56 (   1) (I7_U_NCT)   $1f57 (   1) (       8)   $1f60 (   8) (       8)
    $1f70 (   2) (      74)   $1f72 (   4) (      86)   $1f76 (   2) (     100)   $1f78 (   2) (     128)
    $1f7a (   2) (     112)   $1f7c (   2) (     126)   $1f80 (   8) (       8)   $1f90 (   8) (       8)
    $1fa0 (   8) (       8)   $1fb0 (   2) (       8)   $1fb2 (   1) (I7_U_NCT)   $1fb3 (   1) (       9)
    $1fb4 (  -3) (I7_U_NCT)   $1fb7 (   1) (I7_U_NCT)   $1fbe (   1) (   -7205)   $1fc2 (   1) (I7_U_NCT)
    $1fc3 (   1) (       9)   $1fc4 (  -3) (I7_U_NCT)   $1fc7 (   1) (I7_U_NCT)   $1fd0 (   2) (       8)
    $1fd2 (   2) (I7_U_NCT)   $1fd6 (   2) (I7_U_NCT)   $1fe0 (   2) (       8)   $1fe2 (   3) (I7_U_NCT)
    $1fe5 (   1) (       7)   $1fe6 (   2) (I7_U_NCT)   $1ff2 (   1) (I7_U_NCT)   $1ff3 (   1) (       9)
    $1ff4 (  -3) (I7_U_NCT)   $1ff7 (   1) (I7_U_NCT)   $2071 (   1) (I7_U_NCT)   $207f (   1) (I7_U_NCT)
    $210a (   1) (I7_U_NCT)   $210e (   2) (I7_U_NCT)   $2113 (   1) (I7_U_NCT)   $212f (   1) (I7_U_NCT)
    $2134 (   1) (I7_U_NCT)   $2139 (   1) (I7_U_NCT)   $213d (   1) (I7_U_NCT)   $2146 (   4) (I7_U_NCT)
    $fb00 (   7) (I7_U_NCT)   $fb13 (   5) (I7_U_NCT)   $ff41 (  26) (     -32)   $0000
;

Array I7_Char_Casing_Chart_1 -->
    $0041 (  26) (      32)   $00c0 (  23) (      32)   $00d8 (   7) (      32)   $0100 ( -47) (       1)
    $0130 (   1) (    -199)   $0132 (  -5) (       1)   $0139 ( -15) (       1)   $014a ( -45) (       1)
    $0178 (   1) (    -121)   $0179 (  -5) (       1)   $0181 (   1) (     210)   $0182 (  -3) (       1)
    $0186 (   1) (     206)   $0187 (   1) (       1)   $0189 (   2) (     205)   $018b (   1) (       1)
    $018e (   1) (      79)   $018f (   1) (     202)   $0190 (   1) (     203)   $0191 (   1) (       1)
    $0193 (   1) (     205)   $0194 (   1) (     207)   $0196 (   1) (     211)   $0197 (   1) (     209)
    $0198 (   1) (       1)   $019c (   1) (     211)   $019d (   1) (     213)   $019f (   1) (     214)
    $01a0 (  -5) (       1)   $01a6 (   1) (     218)   $01a7 (   1) (       1)   $01a9 (   1) (     218)
    $01ac (   1) (       1)   $01ae (   1) (     218)   $01af (   1) (       1)   $01b1 (   2) (     217)
    $01b3 (  -3) (       1)   $01b7 (   1) (     219)   $01b8 (   1) (       1)   $01bc (   1) (       1)
    $01c4 (   1) (       2)   $01c7 (   1) (       2)   $01ca (   1) (       2)   $01cd ( -15) (       1)
    $01de ( -17) (       1)   $01f1 (   1) (       2)   $01f4 (   1) (       1)   $01f6 (   1) (     -97)
    $01f7 (   1) (     -56)   $01f8 ( -39) (       1)   $0220 (   1) (    -130)   $0222 ( -17) (       1)
    $0386 (   1) (      38)   $0388 (   3) (      37)   $038c (   1) (      64)   $038e (   2) (      63)
    $0391 (  17) (      32)   $03a3 (   9) (      32)   $03d2 (   3) (I7_U_NCT)   $03d8 ( -23) (       1)
    $03f4 (   1) (     -60)   $03f7 (   1) (       1)   $03f9 (   1) (      -7)   $03fa (   1) (       1)
    $0400 (  16) (      80)   $0410 (  32) (      32)   $0460 ( -33) (       1)   $048a ( -53) (       1)
    $04c0 (   1) (I7_U_NCT)   $04c1 ( -13) (       1)   $04d0 ( -37) (       1)   $04f8 (   1) (       1)
    $0500 ( -15) (       1)   $0531 (  38) (      48)   $10a0 (  38) (I7_U_NCT)   $1e00 (-149) (       1)
    $1ea0 ( -89) (       1)   $1f08 (   8) (      -8)   $1f18 (   6) (      -8)   $1f28 (   8) (      -8)
    $1f38 (   8) (      -8)   $1f48 (   6) (      -8)   $1f59 (  -7) (      -8)   $1f68 (   8) (      -8)
    $1fb8 (   2) (      -8)   $1fba (   2) (     -74)   $1fc8 (   4) (     -86)   $1fd8 (   2) (      -8)
    $1fda (   2) (    -100)   $1fe8 (   2) (      -8)   $1fea (   2) (    -112)   $1fec (   1) (      -7)
    $1ff8 (   2) (    -128)   $1ffa (   2) (    -126)   $2102 (   1) (I7_U_NCT)   $2107 (   1) (I7_U_NCT)
    $210b (   3) (I7_U_NCT)   $2110 (   3) (I7_U_NCT)   $2115 (   1) (I7_U_NCT)   $2119 (   5) (I7_U_NCT)
    $2124 (   1) (I7_U_NCT)   $2126 (   1) (   -7517)   $2128 (   1) (I7_U_NCT)   $212a (   1) (   -8383)
    $212b (   1) (   -8262)   $212c (   2) (I7_U_NCT)   $2130 (   2) (I7_U_NCT)   $2133 (   1) (I7_U_NCT)
    $213e (   2) (I7_U_NCT)   $2145 (   1) (I7_U_NCT)   $ff21 (  26) (      32)   $0000
;

#ENDIF; ! I7_Large_Unicode_Tables

! End of UnicodeData.i6

! Char.i6

#ifdef I7_Char_Casing_Chart_0;

[ I7_iscase c case
	i tab min max len par;
	if (c<'A') rfalse;
	if (case == 0) {
		if ((c >= 'a') && (c <= 'z')) rtrue;
		tab = I7_Char_Casing_Chart_0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) rtrue;
		tab = I7_Char_Casing_Chart_1;
	}
	if (c<128) rfalse;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) rfalse;
		if (c < min+len) {
			if (par) { if ((c-min) % 2 == 0) rtrue; }
			else { rtrue; }
		}
	}
	rfalse;
];

[ I7_tocase c case
	i tab min max len par del f;
	if (c<'A') return c;
	if (case == 1) {
		if ((c >= 'a') && (c <= 'z')) return c-32;
		tab = I7_Char_Casing_Chart_0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) return c+32;
		tab = I7_Char_Casing_Chart_1;
	}
	if (c<128) return c;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		del = tab-->i; i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) return c;
		if (c < min+len) {
			f = false;
			if (par) { if ((c-min) % 2 == 0) f = true; }
			else { f = true; }
			if (f) {
				if (del == I7_U_NCT) return c;
				return c+del;
			}
		}
	}
	return c;
];

[ I7_testcases case i j;
	for (i=32: i<$E0; i++) {
		if ((i>=127) && (i<155)) continue;
		print i, " - ", (char) i, " -";
		if (I7_iscase(i, 0)) print "  lower";
		if (I7_iscase(i, 1)) print "  upper";
		j = I7_tocase(i, 0); if (j ~= i) print "  tolower: ", (char) j;
		j = I7_tocase(i, 1); if (j ~= i) print "  toupper: ", (char) j;
		print "^";
	}
];

#endif; ! I7_Char_Casing_Chart_0;

! End of Char.i6


! Compulsory services required by NI:

[ I7_INDEXED_TEXT_TY_Create opcast x;
	x =  I7_Blk_Allocate(32, INDEXED_TEXT_TY, I7_IT_Storage_Flags);
	!print "Created as ", I7_Blk_Type(x), "^";
	if (opcast) I7_INDEXED_TEXT_TY_Cast(opcast, TEXT_TY, x);
	return x;
];

[ I7_INDEXED_TEXT_TY_Free indt;
];

[ I7_INDEXED_TEXT_TY_Deep_Copy ito ifrom;
];

[ I7_INDEXED_TEXT_TY_Say indt ch i dsize;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	dsize = I7_Blk_Get_Extent(indt);
	for (i=0:i<dsize:i++) {
		ch = I7_Blk_Get(indt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
			#ifdef I7_IT_Storage_Glulx_Unicode;
			glk_put_char_uni(ch);
			#ifnot; ! I7_IT_Storage_Glulx_Unicode
			print (char) ch;
			#endif;
		#endif;
	}
];

#ifndef I7_IT_MAX_LENGTH;
Constant I7_IT_MAX_LENGTH = 512;
#endif;

#ifdef TARGET_ZCODE;
Array I7_Raw_Buffer -> I7_IT_MAX_LENGTH;
#ifnot;
#IFDEF I7_IT_Storage_Glulx_Unicode;
Array I7_Raw_Buffer --> I7_IT_MAX_LENGTH;
#ifnot; ! I7_IT_Storage_Glulx_Unicode
Array I7_Raw_Buffer -> I7_IT_MAX_LENGTH;
#endif; ! I7_IT_Storage_Glulx_Unicode
Array I7_Raw_Buffer_Results --> 2;
#endif;

Global I7_Raw_Buffer_Address = I7_Raw_Buffer;
Global I7_Raw_Buffer_Size = I7_IT_MAX_LENGTH;
!Global I7_Raw_Buffer_Size = 10;

[ I7_INDEXED_TEXT_TY_Cast tx fromkov indt len i str oldstr offs realloc news;
	.RetryWithLargerBuffer;
	!print "trying with buffer length ", I7_Raw_Buffer_Size, "^";
	if (tx == 0) {
		#ifdef TARGET_ZCODE;
		I7_Raw_Buffer_Address-->0 = 1;
		I7_Raw_Buffer_Address->2 = 0;
		#ifnot;
		I7_Raw_Buffer_Address-->0 = 0;
		#endif;
		len = 1;
	} else {
		#ifdef TARGET_ZCODE;
		@output_stream 3 I7_Raw_Buffer_Address;
		#ifnot;
		oldstr = glk_stream_get_current();
		#IFDEF I7_IT_Storage_Glulx_Unicode;
		str = glk_stream_open_memory_uni(I7_Raw_Buffer_Address, I7_Raw_Buffer_Size, filemode_Write, 0);
		#IFNOT;
		str = glk_stream_open_memory(I7_Raw_Buffer_Address, I7_Raw_Buffer_Size, filemode_Write, 0);
		#ENDIF;
		glk_stream_set_current(str);
		#endif;
		if (fromkov == SNIPPET_TY) print (PrintSnippet) tx;
		else {
			if (tx ofclass String) print (string) tx;
			if (tx ofclass Routine) (tx)();	
		}
		#ifdef TARGET_ZCODE;
		@output_stream -3;
		len = I7_Raw_Buffer_Address-->0;
		if (len > I7_Raw_Buffer_Size-1) len = I7_Raw_Buffer_Size-1;
		offs = 2;
		I7_Raw_Buffer_Address->(len+2) = 0;
		#ifnot; ! i.e. GLULX
		
		glk_stream_close(str, I7_Raw_Buffer_Results);
		glk_stream_set_current(oldstr);
		len = I7_Raw_Buffer_Results-->1; ! "Writecount"
		if (len > I7_Raw_Buffer_Size-1) {
			!print "Possible buffer overrun^";
			@gestalt 7 0 i;
			if (i ~= 0) {
				!print "gestalt allows^";
				news = I7_Raw_Buffer_Size;
				while (news < len) news=news*2;
				news = news*4; ! Bytes rather than words
				@malloc news i;
				if (i ~= 0) {
					I7_Raw_Buffer_Address = i;
					I7_Raw_Buffer_Size = news/4;
					!print "Increasing raw buffer size to ", I7_Raw_Buffer_Size, "^";
					jump RetryWithLargerBuffer;
				}
			}
			!print "gestalt refused: trimming^";
			len = I7_Raw_Buffer_Size-1;
		}
		!print "no overrun^";
		offs = 0;
		#IFDEF I7_IT_Storage_Glulx_Unicode;
		I7_Raw_Buffer_Address-->(len) = 0;
		#IFNOT;
		I7_Raw_Buffer_Address->(len) = 0;
		#ENDIF;
		#endif;
		len++;
	}
	!print "Writing ", len, " chars to indt ", indt, "^";

	if (indt == 0) {
		indt = I7_Blk_Allocate(len+1, INDEXED_TEXT_TY, I7_IT_Storage_Flags);
		if (indt == 0) return;
		! print "As created: "; I7_Blk_Debug(indt);
	} else {
		if (I7_Blk_Change_Extent(indt, len+1, 1) == false) return;
	}

	#ifdef TARGET_ZCODE;
	for (i=0:i<=len:i++) I7_Blk_Put(indt, i, I7_Raw_Buffer_Address->(i+offs));
	#ifnot;
	#IFDEF I7_IT_Storage_Glulx_Unicode;
	for (i=0:i<=len:i++) I7_Blk_Put(indt, i, I7_Raw_Buffer_Address-->(i+offs));
	#IFNOT;
	for (i=0:i<=len:i++) I7_Blk_Put(indt, i, I7_Raw_Buffer_Address->(i+offs));
	#endif;
	#endif;

	return indt;
];

[ I7_INDEXED_TEXT_TY_Compare txbleft txbright pos ch1 ch2 dsizeleft dsizeright;
	dsizeleft = I7_Blk_Get_Extent(txbleft);
	dsizeright = I7_Blk_Get_Extent(txbright);
	for (pos=0:(pos<dsizeleft) && (pos<dsizeright):pos++) {
		ch1 = I7_Blk_Get(txbleft, pos);
		ch2 = I7_Blk_Get(txbright, pos);
		if (ch1 ~= ch2) return ch2-ch1;
		if (ch1 == 0) return 0;
	}
	if (pos == dsizeleft) return 1;
	return -1;
];

[ I7_INDEXED_TEXT_TY_Understand txb
	pos len wa wl wpos bdm ch own;
	if (txb == 0) return GPR_FAIL;
	bdm = true; own = wn;
	len = I7_Blk_Get_Extent(txb); !print "Parsing: "; I7_INDEXED_TEXT_TY_Say(txb); print "^";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = I7_Blk_Get(txb, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true; !print "wpos = ", wl, "^";
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1); !print "wl = ", wl, "^";
				wpos = 0;
			}
			!print (char) wa->wpos, " vs ", (char) ch, "^";
			if (wa->wpos ~= ch or I7_IT_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	!print "YES^";
	return GPR_PREPOSITION;
];

[ I7_INDEXED_TEXT_TY_Distinguish txb1 txb2;
	if (I7_INDEXED_TEXT_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ I7_INDEXED_TEXT_TY_WFF txb len pos ch;
	len = I7_Blk_Get_Extent(txb);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = I7_Blk_Get(txb, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
];

[ I7_INDEXED_TEXT_TY_RFF txb auxf ch i v dg pos tsize;
	!print "I7_INDEXED_TEXT_TY_RFF: ", txb, " ", auxf, " ", ch, "^";
	tsize = I7_Blk_Get_Extent(txb);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = I7_FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (I7_Blk_Change_Extent(txb, 2*pos, 20) == false) break;
				tsize = I7_Blk_Get_Extent(txb);
			}
			I7_Blk_Put(txb, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	I7_Blk_Put(txb, pos, 0);
	!print "Read ", pos, " characters up to ch = ", ch, "^";
	!print "Viz: "; I7_INDEXED_TEXT_TY_Say(txb); print "^";
	return txb;
];

! Optional services used only by definitions in the Standard Rules:

Constant CHR_BLOB = 1;
Constant WORD_BLOB = 2;
Constant PWORD_BLOB = 3;
Constant UWORD_BLOB = 4;
Constant PARA_BLOB = 5;
Constant LINE_BLOB = 6;
Constant REGEXP_BLOB = 7;

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ I7_IT_Blob_Length indt blobtype cindt blobcountwanted rindt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return 0;
	if (blobtype == CHR_BLOB) return I7_IT_Character_Length(indt);
	dsize = I7_Blk_Get_Extent(indt);
	if (cindt) csize = I7_Blk_Get_Extent(cindt);
	else if (rindt) "*** rindt without cindt ***";
!	print "Cindt is "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
!	print "Rindt is "; I7_INDEXED_TEXT_TY_Say(rindt); print "^";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
!		print "i = ", i, "^";
		ch = I7_Blk_Get(indt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = I7_Blk_Get(indt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = I7_Blk_Get(indt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == I7_Blk_Get(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == I7_Blk_Get(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((cindt) && (blobcount == blobcountwanted)) {
				if (rindt) {
!	print "Cindt is initially "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
					I7_Blk_Put(cindt, cl, 0);
					I7_IT_Concatenate(cindt, rindt, CHR_BLOB);
!	print "Cindt is then "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
					csize = I7_Blk_Get_Extent(cindt);
					cl = I7_IT_Character_Length(cindt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (I7_Blk_Change_Extent(cindt, 2*cl, 2) == false) break;
						csize = I7_Blk_Get_Extent(cindt);
					}
					I7_Blk_Put(cindt, cl++, ch);
				}
			} else {
				if (rindt) {
					if (cl+1 >= csize) {
						if (I7_Blk_Change_Extent(cindt, 2*cl, 3) == false) break;
						csize = I7_Blk_Get_Extent(cindt);
					}
					I7_Blk_Put(cindt, cl++, ch);
				}
			}
		} else {
			if ((rindt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (I7_Blk_Change_Extent(cindt, 2*cl, 4) == false) break;
					csize = I7_Blk_Get_Extent(cindt);
				}
				I7_Blk_Put(cindt, cl++, ch);
			}
		}
	}
	if (cindt) I7_Blk_Put(cindt, cl++, 0);
	return blobcount;
];

[ I7_IT_Replace_Blob blobtype indt blobcountwanted rindt cindt ilen rlen i;
	if (blobtype == CHR_BLOB) {
		ilen = I7_IT_Character_Length(indt);
		rlen = I7_IT_Character_Length(rindt);
		!	print "Indt is "; I7_INDEXED_TEXT_TY_Say(indt); print "^";
		!	print "Rindt is "; I7_INDEXED_TEXT_TY_Say(rindt); print "^";
		!	print "bcw is ", blobcountwanted, "^";
		blobcountwanted--;
		if ((blobcountwanted >= 0) && (blobcountwanted<ilen)) {
			if (rlen == 1) {
				I7_Blk_Put(indt, blobcountwanted, I7_Blk_Get(rindt, 0));
			} else {
				cindt = I7_Blk_Create(INDEXED_TEXT_TY);
				if (I7_Blk_Change_Extent(cindt, ilen+rlen+1, 5)) {
					for (i=0:i<blobcountwanted:i++)
						I7_Blk_Put(cindt, i, I7_Blk_Get(indt, i));
					for (i=0:i<rlen:i++)
						I7_Blk_Put(cindt, blobcountwanted+i, I7_Blk_Get(rindt, i));
					for (i=blobcountwanted+1:i<ilen:i++)
						I7_Blk_Put(cindt, rlen+i-1, I7_Blk_Get(indt, i));
					I7_Blk_Put(cindt, rlen+ilen, 0);
					I7_Blk_Deep_Copy(indt, cindt);
				}
				I7_Blk_Free(cindt);
			}
		}
	} else {
		cindt = I7_Blk_Create(INDEXED_TEXT_TY);
		I7_IT_Blob_Length(indt, blobtype, cindt, blobcountwanted, rindt);
		!	print "Cindt is ultimately "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
		I7_Blk_Deep_Copy(indt, cindt);	
		!	print "Indt is deeply "; I7_INDEXED_TEXT_TY_Say(indt); print "^";
		I7_Blk_Free(cindt);
	}
];

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;

Constant RE_MAX_PACKETS = 32;
Constant RE_PACKET_SIZE = 14; ! Words, that is
#ifdef TARGET_ZCODE;
Constant RE_PACKET_SIZE_IN_BYTES = 2*RE_PACKET_SIZE;
#ifnot;
Constant RE_PACKET_SIZE_IN_BYTES = 4*RE_PACKET_SIZE;
#endif;
Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;
Constant RE_CCLASS = 0;
Constant RE_PAR1 = 1;
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;
Constant RE_PREVIOUS = 5;
Constant RE_DOWN = 6;
Constant RE_UP = 7;
Constant RE_DATA1 = 8;
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;

[ I7_IT_RE_Node n cc par1 par2 par3
	offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = I6_NULL;
	offset-->RE_PREVIOUS = I6_NULL;
	offset-->RE_DOWN = I6_NULL;
	offset-->RE_UP = I6_NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ I7_IT_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];

Array RE_Subexpressions --> 11;
Array I7_IT_RE_Match_Vars --> 10;
Array Allocated_Match_Vars --> 10;

[ I7_IT_RE_Debug_Match_Vars indt
	offset n i;
	print n<RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1, " = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) I7_Blk_Get(indt, i);
		print "^";
	}
];

[ I7_IT_Empty_Match_Vars indt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			I7_Blk_Put(Allocated_Match_Vars-->n, 0, 0);
];

[ I7_IT_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ I7_IT_Create_Match_Vars indt
	offset n i ch cindt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n == 0)
			Allocated_Match_Vars-->n = I7_INDEXED_TEXT_TY_Create(); ! Permanently
		cindt = Allocated_Match_Vars-->n;
		csize = I7_Blk_Get_Extent(cindt);
		cl = 0;
		!print "Variable ", n, " = ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, " is ", Allocated_Match_Vars-->n, "^";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = I7_Blk_Get(indt, i); !print (char) ch;
			if (cl+1 >= csize) {
				if (I7_Blk_Change_Extent(cindt, 2*cl, 6) == false) break;
				csize = I7_Blk_Get_Extent(cindt);
			}
			I7_Blk_Put(cindt, cl++, ch);
			!print ch;
		}
		!print "^";
		I7_Blk_Put(cindt, cl, 0);
		!I7_INDEXED_TEXT_TY_Say(cindt);
	}
];

[ I7_IT_Get_Match_Var indt vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) jump Nope;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) jump Nope;
	if (offset-->RE_DATA1 < 0) jump Nope;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		jump Nope;
	}
	!print "DC at ", Allocated_Match_Vars-->vn;
	!I7_INDEXED_TEXT_TY_Say(Allocated_Match_Vars-->vn);
	I7_Blk_Deep_Copy(indt, Allocated_Match_Vars-->vn);
	!I7_Blk_Put(indt, 0, 0);
	return indt;
	.Nope;
	I7_Blk_Put(indt, 0, 0);
	return indt;
];

[ I7_IT_RE_Clear_Markers token;
	for (: token ~= I6_NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= I6_NULL) I7_IT_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];

[ I7_IT_Debug_SearchNode offset findt detail
	i par1 par2 par3;
	if (offset == I6_NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) I7_Blk_Get(findt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) I7_Blk_Get(findt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];

[ I7_IT_Debug_SearchR findt depth offset detail
	cup;
	if (offset ~= I6_NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= I6_NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= I6_NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		I7_IT_Debug_SearchNode(offset, findt, detail);
		if (offset-->RE_DOWN ~= I6_NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			I7_IT_Debug_SearchR(findt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= I6_NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ I7_IT_Debug_Search findt detail;
	print "Pattern: ", (I7_INDEXED_TEXT_TY_Say) findt, "^";
	I7_IT_Debug_SearchR(findt, 1, RE_PACKET_space, detail);
];

[ I7_IT_CHR_Compile findt
	root literal fto;

	fto = I7_IT_Character_Length(findt);

	root = I7_IT_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = I7_IT_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	return 2;
];

Array Subexp_Posns --> 20;
[ I7_IT_REGEXP_Compile findt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	!print ">> "; I7_INDEXED_TEXT_TY_Say(findt); print "^";


	fto = I7_IT_Character_Length(findt);
	if (fto == 0) {
		I7_IT_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = I7_IT_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		!print "FF is ", ffrom, "^";
		cc = I7_Blk_Get(findt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = I7_Blk_Get(findt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (I7_Blk_Get(findt, ffrom) == ')') return "empty subexpression";
					if (I7_Blk_Get(findt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (I7_Blk_Get(findt, ffrom) == '-') { ffrom++; bits = false; }
						else if (I7_Blk_Get(findt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = I7_Blk_Get(findt, ffrom++)) {
							'#': while (I7_Blk_Get(findt, ffrom++) ~= 0 or ')') ;
								if (I7_Blk_Get(findt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = I7_Blk_Get(findt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(I7_Blk_Get(findt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = I7_IT_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (I7_Blk_Get(findt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (I7_Blk_Get(findt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = I7_IT_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == I6_NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							I7_IT_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=I7_Blk_Get(findt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (I7_Blk_Get(findt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (I7_Blk_Get(findt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = I7_Blk_Get(findt, ffrom++);
						if (cc == '\') {
							cc = I7_Blk_Get(findt, ffrom++);
							if (cc ~= 0) cc = I7_Blk_Get(findt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(I7_Blk_Get(findt, par1) == ':') &&
						(I7_Blk_Get(findt, par2-1) == ':') &&
						(I7_Blk_Get(findt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = I7_IT_RE_Verify_Range(findt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(I7_Blk_Get(findt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (I7_IT_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (I7_IT_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			I7_IT_Debug_SearchNode(attach_to, findt);
			I7_IT_Debug_Search(findt);
		}

		token = I7_IT_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == I6_NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= I6_NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= I6_NULL) && (attach_to-->RE_PREVIOUS == I6_NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= I6_NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = I6_NULL;
					if (token-->RE_PREVIOUS ~= I6_NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = I7_IT_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (I7_IT_RE_Trace == 2) {
			print "Result:^";
			I7_IT_Debug_Search(findt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = I7_IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = I7_IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = I7_IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= I6_NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = I7_IT_RE_Expand_Choices(RE_PACKET_space, no_packets);

	if (I7_IT_RE_Trace) {
		print "Compiled pattern:^";
		I7_IT_Debug_Search(findt);
	}
	
	bits = I7_IT_RE_Check_Tree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ I7_IT_RE_Expand_Choices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= I6_NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=I6_NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = I7_IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= I6_NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = I6_NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = I6_NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = I7_IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = I7_IT_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = I6_NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = I6_NULL;
				if (then_node-->RE_DOWN ~= I6_NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = I6_NULL;
				for (nex = then_node-->RE_DOWN: nex ~= I6_NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= I6_NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= I6_NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!I7_IT_Debug_SearchR(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= I6_NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == I6_NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = I7_IT_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= I6_NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= I6_NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = I6_NULL;
			ct = 1;
			while (token ~= I6_NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= I6_NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = I6_NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= I6_NULL) token-->RE_NEXT = I6_NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= I6_NULL) {
			no_packets = I7_IT_RE_Expand_Choices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ I7_IT_RE_Check_Tree token no_subs
	rv;
	while (token ~= I6_NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = I7_IT_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= I6_NULL) {
			rv = I7_IT_RE_Check_Tree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ I7_IT_RE_Width token downwards
	w rv aw choice;
	while (token ~= I6_NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = I7_IT_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= I7_IT_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = I7_IT_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = I7_IT_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= I6_NULL: choice = choice-->RE_NEXT) {
					rv = I7_IT_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= I6_NULL) token = token-->RE_NEXT;
	}
	return w;
];

Global I7_IT_RE_RewindCount;
[ I7_IT_RE_DebR;
	print I7_IT_RE_RewindCount;
];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ I7_IT_RE_Parse_RE findt indt ipos insens
	ilen rv root i initial_mode;

	ilen = I7_IT_Character_Length(indt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	I7_IT_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= I6_NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) I7_IT_RE_Parse_RE_Start_Fresh(RE_PACKET_space, initial_mode);
		I7_IT_RE_RewindCount = 0;
		rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];

! Returns: no chars matched for match (may be 0), -1 for no match

[ I7_IT_RE_Parse_RE_R findt indt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= I6_NULL) {
		outcome = false;
				if (I7_IT_RE_Trace) {
					print "Matching at ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}

		if (ipos<ito) ch = I7_Blk_Get(indt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (I7_Blk_Get(indt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (I7_Blk_Get(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = I7_Blk_Get(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (I7_Blk_Get(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = I7_Blk_Get(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (I7_IT_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (I7_IT_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == I6_NULL)
						rv = 0; ! The empty else clause matches
					else rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (I7_IT_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= I6_NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (I7_IT_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						I7_IT_Debug_SearchNode(ch, findt, true);
					}
					rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (I7_IT_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							I7_IT_Debug_SearchNode(ch, findt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							I7_IT_RE_Fail_Subexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (I7_IT_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = I7_IT_RE_Parse_RE_R(findt, indt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) I7_IT_RE_Fail_Subexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (I7_IT_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (I7_IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							I7_IT_Debug_SearchNode(token, findt, true);
						}
						rv = I7_IT_RE_Parse_RE_R(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1; if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (I7_IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							I7_IT_Debug_SearchNode(token, findt, true);
						}
						rv = I7_IT_RE_Parse_RE_R(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						I7_IT_RE_Fail_Subexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (I7_IT_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						I7_IT_RE_Fail_Subexpressions(token-->RE_DOWN);
					if (I7_IT_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (I7_iscase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (I7_iscase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (I7_iscase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (I7_iscase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (I7_IT_RE_Range(ch, findt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = I7_IT_RE_Submatch(indt, ipos,
					findt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = I7_IT_RE_Submatch(indt, ipos,
						indt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (I7_IT_RE_RewindCount++ >= 10000) {
				if (I7_IT_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (I7_IT_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					I7_IT_Debug_SearchNode(token, findt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(I7_IT_RE_Seek_Rewind(token-->RE_DOWN, findt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) I7_IT_RE_Fail_Subexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= I6_NULL) {
				if (I7_IT_RE_Seek_Rewind(token, findt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						I7_IT_RE_Fail_Subexpressions(token, true);
					if (ipos == -1)
						I7_IT_Debug_Search(findt, true);
					if (I7_IT_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (I7_IT_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];

[ I7_IT_RE_Fail_Subexpressions token downwards;
	for (: token ~= I6_NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= I6_NULL) I7_IT_RE_Fail_Subexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];

[ I7_IT_RE_Seek_Rewind token findt downwards ito report_only
	untried;
	for (: token ~= I6_NULL: token = token-->RE_NEXT) {
		if ((I7_IT_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			I7_IT_Debug_SearchNode(token, findt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= I6_NULL) {
			if ((I7_IT_RE_Trace) && (report_only == false)) print "Descend^";
			if (I7_IT_RE_Seek_Rewind(token-->RE_DOWN, findt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than the last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((I7_IT_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (I7_IT_RE_Trace) {
				print "Grounds for rewind at: ";
				I7_IT_Debug_SearchNode(token, findt, true);
			}
			I7_IT_RE_Parse_RE_Start_Fresh(token-->RE_NEXT);
			I7_IT_RE_Parse_RE_Start_Fresh(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];

[ I7_IT_RE_Parse_RE_Start_Fresh token;
	while (token ~= I6_NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC:
				token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) I7_IT_RE_Parse_RE_Start_Fresh(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];

[ I7_IT_RE_Verify_Range findt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = I7_Blk_Get(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = I7_Blk_Get(findt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (I7_Blk_Get(findt, i+1) == '-')) {
			if (chm > I7_Blk_Get(findt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ I7_IT_RE_Range ch findt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (I7_IT_RE_Range(ch, findt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = I7_Blk_Get(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = I7_Blk_Get(findt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (I7_iscase(ch, 0)) rtrue;
				'L': if (I7_iscase(ch, 0) == false) rtrue;
				'u': if (I7_iscase(ch, 1)) rtrue;
				'U': if (I7_iscase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		}
		if ((i+2<rt) && (I7_Blk_Get(findt, i+1) == '-')) {
			upper = I7_Blk_Get(findt, i+2);
			if ((ch >= chm) && (ch <= upper)) rtrue;
			if (insens) {
				crev = I7_IT_RevCase(ch);
				if ((crev >= chm) && (crev <= upper)) rtrue;
			}
			i=i+2;
		} else {
			if (chm == ch) rtrue;
			if ((insens) && (chm == I7_IT_RevCase(ch))) rtrue;
		}
	}
	rfalse;
];

[ I7_IT_RE_Submatch indt ipos mindt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = I7_Blk_Get(mindt, i);
			if (I7_Blk_Get(indt, ipos++) ~= ch or I7_IT_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (I7_Blk_Get(indt, ipos++) ~= I7_Blk_Get(mindt, i))
				return -1;
	return mto-mfrom;
];

#IFDEF TARGET_ZCODE;
[ I7_IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ I7_IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (I7_iscase(ch, 0)) return I7_tocase(ch, 1);
	if (I7_iscase(ch, 1)) return I7_tocase(ch, 0);
	return ch;
];
#ENDIF;

[ I7_IT_Replace_RE blobtype indt findt rindt insens exactly
	cindt csize ilen i cl mpos cpos ch chm;
	ilen = I7_IT_Character_Length(indt);

	I7_IT_RE_Err = 0;
	switch (blobtype) {
		REGEXP_BLOB: i = I7_IT_REGEXP_Compile(findt, exactly);
		CHR_BLOB: i = I7_IT_CHR_Compile(findt);
		default: "*** bad blobtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		I7_IT_RE_Err = i;
		print "*** Regular expression error: ", (string) I7_IT_RE_Err, " ***^";
		return 0;
	}

	if (I7_IT_RE_Trace) {
		I7_IT_Debug_Search(findt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (blobtype == REGEXP_BLOB) I7_IT_Empty_Match_Vars();

	mpos = 0; chm = 0; cpos = 0;
	while (I7_IT_RE_Parse_RE(findt, indt, mpos, insens) >= 0) {
		chm++;
		
		if (I7_IT_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) I7_Blk_Get(indt, i);
			}
			print " ***^";
		}
		
		if (rindt == 0) break; ! Accept only one match, replace nothing
		
		if (rindt ~= 0 or 1) {
			if (chm == 1) {
				cindt = I7_Blk_Create(INDEXED_TEXT_TY);
				csize = I7_Blk_Get_Extent(cindt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = I7_Blk_Get(indt, i);
				if (cl+1 >= csize) {
					if (I7_Blk_Change_Extent(cindt, 2*cl, 7) == false) break;
					csize = I7_Blk_Get_Extent(cindt);
				}
				I7_Blk_Put(cindt, cl++, ch);
			}
			I7_Blk_Put(cindt, cl, 0);
	
			I7_IT_Concatenate(cindt, rindt, blobtype, indt);
			csize = I7_Blk_Get_Extent(cindt);
			cl = I7_IT_Character_Length(cindt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (I7_IT_RE_Trace) {
			if (chm == 100) {
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rindt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = I7_Blk_Get(indt, i);
				if (cl+1 >= csize) {
					if (I7_Blk_Change_Extent(cindt, 2*cl, 8) == false) break;
					csize = I7_Blk_Get_Extent(cindt);
				}
				I7_Blk_Put(cindt, cl++, ch);
			}
		}
		
		if (blobtype == REGEXP_BLOB) {
			I7_IT_Create_Match_Vars(indt);
			if (I7_IT_RE_Trace)
				I7_IT_RE_Debug_Match_Vars(indt);
		}

		if (rindt ~= 0 or 1) {
			I7_Blk_Put(cindt, cl, 0);
			I7_Blk_Deep_Copy(indt, cindt);	
			I7_Blk_Free(cindt);
		}
	}
	return chm;
];

[ I7_IT_Replace_Text blobtype indt findt rindt
	cindt csize ilen flen i cl mpos ch chm whitespace punctuation;
	
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return I7_IT_Replace_RE(blobtype, indt, findt, rindt);
	
	ilen = I7_IT_Character_Length(indt);
	flen = I7_IT_Character_Length(findt);
	cindt = I7_Blk_Create(INDEXED_TEXT_TY);
	csize = I7_Blk_Get_Extent(cindt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = I7_Blk_Get(indt, i);
		.MoreMatching;
		chm = I7_Blk_Get(findt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			!	print ch, " matches^";
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = I7_Blk_Get(indt, i+1);
				!	print chm, " is next^";
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					!	print "Success!^";
					mpos = 0;
					cl = cl - (flen-1);
					I7_Blk_Put(cindt, cl, 0);
					I7_IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = I7_Blk_Get_Extent(cindt);
					cl = I7_IT_Character_Length(cindt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (I7_Blk_Change_Extent(cindt, 2*cl, 9) == false) break;
			csize = I7_Blk_Get_Extent(cindt);
		}
		I7_Blk_Put(cindt, cl++, ch);
	}
	I7_Blk_Deep_Copy(indt, cindt);	
	I7_Blk_Free(cindt);
];

[ I7_IT_Get_Blob cindt indt i blobtype;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	if (blobtype == CHR_BLOB) return I7_IT_Character(cindt, indt, i);
	I7_IT_Blob_Length(indt, blobtype, cindt, i);
	return cindt;
];

[ I7_IT_Character_Length indt ch i dsize;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return 0;
	dsize = I7_Blk_Get_Extent(indt);
	for (i=0:i<dsize:i++) {
		ch = I7_Blk_Get(indt, i);
		if (ch == 0) return i;
	}
	return dsize;
];

[ I7_IT_Character cindt indt i ch;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	if ((i<=0) || (i>I7_IT_Character_Length(indt))) ch = 0;
	else ch = I7_Blk_Get(indt, i-1);
	I7_Blk_Put(cindt, 0, ch);
	I7_Blk_Put(cindt, 1, 0);
	return cindt;
];

[ I7_IT_Of_Case indt case i ch len;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) rfalse;
	len = I7_IT_Character_Length(indt);
	for (i=0:i<len:i++) {
		ch = I7_Blk_Get(indt, i);
		if ((ch) && (I7_iscase(ch, case) == false)) rfalse;
	}
	rtrue;
];

[ I7_IT_To_Case cindt indt case i ch len bnd;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	len = I7_IT_Character_Length(indt);
	if (I7_Blk_Change_Extent(cindt, len+1, 11) == false) return cindt;
	bnd = 1;
	for (i=0:i<len:i++) {
		ch = I7_Blk_Get(indt, i);
		if (case < 2) {
			I7_Blk_Put(cindt, i, I7_tocase(ch, case));
		} else {
			I7_Blk_Put(cindt, i, I7_tocase(ch, bnd));
			if (case == 2) {
				bnd = 0;
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
			}
			if (case == 3) {
				if (ch ~= 0 or 10 or 13 or 32 or 9) {
					if (bnd == 1) bnd = 0;
					else {
						if (ch == '.' or '!' or '?') bnd = 1;
					}
				}
			}
		}
	}
	I7_Blk_Put(cindt, len, 0);
	return cindt;
];

[ I7_IT_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (I7_Blk_Type(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (I7_Blk_Type(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	if (blobtype == CHR_BLOB) {
		pos = I7_IT_Character_Length(indt_to);
		len = I7_IT_Character_Length(indt_from);
		if (I7_Blk_Change_Extent(indt_to, pos+len+1, 10) == false) return indt_to;
		for (i=0:i<len:i++) {
			ch = I7_Blk_Get(indt_from, i);
			I7_Blk_Put(indt_to, i+pos, ch);
		}
		I7_Blk_Put(indt_to, len+pos, 0);
	} else {
		pos = I7_IT_Character_Length(indt_to);
		tosize = I7_Blk_Get_Extent(indt_to);
		len = I7_IT_Character_Length(indt_from);
		for (i=0:i<len:i++) {
			ch = I7_Blk_Get(indt_from, i);
			if ((ch == '\') && (i < len-1)) {
				ch = I7_Blk_Get(indt_from, ++i);
				if (ch == 'n') ch = 10;
				if (ch == 't') ch = 9;
				case = -1;
				if (ch == 'l') case = 0;
				if (ch == 'u') case = 1;
				if (case >= 0) ch = I7_Blk_Get(indt_from, ++i);
				if ((ch >= '0') && (ch <= '9')) {
					ch = ch - '0';
					if (ch < RE_Subexpressions-->10) {
						x = (RE_Subexpressions-->ch)-->RE_DATA1;
						y = (RE_Subexpressions-->ch)-->RE_DATA2;
						if (x >= 0) {
							for (:x<y:x++) {
								ch = I7_Blk_Get(indt_ref, x);
								if (pos+1 >= tosize) {
									if (I7_Blk_Change_Extent(indt_to, 2*tosize, 11) == false) break;
									tosize = I7_Blk_Get_Extent(indt_to);
								}
								if (case >= 0)
									I7_Blk_Put(indt_to, pos++, I7_tocase(ch, case));
								else
									I7_Blk_Put(indt_to, pos++, ch);
							}
						}
					}
					continue;
				}
				
			}
			if (pos+1 >= tosize) {
				if (I7_Blk_Change_Extent(indt_to, 2*tosize, 12) == false) break;
				tosize = I7_Blk_Get_Extent(indt_to);
			}
			I7_Blk_Put(indt_to, pos++, ch);
		}
		I7_Blk_Put(indt_to, pos, 0);
	}
	return indt_to;
];

[ I7_IT_SetPlayersCommand indt_from i len at;
	len = I7_IT_Character_Length(indt_from);
	if (len > 118) len = 118;
#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
#ifnot;
	buffer-->0 = len; at = 4;
#endif;
!print "Len is ", len, "^";
	for (i=0:i<len:i++) {
		buffer->(i+at) = I7_Blk_Get(indt_from, i);
		!print (char) buffer->(i+at);
	}
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	Tokenise__(buffer, parse);
	I7_command = 100 + WordCount();
];

#IFNOT; ! IFDEF I7_HEAP_SIZE

[ I7_INDEXED_TEXT_TY_Say indt; ];
[ I7_IT_SetPlayersCommand indt_from; ];
[ I7_INDEXED_TEXT_TY_Create; ];
[ I7_INDEXED_TEXT_TY_Cast a b c; ];

#ENDIF; ! IFDEF I7_HEAP_SIZE

! End of IndexedText.i6

! StoredAction.i6

#IFDEF I7_HEAP_SIZE; ! Will exist if any use is made of indexed texts

! Compulsory services required by NI:

[ I7_STORED_ACTION_TY_Create opcast stora;
	stora = I7_Blk_Allocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);
	I7_Blk_Put(stora, 0, ##Wait); ! action
	I7_Blk_Put(stora, 1, 0); ! noun
	I7_Blk_Put(stora, 2, 0); ! second
	I7_Blk_Put(stora, 3, player); ! actor
	I7_Blk_Put(stora, 4, false); ! whether a request
	I7_Blk_Put(stora, 5, 0); ! text of command if necessary
	!print "Created at ", stora, "^";
	return stora;
];

[ I7_STORED_ACTION_TY_Say stora text_of_command saved_command;
	if ((stora==0) || (I7_Blk_Type(stora) ~= STORED_ACTION_TY)) return;
	text_of_command = I7_Blk_Get(stora, 5);
	if (text_of_command) {
		saved_command = I7_INDEXED_TEXT_TY_Create();
		I7_INDEXED_TEXT_TY_Cast(I7_command, SNIPPET_TY, saved_command);
		I7_IT_SetPlayersCommand(text_of_command);
		!print "(switching to text of command: ", (I7_INDEXED_TEXT_TY_Say) text_of_command, " at ", I7_Blk_Get(stora, 5), ")^";
	}	
	DB_Action(I7_Blk_Get(stora, 3), I7_Blk_Get(stora, 4),
		I7_Blk_Get(stora, 0), I7_Blk_Get(stora, 1), I7_Blk_Get(stora, 2),
		true);
	if (text_of_command) {
		!print "(switching back to: ", (I7_INDEXED_TEXT_TY_Say) saved_command, ")^";
		I7_IT_SetPlayersCommand(saved_command);
		I7_Blk_Free(saved_command);
	}
];

[ I7_STORED_ACTION_TY_Compare storaleft storaright delta;
	delta = I7_Blk_Get(storaleft, 0) - I7_Blk_Get(storaright, 0);
	if (delta) return delta;
	delta = I7_Blk_Get(storaleft, 1) - I7_Blk_Get(storaright, 1);
	if (delta) return delta;
	delta = I7_Blk_Get(storaleft, 2) - I7_Blk_Get(storaright, 2);
	if (delta) return delta;
	delta = I7_Blk_Get(storaleft, 3) - I7_Blk_Get(storaright, 3);
	if (delta) return delta;
	delta = I7_Blk_Get(storaleft, 4) - I7_Blk_Get(storaright, 4);
	if (delta) return delta;
	delta = I7_Blk_Get(storaleft, 5) - I7_Blk_Get(storaright, 5);
	if (delta) return delta;
	return 0;
];

[ I7_STORED_ACTION_TY_Distinguish txb1 txb2;
	if (I7_STORED_ACTION_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ I7_STORED_ACTION_TY_Free stora toc;
	!print "freeing ", stora, "^";
	toc = I7_Blk_Get(stora, 5);
	if (toc) { I7_Blk_Free(toc); }
	return stora;
];

[ I7_STORED_ACTION_TY_Deep_Copy storato storafrom tocfrom tocto;
	tocfrom = I7_Blk_Get(storafrom, 5);
	if (tocfrom == 0) return;
	tocto = I7_INDEXED_TEXT_TY_Create();
	I7_Blk_Deep_Copy(tocto, tocfrom);
	I7_Blk_Put(storato, 5, tocto);
];

! Optional services used only by definitions in the Standard Rules:

[ I7_STORED_ACTION_TY_Involves stora item at;
	at = FindAction(I7_Blk_Get(stora, 0));
	if (at) {
		if ((ActionData-->(at+2) == OBJECT_TY) && (I7_Blk_Get(stora, 1) == item))
			rtrue;
		if ((ActionData-->(at+3) == OBJECT_TY) && (I7_Blk_Get(stora, 2) == item))
			rtrue;
	}
	if (I7_Blk_Get(stora, 3) == item) rtrue;
	if (I7_Blk_Get(stora, 4) == item) rtrue;
	rfalse;
];

[ I7_STORED_ACTION_TY_Part stora ind at;
	if (ind == 1 or 2) {
		at = FindAction(I7_Blk_Get(stora, 0));
		if ((at) && (ActionData-->(at+ind+1) == OBJECT_TY))
			return I7_Blk_Get(stora, ind);
		return nothing;
	}
	return I7_Blk_Get(stora, ind);
];

Array I7_SAT_Tmp-->6;
[ I7_adopt_STORED_ACTION_TY stora;
	I7_SAT_Tmp-->1 = action;
	I7_SAT_Tmp-->2 = noun;
	I7_SAT_Tmp-->3 = second;
	I7_SAT_Tmp-->4 = actor;
	I7_SAT_Tmp-->5 = act_requester;
	action = I7_Blk_Get(stora, 0);
	noun = I7_Blk_Get(stora, 1);
	second = I7_Blk_Get(stora, 2);
	actor = I7_Blk_Get(stora, 3);
	if (I7_Blk_Get(stora, 4)) act_requester = player; else act_requester = nothing;
];
[ I7_unadopt_STORED_ACTION_TY;
	action = I7_SAT_Tmp-->1;
	noun = I7_SAT_Tmp-->2;
	second = I7_SAT_Tmp-->3;	
	actor = I7_SAT_Tmp-->4;	
	act_requester = I7_SAT_Tmp-->5;
	return I7_SAT_Tmp-->0;
];

[ I7_new_STORED_ACTION_TY a n s ac req stora;
	if (stora == 0) stora = I7_STORED_ACTION_TY_Create();
	I7_Blk_Put(stora, 0, a);
	I7_Blk_Put(stora, 1, n);
	I7_Blk_Put(stora, 2, s);
	I7_Blk_Put(stora, 3, ac);
	I7_Blk_Put(stora, 4, req);
	return stora;
];

[ I7_current_STORED_ACTION_TY stora at text_of_command;
	if ((stora==0) || (I7_Blk_Type(stora) ~= STORED_ACTION_TY)) return 0;
	I7_Blk_Put(stora, 0, action);
	I7_Blk_Put(stora, 1, noun);
	I7_Blk_Put(stora, 2, second);
	I7_Blk_Put(stora, 3, actor);
	if (act_requester) I7_Blk_Put(stora, 4, true); else I7_Blk_Put(stora, 4, false);
	at = FindAction(-1);
	if ((at) &&
		((ActionData-->(at+2) == UNDERSTANDING_TY) || (ActionData-->(at+3) == UNDERSTANDING_TY))) {
		text_of_command = I7_Blk_Get(stora, 5);
		if (text_of_command == 0) {
			text_of_command = I7_INDEXED_TEXT_TY_Create();
			!print "(creating text buffer for stora ", stora, ")^";
			I7_Blk_Put(stora, 5, text_of_command);
		}
		I7_INDEXED_TEXT_TY_Cast(I7_command, SNIPPET_TY, text_of_command);
		!print "(storing text of command: ", (I7_INDEXED_TEXT_TY_Say) I7_Blk_Get(stora, 5), " at ", I7_Blk_Get(stora, 5), ")^";
	} else I7_Blk_Put(stora, 5, 0);
	return stora;
];

[ I7_try_STORED_ACTION_TY stora ks text_of_command saved_command;
	!print "I7_try_STORED_ACTION_TY on ", stora, "^";
	if ((stora==0) || (I7_Blk_Type(stora) ~= STORED_ACTION_TY)) return;
	if (ks) { @push keep_silent; keep_silent=1; }
	text_of_command = I7_Blk_Get(stora, 5);
	if (text_of_command) {
		saved_command = I7_INDEXED_TEXT_TY_Create();
		I7_INDEXED_TEXT_TY_Cast(I7_command, SNIPPET_TY, saved_command);
		I7_IT_SetPlayersCommand(text_of_command);
		!print "(switching to text of command: ", (I7_INDEXED_TEXT_TY_Say) text_of_command, ")^";
	}
	!print "TRY^";
	I7_TryAction(I7_Blk_Get(stora, 4), I7_Blk_Get(stora, 3),
		I7_Blk_Get(stora, 0), I7_Blk_Get(stora, 1), I7_Blk_Get(stora, 2));
	!print "END TRY^";
	if (text_of_command) {
		!print "(switching back to: ", (I7_INDEXED_TEXT_TY_Say) saved_command, ")^";
		I7_IT_SetPlayersCommand(saved_command);
		I7_Blk_Free(saved_command);
	}
	if (ks) { @pull keep_silent; }
];

#IFNOT; ! IFDEF I7_HEAP_SIZE

[ I7_STORED_ACTION_TY_Say stora; ];

[ I7_new_STORED_ACTION_TY a n s ac req stora; return false; ];

#ENDIF; ! IFDEF I7_HEAP_SIZE

! End of StoredAction.i6

! Lists.i6

#IFDEF I7_HEAP_SIZE; ! Will exist if any use is made of heap

! A list is organised as:
! Word 0: base type stored within
! Word 1: length
! Words 2, ..., L+1: entries

Constant BASE_KIND_F = 0;
Constant LIST_LENGTH_F = 1;
Constant LIST_ENTRY_COMPARE_F = 2;
Constant LIST_ENTRY_BASE = 3;

! Compulsory services required by NI:

[ I7_LIST_OF_TY_Create skov list;
	list = I7_Blk_Allocate(24*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);
	I7_Blk_Put(list, BASE_KIND_F, skov);
	I7_Blk_Put(list, LIST_LENGTH_F, 0);
	I7_Blk_Put(list, LIST_ENTRY_COMPARE_F, I7_Comparison_Function_for_KOV(skov));
	return list;
];

[ I7_LIST_OF_TY_CopyRawArray list arr len i ex bk v w;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return false;
	ex = I7_Blk_Get_Extent(list);
!print "Extent ex = ", ex, "^";
!print "len = ", len, "^";
	len = arr-->2;
	if (len+LIST_ENTRY_BASE > ex) {
		if (I7_Blk_Change_Extent(list, len+LIST_ENTRY_BASE) == false)
			return 0;
	}
!print "Extended ok^";
	I7_Blk_Put(list, LIST_LENGTH_F, len);
	bk = arr-->1;
	I7_Blk_Put(list, BASE_KIND_F, bk);
	I7_Blk_Put(list, LIST_ENTRY_COMPARE_F, I7_Comparison_Function_for_KOV(arr-->1));
	for (i=0:i<len:i++) {
		v = arr-->(i+3);
		if (bk == LIST_OF_TY) {
			w = I7_LIST_OF_TY_Create(v-->1);
			I7_LIST_OF_TY_CopyRawArray(w, v);
			I7_Blk_Put(list, i+LIST_ENTRY_BASE, w);
		} else {
			I7_Blk_Put(list, i+LIST_ENTRY_BASE, v);
		}
	}
!	I7_LIST_OF_TY_Say(list, true);
	return list;
];

[ I7_LIST_OF_TY_Say list format dsize v i bk;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	bk = I7_Blk_Get(list, BASE_KIND_F);
	! print "(kov=", bk, ")";
	if (format == 1) print "{";
	for (i=0:i<dsize:i++) {
		v = I7_Blk_Get(list, i+LIST_ENTRY_BASE);
		switch (format) {
			2: print (the) v;
			3: print (a) v;
			default:
				if (bk == LIST_OF_TY) I7_LIST_OF_TY_Say(v, 1);
				else if ((bk == TEXT_TY or INDEXED_TEXT_TY) && (format == 1)) {
					print "~"; I7_Print_Kind_Value_Pair(bk, v); print "~";
				}
				else I7_Print_Kind_Value_Pair(bk, v);
		}
		if (i<dsize-2) print ", ";
		if (i==dsize-2) {
			#ifdef USE_SERIAL_COMMA; print ","; #endif;
			if (format == 1) print ", "; else print " and ";
		}
	}
	if (format == 1) print "}";
];

[ I7_LIST_OF_TY_Compare listleft listright delta dsize i cf;
	delta = I7_Blk_Get(listleft, BASE_KIND_F) - I7_Blk_Get(listright, BASE_KIND_F);
	if (delta) return delta;
	delta = I7_Blk_Get(listleft, LIST_LENGTH_F) - I7_Blk_Get(listright, LIST_LENGTH_F);
	if (delta) return delta;
	dsize = I7_Blk_Get(listleft, LIST_LENGTH_F);
	cf = I7_Blk_Get(listleft, LIST_ENTRY_COMPARE_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<dsize; i++) {
			delta = I7_Blk_Get(listleft, i+LIST_ENTRY_BASE) -
				I7_Blk_Get(listright, i+LIST_ENTRY_BASE);
			if (delta) return delta;
		}
	} else {
		for (i=0; i<dsize; i++) {
			delta = cf(I7_Blk_Get(listleft, i+LIST_ENTRY_BASE),
				I7_Blk_Get(listright, i+LIST_ENTRY_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ I7_LIST_OF_TY_Distinguish txb1 txb2;
	if (I7_LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ I7_LIST_OF_TY_Free list dsize i;
	if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F))) {
		dsize = I7_Blk_Get(list, LIST_LENGTH_F);
		for (i=0; i<dsize; i++) {
			I7_Blk_Free(I7_Blk_Get(list, i+LIST_ENTRY_BASE));
		}
		!print "All ", dsize, " freed^";
	}
	return list;
];

[ I7_LIST_OF_TY_Deep_Copy lto lfrom list dsize i nv bk;
	if (I7_KOV_On_Heap(I7_Blk_Get(lfrom, BASE_KIND_F))) {
		dsize = I7_Blk_Get(lfrom, LIST_LENGTH_F);
		bk = I7_Blk_Get(lfrom, BASE_KIND_F);
		for (i=0; i<dsize; i++) {
			nv = I7_Blk_Create(bk);
			I7_Blk_Deep_Copy(nv, I7_Blk_Get(lfrom, i+LIST_ENTRY_BASE));
			I7_Blk_Put(lto, i+LIST_ENTRY_BASE, nv);
		}
	}
];

! Optional services used only by definitions in the Standard Rules:

[ I7_LIST_OF_TY_Desc list desc obj dsize ex len i;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return false;
	ex = I7_Blk_Get_Extent(list);
	len = 0;
	for (obj=desc(-2, nothing): obj: obj=desc(-2, obj)) len++;
	if (len+LIST_ENTRY_BASE > ex) {
		if (I7_Blk_Change_Extent(list, len+LIST_ENTRY_BASE) == false)
			return 0;
	}
	I7_Blk_Put(list, BASE_KIND_F, OBJECT_TY);
	I7_Blk_Put(list, LIST_LENGTH_F, len);
	for (obj=desc(-2, nothing), i=0: obj: obj=desc(-2, obj), i++)
		I7_Blk_Put(list, i+LIST_ENTRY_BASE, obj);
	return list;
];

[ I7_LIST_OF_TY_Add_Entry list v posnflag posn nodups i dsize ex nv;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return false;
	if (nodups && (I7_LIST_OF_TY_Find_Entry(list, v))) return list;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (posnflag) {
		if ((posn<1) || (posn > dsize+1)) {
			print "*** Couldn't add at entry ", posn, " in the list ";
			I7_LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", dsize, " ***^";
			rfalse;
		}
	}
	ex = I7_Blk_Get_Extent(list);
	if (dsize+LIST_ENTRY_BASE+1 > ex) {
		if (I7_Blk_Change_Extent(list, ex+16) == false) return 0;
	}
	if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F))) {
		nv = I7_Blk_Create(I7_Blk_Get(list, BASE_KIND_F));
		I7_Blk_Deep_Copy(nv, v);
		v = nv;
	}
	if (posnflag) {
		posn--;
		for (i=dsize:i>posn:i--) {
			I7_Blk_Put(list, i+LIST_ENTRY_BASE,
				I7_Blk_Get(list, i-1+LIST_ENTRY_BASE));			
		}
		I7_Blk_Put(list, posn+LIST_ENTRY_BASE, v);
	} else {
		I7_Blk_Put(list, dsize+LIST_ENTRY_BASE, v);
	}
	I7_Blk_Put(list, LIST_LENGTH_F, dsize+1);
	return list;
];

[ I7_LIST_OF_TY_AppendList list more posnflag posn nodups v i j dsize msize ex nv;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return false;
	if ((more==0) || (I7_Blk_Type(more) ~= LIST_OF_TY)) return list;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (posnflag) {
		if ((posn<1) || (posn > dsize+1)) {
			print "*** Couldn't add at entry ", posn, " in the list ";
			I7_LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", dsize, " ***^";
			rfalse;
		}
	}
	msize = I7_Blk_Get(more, LIST_LENGTH_F);
	ex = I7_Blk_Get_Extent(list);
	if (dsize+msize+LIST_ENTRY_BASE > ex) {
		if (I7_Blk_Change_Extent(list, dsize+msize+LIST_ENTRY_BASE+8) == false)
			return 0;
	}
	if (posnflag) {
		posn--;
		for (i=dsize+msize:i>=posn+msize:i--) {
			I7_Blk_Put(list, i+LIST_ENTRY_BASE,
				I7_Blk_Get(list, i-msize+LIST_ENTRY_BASE));			
		}
		I7_Blk_Put(list, posn, v);
		for (j=0: j<msize: j++) {
			v = I7_Blk_Get(more, j+LIST_ENTRY_BASE);
			if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F))) {
				nv = I7_Blk_Create(I7_Blk_Get(list, BASE_KIND_F));
				I7_Blk_Deep_Copy(nv, v);
				v = nv;
			}
			I7_Blk_Put(list, posn+j+LIST_ENTRY_BASE, v);
		}
	} else {
		for (i=0, j=0: i<msize: i++) {
			v = I7_Blk_Get(more, i+LIST_ENTRY_BASE);
			if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F))) {
				nv = I7_Blk_Create(I7_Blk_Get(list, BASE_KIND_F));
				I7_Blk_Deep_Copy(nv, v);
				v = nv;
			}
			if ((nodups == 0) || (I7_LIST_OF_TY_Find_Entry(list, v) == false)) {
				I7_Blk_Put(list, dsize+j+LIST_ENTRY_BASE, v);
				j++;
			}
		}
	}
	I7_Blk_Put(list, LIST_LENGTH_F, dsize+j);
	return list;
];

[ I7_LIST_OF_TY_Find_Entry list v i dsize cf;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) rfalse;
	cf = I7_Blk_Get(list, LIST_ENTRY_COMPARE_F);
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<dsize; i++)
			if (v == I7_Blk_Get(list, i+LIST_ENTRY_BASE)) rtrue;
	} else {
		for (i=0; i<dsize; i++)
			if (cf(v, I7_Blk_Get(list, i+LIST_ENTRY_BASE)) == 0) rtrue;
	}
	rfalse;
];

[ I7_LIST_OF_TY_Remove_Entry list v forgive i j dsize odsize f cf;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) rfalse;
	cf = I7_Blk_Get(list, LIST_ENTRY_COMPARE_F);
	dsize = I7_Blk_Get(list, LIST_LENGTH_F); odsize = dsize;
	for (i=0; i<dsize; i++) {
		if (cf == 0 or UnsignedCompare)
			f = (v == I7_Blk_Get(list, i+LIST_ENTRY_BASE));
		else
			f = (cf(v, I7_Blk_Get(list, i+LIST_ENTRY_BASE)) == 0);
		if (f) {
			if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F))) {
				I7_Blk_Free(I7_Blk_Get(list, i+LIST_ENTRY_BASE));
			}
			for (j=i+1; j<dsize; j++)
				I7_Blk_Put(list, j-1+LIST_ENTRY_BASE,
					I7_Blk_Get(list, j+LIST_ENTRY_BASE));
			dsize--; i--;
			I7_Blk_Put(list, LIST_LENGTH_F, dsize);
		}
	}
	if (odsize ~= dsize) rfalse;
	if (forgive) rfalse;
	print "*** Couldn't remove: the value ";
	I7_Print_Kind_Value_Pair(I7_Blk_Get(list, BASE_KIND_F), v);
	print " was not present in the list ";
	I7_LIST_OF_TY_Say(list, true);
	" ***";
];

[ I7_LIST_OF_TY_Remove_Range list from to forgive i d dsize;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) rfalse;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if ((from > to) || (from <= 0) || (to > dsize)) {
		if (forgive) {
			if (from <= 0) from = 1;
			if (to >= dsize) to = dsize;
			if (from > to) return list;
		} else {
			print "*** Couldn't remove entries ", from, " to ", to, " from the list ";
			I7_LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", dsize, " ***^";
			rfalse;
		}
	}
	to--; from--;
	d = to-from+1;
	for (i=from: i<dsize-d: i++)
		I7_Blk_Put(list, i+LIST_ENTRY_BASE,
			I7_Blk_Get(list, i+d+LIST_ENTRY_BASE));
	I7_Blk_Put(list, LIST_LENGTH_F, dsize-d);
	return list;
];

[ I7_LIST_OF_TY_Remove_List list rlist i j k v w dsize odsize rsize cf f;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) rfalse;
	!print "Remove "; I7_LIST_OF_TY_Say(rlist, true);
	!print " from ";I7_LIST_OF_TY_Say(list, true);
	dsize = I7_Blk_Get(list, LIST_LENGTH_F); odsize = dsize;
	rsize = I7_Blk_Get(rlist, LIST_LENGTH_F);
	cf = I7_Blk_Get(list, LIST_ENTRY_COMPARE_F);
	for (i=0: i<dsize: i++) {
		v = I7_Blk_Get(list, i+LIST_ENTRY_BASE);
		for (k=0: k<rsize: k++) {
			w = I7_Blk_Get(rlist, k+LIST_ENTRY_BASE);
			if (cf == 0 or UnsignedCompare)
				f = (v == w);
			else
				f = (cf(v, w) == 0);
			if (f) {
				! print "[out: ", (name) v, "] ";
				if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F))) {
					I7_Blk_Free(v);
				}
				for (j=i+1: j<dsize: j++)
					I7_Blk_Put(list, j+LIST_ENTRY_BASE-1, 
						I7_Blk_Get(list, j+LIST_ENTRY_BASE));
				dsize--; i--;
				I7_Blk_Put(list, LIST_LENGTH_F, dsize);
				break;
			}
		}
	}
	!print " --> ";I7_LIST_OF_TY_Say(list, true); print "^";
	rfalse;
];

[ I7_LIST_OF_TY_Get_Entry list i dsize;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return false;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if ((i<=0) || (i>dsize)) return false;
	return I7_Blk_Get(list, LIST_ENTRY_BASE+i-1);
];

[ WriteI7_LIST_OF_TY_Get_Entry list i val dsize;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return false;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if ((i<=0) || (i>dsize)) {
		print "*** Couldn't write to list entry ", i, ": the list ";
		I7_LIST_OF_TY_Say(list, true);
		switch (dsize) {
			0: " is empty ***";
			1: " has only one entry, numbered 1 ***";
		}
		" has entries numbered from 1 to ", dsize, " ***";
	}
	I7_Blk_Put(list, LIST_ENTRY_BASE+i-1, val);
];

[ I7_LIST_OF_TY_Put_Entry list i v dsize nv;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return false;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F))) {
		nv = I7_Blk_Create(I7_Blk_Get(list, BASE_KIND_F));
		I7_Blk_Deep_Copy(nv, v);
		v = nv;
	}
	if ((i<=0) || (i>dsize)) return false;
	I7_Blk_Put(list, LIST_ENTRY_BASE+i-1, v);
];

[ I7_LIST_OF_TY_Get_Length list;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return 0;
	return I7_Blk_Get(list, LIST_LENGTH_F);
];

[ I7_LIST_OF_TY_Set_Length list newsize fl truncend dsize ex i dv;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return 0;
	if (newsize < 0) "*** Cannot resize a list to negative length ***";
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (dsize < newsize) {
		if (fl == -1) return list;
		ex = I7_Blk_Get_Extent(list);
		if (newsize+LIST_ENTRY_BASE > ex) {
			if (I7_Blk_Change_Extent(list, newsize+LIST_ENTRY_BASE) == false)
				return 0;
		}
		dv = I7_Default_Value_of_KOV(I7_Blk_Get(list, BASE_KIND_F));
		for (i=dsize: i<newsize: i++)
			I7_Blk_Put(list, LIST_ENTRY_BASE+i, dv);
		I7_Blk_Put(list, LIST_LENGTH_F, newsize);
	}
	if (dsize > newsize) {
		if (fl == 1) return list;
		if (truncend == -1) {
			if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F)))
				for (i=0: i<dsize-newsize: i++)
					I7_Blk_Free(I7_Blk_Get(list, LIST_ENTRY_BASE+i));
			for (i=0: i<newsize: i++)
				I7_Blk_Put(list, LIST_ENTRY_BASE+i,
					I7_Blk_Get(list, LIST_ENTRY_BASE+dsize-newsize+i));
		} else {
			if (I7_KOV_On_Heap(I7_Blk_Get(list, BASE_KIND_F)))
				for (i=newsize: i<dsize: i++)
					I7_Blk_Free(I7_Blk_Get(list, LIST_ENTRY_BASE+i));
		}
		I7_Blk_Put(list, LIST_LENGTH_F, newsize);
	}
	return list;
];

[ I7_LIST_OF_TY_Reverse list dsize i v;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return 0;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (dsize < 2) return list;
	for (i=0;i*2<dsize;i++) {
		v = I7_Blk_Get(list, LIST_ENTRY_BASE+i);
		I7_Blk_Put(list, LIST_ENTRY_BASE+i, I7_Blk_Get(list, LIST_ENTRY_BASE+dsize-1-i));
		I7_Blk_Put(list, LIST_ENTRY_BASE+dsize-1-i, v);
	}
	return list;
];

[ I7_LIST_OF_TY_Rotate list backwards dsize i v;
	if ((list==0) || (I7_Blk_Type(list) ~= LIST_OF_TY)) return 0;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (dsize < 2) return list;
	if (backwards) {
		v = I7_Blk_Get(list, LIST_ENTRY_BASE);
		for (i=0:i<dsize-1:i++)
			I7_Blk_Put(list, LIST_ENTRY_BASE+i,
				I7_Blk_Get(list, LIST_ENTRY_BASE+i+1));
		I7_Blk_Put(list, dsize-1+LIST_ENTRY_BASE, v);
	} else {
		v = I7_Blk_Get(list, dsize-1+LIST_ENTRY_BASE);
		for (i=dsize-1:i>0:i--)
			I7_Blk_Put(list, LIST_ENTRY_BASE+i,
				I7_Blk_Get(list, LIST_ENTRY_BASE+i-1));
		I7_Blk_Put(list, LIST_ENTRY_BASE, v);
	}
	return list;
];

[ ListSwapEntries list i j v;
	if (i==j) return;
	v = I7_Blk_Get(list, LIST_ENTRY_BASE+i-1);
	I7_Blk_Put(list, LIST_ENTRY_BASE+i-1, I7_Blk_Get(list, LIST_ENTRY_BASE+j-1));
	I7_Blk_Put(list, LIST_ENTRY_BASE+j-1, v);
];

[ ListCompareEntries list col i j d cf;
	if (i==j) return 0;
	if (I7S_Col) {
		i = I7_Blk_Get(list, LIST_ENTRY_BASE+i-1);
		j = I7_Blk_Get(list, LIST_ENTRY_BASE+j-1);
		!print "prop=", I7S_Col, " on ", (name) i, " and ", (name) j, "^";
		!print "thus ", i.I7S_Col, " and ", j.I7S_Col, "^";
		if (i provides I7S_Col) i=i.I7S_Col; else i=0;
		if (j provides I7S_Col) j=j.I7S_Col; else j=0;
		return i - j;
	}
	cf = I7_Blk_Get(list, LIST_ENTRY_COMPARE_F);
	if (cf == 0)
		return I7_Blk_Get(list, LIST_ENTRY_BASE+i-1) -
			I7_Blk_Get(list, LIST_ENTRY_BASE+j-1);
	else
		return cf(I7_Blk_Get(list, LIST_ENTRY_BASE+i-1),
			I7_Blk_Get(list, LIST_ENTRY_BASE+j-1));
];

[ I7_LIST_OF_TY_Sort list dir prop i j dsize v;
	dsize = I7_Blk_Get(list, LIST_LENGTH_F);
	if (dir == 2) {
		if (dsize < 2) return;
		for (i=1:i<dsize:i++) {
			j = random(i+1) - 1;
			v = I7_Blk_Get(list, LIST_ENTRY_BASE+i);
			I7_Blk_Put(list, LIST_ENTRY_BASE+i, I7_Blk_Get(list, LIST_ENTRY_BASE+j));
			I7_Blk_Put(list, LIST_ENTRY_BASE+j, v);
		}
		return;
	}
	I7S_Tab = list;
	I7S_Col = prop;
	I7S_Dir = dir;
	I7S_Swap = ListSwapEntries;
	I7S_Comp = ListCompareEntries;
	I7_Sort_Range(0, dsize);
];

#IFNOT; ! IFDEF I7_HEAP_SIZE

[ I7_LIST_OF_TY_Say list; ];
[ I7_LIST_OF_TY_Create o; ];
[ I7_LIST_OF_TY_Cast a b c; ];

#ENDIF; ! IFDEF I7_HEAP_SIZE

! End of Lists.i6

[ I7_Create_Blk_Consts;
];




! End of automatically generated I6 source
! --------------------------------------------------------------------------
